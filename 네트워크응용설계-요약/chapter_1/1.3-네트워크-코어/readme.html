<!DOCTYPE html> <html><head>
		<title>README</title>
		<base href="..\..\..\..\../">
		<meta id="root-path" root-path="..\..\..\..\../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Obsidian_main - README">
		<meta property="og:title" content="README">
		<meta property="og:description" content="Obsidian_main - README">
		<meta property="og:type" content="website">
		<meta property="og:url" content="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_1/1.3-네트워크-코어/readme.html">
		<meta property="og:image" content="https://user-images.githubusercontent.com/86337233/210137238-bf8d10d3-ef09-4263-9339-7fedbb2d619e.png">
		<meta property="og:site_name" content="Obsidian_main">
		<meta name="author" content="dustbox"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title show-ribbon mk-readable-line mk-folder-lines mk-spaces-enabled mk-inline-context-enabled mk-flow-seamless"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="1.3 네트워크 코어"><p dir="auto">1.3 네트워크 코어</p></h1><div class="heading-wrapper"><div class="heading-children"><div><p dir="auto">1.2절의 종단 시스템을 연결하는 패킷 스위치와 링크의 그물망(mesh)에 대하여 살펴보도록 하자.</p></div><div><p dir="auto">아래 그림에서의 굵은 선들은 네트워크 코어를 나타낸 것이다.</p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210137238-bf8d10d3-ef09-4263-9339-7fedbb2d619e.png" alt="네트워크 코어" referrerpolicy="no-referrer" style="width: 450px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto"><strong>링크와 스위치의 네트워크를 통해 데이터를 이동시키는</strong> 두 가지 기본 방식</p></div><div><ol dir="auto">
<li data-line="0" dir="auto"><code>패킷 교환(packet switching)</code> : 보장되지 않는 (e.g., 인터넷)</li>
<li data-line="1" dir="auto"><code>회선 교환(circuit switching)</code> : 자원을 예약 → 보장된</li>
</ol></div><div><br>
<br>
<br></div></div></div><div class="heading-wrapper"><h1 data-heading="1.3.1 패킷 교환(packet switching)" dir="auto" class="heading" id="1.3.1_패킷_교환(packet_switching)">1.3.1 패킷 교환(packet switching)</h1><div class="heading-children"><div><p dir="auto">종단 시스템들은 서로 <code>메시지(message)</code>를 교환한다. (<strong>출발지 종단 시스템에서 목적지 종단 시스템으로</strong> 메시지를 보냄)</p></div><div><br></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">송신 시스템은 메시지를 <code>패킷(packet)</code>이라고 하는 작은 데이터 덩어리로 분할한다.</p>
</li>
<li data-line="3" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">각 패킷은 <code>통신 링크(communication link)</code>와 <code>패킷 스위치(packet switch)</code>를 거치게 된다.</p>
<ul dir="auto">
<li data-line="4" dir="auto">패킷 스위치에는 <b>라우터(router)</b>와 <b>링크 계층 스위치(link-layer switch)</b>의 두 가지 유형이 존재한다.</li>
</ul>
</li>
<li data-line="7" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">패킷은 <strong>링크의 최대 전송률과 같은 속도로</strong> 각각의 통신 링크에서 전송된다.</p>
<ul dir="auto">
<li data-line="8" dir="auto">출발지 종단 시스템 혹은 패킷 스위치가 <code>R bps(bits per second)</code>의 속도로 링크에서 <code>L 비트</code>의 패킷을 송신한다면,<br>
그 패킷을 전송하는 데 걸리는 시간은 <code>L/R 초</code></li>
</ul>
</li>
</ol></div><div><br>
<br></div><div class="heading-wrapper"><h2 data-heading="저장-후-전달 전송(store-and-forward transmission) 방식" dir="auto" class="heading" id="저장-후-전달_전송(store-and-forward_transmission)_방식"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>저장-후-전달 전송(store-and-forward transmission) 방식</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 스위치가 패킷의 첫 비트를 출력 링크로 전송하기 전에 <strong>전체 패킷</strong>을 받아야 한다.</p>
</blockquote></div><div><p dir="auto"><code>저장-후-전달 전송 방식</code>은 대부분의 패킷 스위치가 이용하는 방식이다.</p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210137289-63c6e459-0892-4ee6-8a91-d35fe4f9fb51.png" alt="저장-후-전달 패킷 교환" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">위는 하나의 라우터로 연결되고 2개의 종단 시스템으로 구성된 매우 간단한 네트워크 예시이다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">출발지는 목적지로 전송할 3개의 패킷(1, 2, 3)을 가지고 있으며, <strong>각각의 패킷은 L 비트로 구성되어 있다.</strong></li>
<li data-line="1" dir="auto">출발지는 링크에서 L 비트의 패킷을 <strong>R bps(bits per second)의 속도로 송신</strong>하고 있다.</li>
</ul></div><div><br></div><div><p dir="auto">그림에서 보이는 것처럼 출발지는 <code>패킷 1의 일부분</code>을 전송했고, 그 부분이 라우터에 도착해있는 상황을 생각해보자.</p></div><div><p dir="auto">이때 라우터는 저장-후-전달 방식을 채택하고 있기 때문에 수신한 비트를 전송할 수 없다. 그 대신, 아래의 과정이 진행된다.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">패킷의 비트를 먼저 <code>저장(buffer, 즉 ‘store’)</code>한다.</li>
<li data-line="1" dir="auto"><strong>라우터가 패킷의 모든 비트를 수신하였다면</strong> 그제서야 출력 링크로 그 패킷을 <code>전송(transmit, 즉 ‘forward’)</code>하기 시작한다.</li>
</ol></div><div><br></div><div class="heading-wrapper"><h3 data-heading="경과 시간에 대한 계산" dir="auto" class="heading" id="경과_시간에_대한_계산"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>경과 시간에 대한 계산</h3><div class="heading-children"><div><pre dir="auto"><code>1-1. 출발지에서 패킷 1을 송신하기 시작해서 패킷 1의 전체를 목적지에서 수신할 때까지의 경과 시간을 계산해보자.
</code><button class="copy-code-button">복사</button></pre></div><div><p dir="auto"><em>여기서 전파 지연(propagation delay)은 무시하도록 하자. 이는 비트가 빛의 속도에 가까운 속도로 통신선을 거쳐가는 데에 걸리는 시간을 말한다.<br>
→ 1.4절에서 논의</em></p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><code>0 초</code> : 출발지가 패킷 1을 전송하기 시작</li>
<li data-line="1" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>L/R 초</code>
<ul dir="auto">
<li data-line="2" dir="auto">출발지는 패킷 1의 전체 데이터를 전송 완료했으며, 전체가 라우터에 수신되고 저장되었다. (전파 지연이 없기 때문)</li>
<li data-line="3" dir="auto"><strong>라우터가 전체 패킷을 수신했기 때문에</strong> 라우터는 목적지를 향해 그 패킷을 출력 링크로 전송하기 시작한다.</li>
</ul>
</li>
<li data-line="4" dir="auto"><code>2L/R 초</code> : 라우터는 전체 패킷을 전송했으며, 목적지는 패킷 1 전체를 수신 완료한다. (전파 지연이 없기 때문)</li>
</ul></div><div><br></div><div><p dir="auto">따라서 저장-후-전달 전송 방식을 채택한다면 전체 지연은 <code>2L/R</code>이며,<br>
이 방식 없이 스위치에 비트가 도착하자마자 곧바로 전달을 하게 된다면 전체 지연은 <code>L/R</code>이 된다.</p></div><div><p dir="auto">하지만 라우터는 전달하기에 앞서 전체 패킷을 수신, 저장, 처리할 필요가 있다. <em>(이것도 1.4절에서 자세히 논의한다.)</em></p></div><div><br></div><div><pre dir="auto"><code>1-2. 출발지가 패킷 1을 송신하기 시작한 순간부터 목적지 노드가 3개의 모든 패킷(1, 2, 3)을 수신할 때까지 경과된 전체 시간을 계산해보자.
</code><button class="copy-code-button">복사</button></pre></div><div><ul dir="auto">
<li data-line="0" dir="auto"><code>0 초</code> : 출발지가 패킷 1을 전송하기 시작</li>
<li data-line="1" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>L/R 초</code>
<ul dir="auto">
<li data-line="2" dir="auto">라우터는 패킷 1을 수신 완료, 이를 전송하기 시작</li>
<li data-line="3" dir="auto">출발지는 패킷 2를 전송하기 시작</li>
</ul>
</li>
<li data-line="4" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>2L/R 초</code>
<ul dir="auto">
<li data-line="5" dir="auto">라우터는 패킷 2를 수신 완료, 이를 전송하기 시작</li>
<li data-line="6" dir="auto">목적지는 패킷 1 전체를 수신 완료</li>
<li data-line="7" dir="auto">출발지는 패킷 3을 전송하기 시작</li>
</ul>
</li>
<li data-line="8" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>3L/R 초</code>
<ul dir="auto">
<li data-line="9" dir="auto">라우터는 패킷 3를 수신 완료, 이를 전송하기 시작</li>
<li data-line="10" dir="auto">목적지는 패킷 2 전체를 수신 완료</li>
</ul>
</li>
<li data-line="11" dir="auto"><code>4L/R 초</code> : 목적지는 패킷 3 전체를 수신 완료</li>
</ul></div><div><br></div><div><p dir="auto">따라서 저장-후-전달 전송 방식을 채택한다면 목적지는 <code>4L/R</code> 초에 3개의 모든 패킷을 수신하게 된다.</p></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="종단 간 지연" dir="auto" class="heading" id="종단_간_지연"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>종단 간 지연</h3><div class="heading-children"><div><pre dir="auto"><code>2. 출발지로부터 목적지 노드까지 N개의 링크로 구성되고 각각은 전송률이 R인 경로를 통해 하나의 패킷을 전송하는 경우를 생각해보자.
</code><button class="copy-code-button">복사</button></pre></div><div><p dir="auto">즉, 출발지와 목적지 사이에 N-1개의 라우터가 존재한다는 것이다.</p></div><div><p dir="auto">실제로 라우터는 보통 여러 개의 링크를 갖는데, 그 이유는 라우터의 기능이 <strong>입력되는 패킷을 출력 링크로 교환</strong>하는 것이기 때문이다.</p></div><div><br></div><div><p dir="auto">1-1, 1-2와 같은 논리를 적용한다면 <strong>종단 간 지연</strong>은 다음과 같음을 알 수 있다.</p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210137330-0534c802-b6cd-41e4-915d-d8a3dac5d07a.png" alt="종단 간 지연" referrerpolicy="no-referrer" style="width: 250px; max-width: 100%;"></p></div><div><br>
<br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="큐잉 지연(queuing delay)과 패킷 손실" dir="auto" class="heading" id="큐잉_지연(queuing_delay)과_패킷_손실"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>큐잉 지연(queuing delay)과 패킷 손실</h2><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">각 패킷 스위치는 접속된 여러 <code>링크</code>를 가지고 있으며, 패킷 스위치는 <strong>각 링크에 대해</strong> <code>출력 버퍼</code><strong>를 가지고 있다.</strong></li>
<li data-line="1" dir="auto">출력 버퍼(output buffer)는 출력 큐(output queue)로도 불리며, <strong>그 링크로 송신하려고 하는 패킷을 저장하고 있다.</strong><br>
이는 <code>패킷 교환</code>에서 중요한 역할을 한다.</li>
</ul></div><div><p dir="auto">패킷이 겪는 지연은 앞에서 보았던 저장-후-전달 지연만 존재하는 것이 아니다.</p></div><div><br></div><div><pre dir="auto"><code>도착하는 패킷은 한 링크로 전송되어야 한다. 하지만 만약 그 링크가 다른 패킷을 전송하고 있는 중이라면 어떻게 해야 하는가?
</code><button class="copy-code-button">복사</button></pre></div><div><p dir="auto"><strong>→ 도착하는 패킷은 출력 버퍼에서 대기해야 한다.</strong> = <code>큐잉 지연</code></p></div><div><ul dir="auto">
<li data-line="0" dir="auto">큐잉 지연은 가변적이며, 네트워크의 혼잡 정도에 따른다.</li>
<li data-line="1" dir="auto">버퍼 공간의 크기는 유한하기 때문에 <code>패킷 손실(packet loss)</code>이 발생할 수 있다.</li>
<li data-line="2" dir="auto">즉, 버퍼가 전송을 위해 대기 중인 다른 패킷들로 꽉 차 있는 경우라면 <b>도착하는 패킷 또는 큐에 대기 중인 패킷을 폐기(drop)</b>하는 것이다.</li>
</ul></div><div><br></div><div><p dir="auto">아래의 예시를 보자.</p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210137348-9f7c303f-5261-4e62-8885-36e36eeb4dea.png" alt="패킷 교환" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">여기서 라우터는 수신한 패킷을 15 Mbps의 링크로 전달하고 있다.</p></div><div><p dir="auto">만약 짧은 기간 동안 라우터에 도착하는 패킷의 전송률이 15 Mbps를 초과하게 된다면, 링크의 출력 버퍼에 패킷들이 큐잉될 것이다.</p></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="포워딩 테이블과 라우팅 프로토콜" dir="auto" class="heading" id="포워딩_테이블과_라우팅_프로토콜"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>포워딩 테이블과 라우팅 프로토콜</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">라우터는 접속된 통신 링크 중 하나로 도착하는 패킷을 받아, <strong>접속된 통신 링크 중 다른 링크로 그 패킷을 전달한다.</strong></p>
</blockquote></div><div><p dir="auto">그렇다면 라우터는 그 패킷을 어느 링크로 전달해야 하는지를 어떻게 결정할까?</p></div><div><p dir="auto"><em>패킷 전달은 실제 여러 유형의 컴퓨터 네트워크에서 다른 방식으로 실행되는데, 여기서는 라우팅이 <strong>인터넷</strong>에서 어떻게 실행되는지를 간단히 설명한다.</em></p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="IP 주소" dir="auto" class="heading" id="IP_주소"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>IP 주소</h3><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">인터넷에서 모든 종단 시스템은 IP 주소를 가지며, 이 주소는 계층적 구조를 갖는다.</li>
<li data-line="1" dir="auto">출발지 종단 시스템이 목적이 종단 시스템으로 패킷을 보내고자 할 때 <strong>출발지는 패킷의 헤더에 목적지의 IP 주소를 포함한다.</strong></li>
</ul></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="포워딩 테이블(forwarding table)" dir="auto" class="heading" id="포워딩_테이블(forwarding_table)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>포워딩 테이블(forwarding table)</h3><div class="heading-children"><div><p dir="auto">각 라우터는 <strong>목적지 주소 또는 목적지 주소의 일부를 라우터의 출력 링크로 매핑</strong>하는 포워딩 테이블을 가지고 있다.</p></div><div><p dir="auto">따라서 라우터가 수신한 패킷을 어느 링크로 전달해야 하는지를 결정하는 과정은 다음과 같다.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">패킷이 라우터에 도착한다.</li>
<li data-line="1" dir="auto">라우터는 패킷의 IP 주소를 조사한다.</li>
<li data-line="2" dir="auto">해당 목적지 주소를 이용하여 포워딩 테이블을 검색한다.</li>
<li data-line="3" dir="auto">그 패킷을 출력 링크로 보낸다.</li>
</ol></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="라우팅 프로토콜(routing protocol)" dir="auto" class="heading" id="라우팅_프로토콜(routing_protocol)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>라우팅 프로토콜(routing protocol)</h3><div class="heading-children"><div><p dir="auto">그렇다면 포워딩 테이블은 어떻게 설정되는 것일까? <em>(5장에서 자세히 논의)</em></p></div><div><p dir="auto">인터넷은 <strong>자동으로 포워딩 테이블을 설정하는 데 이용되는</strong> 여러 특별한 라우팅 프로토콜을 가지고 있다.</p></div><div><p dir="auto">e.g., 각 라우터로부터 각 목적지까지 최단 경로를 결정 → 라우터에 포워팅 테이블을 설정하는 데에는 이 최단 경로 결과를 이용한다.</p></div><div><br>
<br>
<br></div></div></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="1.3.2 회선 교환(circuit switching)" dir="auto" class="heading" id="1.3.2_회선_교환(circuit_switching)">1.3.2 회선 교환(circuit switching)</h1><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">회선 교환 네트워크에서는 종단 시스템 간에 통신을 제공하기 위해<br>
<b>경로상에서 필요한 자원(버퍼, 링크 전송률)</b>은 통신 세션(session) 동안에 확보 또는 <code>예약(reserve)</code>된다. (↔︎ 패킷 교환 네트워크)</li>
<li data-line="2" dir="auto">세션 메시지는 <code>온디맨드(on-demand) 방식</code>으로 자원을 요청하여 사용한다.</li>
<li data-line="3" dir="auto">따라서 통신 링크에 대한 접속을 위해 <strong>큐에서 대기해야 할 수도 있다.</strong></li>
</ul></div><div><br></div><div><ul dir="auto">
<li data-line="0" dir="auto">연결 = <code>회선(circuit)</code> : 송신자와 수신자 간의 경로에 있는 스위치들이 해당 연결 상태를 유지해야 한다.</li>
</ul></div><div><ol dir="auto">
<li data-line="0" dir="auto">송신자가 정보를 보내기 전, 네트워크는 송신자와 수신자 간의 <strong>연결</strong>을 설정해야 한다.</li>
<li data-line="1" dir="auto">네트워크가 회선을 설정할 때, 그 연결이 이루어지는 동안 <strong>네트워크 링크에 일정한 전송률을 예약한다.</strong></li>
<li data-line="2" dir="auto">주어진 전송률이 송신자-수신자 연결을 위해 예약되기 때문에, <strong>송신자는 수신자에게</strong> <code>보장된(guaranteed)</code> <strong>일정 전송률로 데이터를 보낼 수 있다.</strong></li>
</ol></div><div><br></div><div class="heading-wrapper"><h3 data-heading="종단 간 연결(end-to-end connection)" dir="auto" class="heading" id="종단_간_연결(end-to-end_connection)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>종단 간 연결(end-to-end connection)</h3><div class="heading-children"><div><p dir="auto">아래는 4개의 스위치와 4개의 링크로 구성된 회선 교환 네트워크를 나타낸 그림이다.</p></div><div><p dir="auto">이들 각 링크는 4개의 회선을 가지므로 <strong>각 링크는 4개의 동시 연결을 지원할 수 있다.</strong></p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210137402-59bd4469-e343-430c-96df-9f5c6c072005.png" alt="회선 교환 네트워크" referrerpolicy="no-referrer" style="width: 470px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">만약 두 호스트가 통신하고 싶을 때, 네트워크는 두 호스트 사이에 지정된 <code>종단 간 연결</code>을 설정한다.</p></div><div><p dir="auto">즉, 호스트 A가 호스트 B와 통신하기 위해서 네트워크는 먼저 <strong>A의 링크와 B의 링크 각각에서 한 회선씩을 예약</strong>한다.<br>
(위 그림에서는 링크(0, 0)의 두 번째 회선, 링크(1, 1)의 두 번째 회선)</p></div><div><p dir="auto">각 링크에 대하여 연결이 지속되는 동안 해당 연결은 링크 전체 전송 용량의 1/4를 얻는다. (각 링크는 4개의 회선을 가지고 있기 때문)</p></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><pre dir="auto"><code>반대로, 한 호스트가 인터넷 같은 패킷 교환 네트워크를 통해 다른 호스트로 패킷을 보내고자 하는 경우에는 어떤 일이 발생할까?
</code><button class="copy-code-button">복사</button></pre></div><div><p dir="auto">회선 교환과 마찬가지로 패킷은 일련의 통신 링크를 통해 전송된다.</p></div><div><p dir="auto">하지만 회선 교환과는 다르게, <strong>패킷 교환은 링크 자원을 예약하지 않고 네트워크로 보내진다.</strong></p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 패킷 교환 네트워크는 일정한 시간 내에 데이터를 전달하는 것을 보장하지 않는다.</p>
</blockquote></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="회선 교환 네트워크에서의 다중화" dir="auto" class="heading" id="회선_교환_네트워크에서의_다중화"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>회선 교환 네트워크에서의 다중화</h2><div class="heading-children"><div><p dir="auto">링크 내 한 회선이 구현되는 방법</p></div><div><ol dir="auto">
<li data-line="0" dir="auto"><code>주파수 분할 다중화(Frequency-Division Multiplexing, FDM)</code> : 각 회선은 <strong>지속적으로</strong> 대역폭의 <strong>일부</strong>를 얻는다.</li>
<li data-line="1" dir="auto"><code>시분할 다중화(Time-Division Multiplexing, TDM)</code> : 각 회선은 <b>주기적으로</b>(짧은 시간 즉, 슬롯 동안) <strong>전체</strong> 대역폭을 얻는다.</li>
</ol></div><div><br></div><div class="heading-wrapper"><h3 data-heading="주파수 분할 다중화(Frequency-Division Multiplexing, FDM)" dir="auto" class="heading" id="주파수_분할_다중화(Frequency-Division_Multiplexing,_FDM)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>주파수 분할 다중화(Frequency-Division Multiplexing, FDM)</h3><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">링크를 통해 설정된 연결은 그 링크의 주파수 스펙트럼을 공유한다.</li>
<li data-line="1" dir="auto">그 링크는 연결되는 동안 각 연결에 대해 <strong>주파수 대역을 고정 제공</strong>한다. = <code>대역폭(bandwidth)</code></li>
</ul></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210137431-63860cea-2921-47f8-89f4-19656ee81de5.png" alt="FDM" referrerpolicy="no-referrer" style="width: 300px; max-width: 100%;"></p></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h3 data-heading="시분할 다중화(Time-Division Multiplexing, TDM)" dir="auto" class="heading" id="시분할_다중화(Time-Division_Multiplexing,_TDM)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>시분할 다중화(Time-Division Multiplexing, TDM)</h3><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">TDM 링크는 <strong>시간을 일정 주기의 프레임으로 구분</strong>하고, 각 프레임은 고정된 수의 <code>시간 슬롯</code>으로 나뉜다.</li>
<li data-line="1" dir="auto">네트워크가 링크를 통해 하나의 연결을 설정할 때, 네트워크는 모든 프레임에서 <strong>시간 슬롯 1개를 그 연결에 할당</strong>한다.</li>
<li data-line="2" dir="auto">전송률 : 한 슬롯 안의 비트 수 × 프레임 전송률</li>
</ul></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210137432-426fd263-6cac-45ab-8262-a82bf772e1cc.png" alt="TDM" referrerpolicy="no-referrer" style="width: 350px; max-width: 100%;"></p></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h3 data-heading="패킷 교환 대 회선 교환" dir="auto" class="heading" id="패킷_교환_대_회선_교환"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>패킷 교환 대 회선 교환</h3><div class="heading-children"><div><p dir="auto"><strong>[ 패킷 교환 옹호자 ]</strong></p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>주장
<ol dir="auto">
<li data-line="1" dir="auto">패킷 교환이 회선 교환보다 전송 용량의 공유에서 더 효율적이다.</li>
<li data-line="2" dir="auto">패킷 교환이 회선 교환보다 더 간단하고 효율적이며, 구현 비용이 적다.</li>
</ol>
</li>
<li data-line="3" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>근거
<ul dir="auto">
<li data-line="4" dir="auto">회선 교환에서 통신을 위해서는 자원이 항상 <strong>각각의</strong> 사용자에게 <strong>예약</strong>되어야만 한다.</li>
<li data-line="5" dir="auto">할당된 회선이 <code>비활용 기간(silent period)</code>에는 자원을 점유한 채로 놀게 되기 때문에 자원 이용률이 감소한다.</li>
<li data-line="6" dir="auto">즉, 회선 교환에서는 사용되지 않는 네트워크 자원(연결 경로상의 링크 주파수 대역이나 슬롯)은 <strong>다른 진행 중인 연결이 대신해서 사용할 수 없기 때문에</strong><br>
패킷 교환이 더 효율적이다.</li>
</ul>
</li>
</ul></div><div><br></div><div><p dir="auto"><strong>[ 패킷 교환 반대자 ]</strong></p></div><div><ul dir="auto">
<li data-line="0" dir="auto">주장 : 패킷 교환은 실시간 서비스에는 적당하지 않다.</li>
<li data-line="1" dir="auto">근거 : 주로 큐잉 지연에서 발생하는 <strong>종단 간의 지연</strong> (불규칙적이고 예측할 수 없음)</li>
</ul></div><div><br></div><div><p dir="auto">과연 패킷 교환 반대자의 주장은 옳을까?</p></div><div><p dir="auto">이를 확인해보기 위해서 간단한 예 두 가지를 살펴보자.</p></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><pre dir="auto"><code>1. 사용자가 1 Mbps 링크를 공유한다고 가정하고, 각 사용자들은 활동 시간과 비활동 시간을 반복한다고 하자.
사용자는 전체 시간에서 10%만 활동하며 나머지 90% 시간에는 활동하지 않는다.
</code><button class="copy-code-button">복사</button></pre></div><div><ul dir="auto">
<li data-line="0" dir="auto">활동 시간 : 100 kbps의 일정 속도로 데이터를 생산할 때</li>
<li data-line="1" dir="auto">비활동 시간 : 데이터를 생산하지 않을 때</li>
</ul></div><div><br></div><div><p dir="auto">✅ <code>회선 교환</code>의 경우, 100 kbps가 항상 각각의 사용자에게 예약되어야 한다.<br>
TDM 회선 교환을 예시로, 초 프레임이 100 ms마다 10개 시간 슬롯으로 나뉜다고 한다면 각 사용자에게는 <strong>한 프레임에 한 번의 시간 슬롯</strong>이 할당된다.<br>
따라서 회선 교환 링크는 <strong>동시에 10명(= 1 Mbps / 100 kbps)만 지원할 수 있다.</strong></p></div><div><br></div><div><p dir="auto">✅ <code>패킷 교환</code>의 경우, 한 특정 사용자가 활동을 하고 있을 확률은 10%이다.<br>
만약 10명 이하의 동시 사용자가 있다면 그 확률은 99.96%, 데이터의 통합 도착률은 1 Mbps(링크의 출력률)보다 작거나 같다.<br>
따라서 <strong>10명 이상의 동시 사용자가 있다면 패킷의 통합 도착률이 링크의 출력 용량을 초과하기 때문에 출력 큐가 커지기 시작한다.</strong><br>
(이 큐는 통합 입력률이 1 Mbps 이하로 떨어질 때까지 커질 것이고, 이후에는 큐 길이가 줄어들기 시작할 것)</p></div><div><br></div><div><p dir="auto">10명 이상의 동시 사용자가 있을 확률은 0.04%로 굉장히 작으므로,<br>
<strong>패킷 교환은 거의 항상 회선 교환과 대등한 지연 성능을 가지면서도</strong> 거의 3배 이상의 사용자 수를 허용한다.</p></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><pre dir="auto"><code>2. 10명의 사용자가 있다고 가정하자. 1번과 동일하게, 사용자는 1 Mbps 링크를 공유한다.
한 사용자가 한번에 1,000비트 패킷을 1,000개 생성하고 다른 사용자는 패킷을 생성하지 않는다.
</code><button class="copy-code-button">복사</button></pre></div><div><br></div><div><p dir="auto">✅ <code>회선 교환</code>의 경우를 먼저 보자.<br>
TDM 회선 교환을 예시로, 한 프레임은 10개 슬롯으로 구성되고 각 슬롯은 1,000비트로 구성되었다면<br>
사용자는 데이터 전송을 위해 <strong>한 프레임당 1개의 시간 슬롯만 사용할 수 있다.</strong> 반면에 각 프레임에 남겨진 9개의 시간 슬롯은 쉬는 상태가 된다.<br>
따라서 사용자의 데이터 <strong>100만 비트를 모두 전송하려면 10초가 걸린다.</strong></p></div><div><br></div><div><p dir="auto">✅ <code>패킷 교환</code>의 경우,<br>
패킷을 생성하는 다른 사용자가 없기 때문에 다중화가 요구되지 않고, 사용자는 1 Mbps의 링크가 가득 찰 때까지 패킷을 계속 보낼 수 있다.<br>
따라서 사용자의 데이터 100만 비트는 <strong>1초 만에 모두 전송된다.</strong></p></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">앞의 두 가지 예에서 명확하게 볼 수 있듯, <strong>패킷 교환이 회선 교환보다 성능이 우수하다.</strong></p></div><div><p dir="auto">따라서 오늘날의 전기통신 네트워크의 추세는 패킷 교환으로 전환되고 있다.</p></div><div><br></div><div><p dir="auto">링크 전송률을 공유하는 두 방식의 가장 큰 차이점은 아래와 같이 정리할 수 있다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">회선 교환 방식 : 요구에 관계없이 미리 전송 링크의 사용을 할당한다.</li>
<li data-line="1" dir="auto">패킷 교환 방식 : <strong>요구할 때만</strong> 링크의 사용을 할당한다.</li>
</ul></div><div><br>
<br>
<br></div></div></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="1.3.3 네트워크의 네트워크" dir="auto" class="heading" id="1.3.3_네트워크의_네트워크">1.3.3 네트워크의 네트워크</h1><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="접속 ISP" dir="auto" class="heading" id="접속_ISP"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>접속 ISP</h3><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>ISP(Internet Service Provider)</code> : 패킷 스위치와 통신 링크로 이루어진 네트워크</p>
<ol dir="auto">
<li data-line="1" dir="auto">종단 시스템에게 다양한 네트워크 접속을 제공한다. (e.g., 가정용 초고속 접속, 고속 LAN 접속, 이동 무선 접속 등)</li>
<li data-line="2" dir="auto">CP(content provider)에게 인터넷 접속을 제공 → 웹 사이트나 비디오 서버를 인터넷에 직접 연결할 수 있게 된다.</li>
</ol>
</li>
<li data-line="5" dir="auto">
<p dir="auto">종단 시스템(PC, 스마트폰, 웹 서버 등)은 <strong>접속 ISP를 통해 인터넷에 연결된다.</strong></p>
</li>
<li data-line="6" dir="auto">
<p dir="auto">접속 ISP는 다양한 접속 기술(DSL, 케이블, FTTH, 와이파이, 셀룰러(이동 통신) 등)을 이용하여 유선 또는 무선 연결을 제공한다.</p>
</li>
</ul></div><div><br></div><div><p dir="auto">접속 ISP는 텔코 혹은 케이블 회사일 필요가 없다.<br>
e.g., 대학교 - 학생, 직원, 교수에게 인터넷 접속을 제공, 회사 - 직원에게 인터넷 접속을 제공</p></div><div><p dir="auto">그러나 종단 사용자들과 콘텐츠 제공자들을 모두 접속 ISP로 연결하는 것은 말도 안 된다.</p></div><div><p dir="auto">이를 위해서는 <strong>접속 ISP들이 서로 연결되어야만 하기 때문에</strong> <code>네트워크의 네트워크(network of network)</code>가 탄생하게 되었다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 목표 : <strong>모든 종단 시스템이 서로에게 패킷을 보낼 수 있도록</strong> 접속 ISP를 연결하는 것</p>
</blockquote></div><div><p dir="auto">가장 간단한 방법은 각 접속 ISP를 직접 서로 다른 ISP와 연결하는 것이다.</p></div><div><p dir="auto">하지만 각 접속 ISP가 전 세계적으로 다른 접속 ISP와 수십만 개의 개별적인 통신 링크를 유지해야 하기 때문에,<br>
이런 그물망 설계는 접속 ISP에게 너무 많은 비용을 발생시킨다.</p></div><div><br></div><div><p dir="auto">오늘날의 인터넷 네트워크 구조를 이해하기 위해 점진적으로 일련의 네트워크 구조를 만들어보자.</p></div><div><br></div></div></div><div class="heading-wrapper"><h2 data-heading="네트워크 구조 1" dir="auto" class="heading" id="네트워크_구조_1"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>네트워크 구조 1</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">모든 접속 ISP를 <strong>하나의 글로벌 통과(transit) ISP</strong>와 연결한다.</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto"><code>글로벌 통과 ISP</code> : 라우터 + 전 세계에 이르고, 적어도 수십만 개의 접속 ISP와 가까운 곳에 있는 라우터를 갖는 통신 링크의 네트워크</li>
<li data-line="1" dir="auto">글로벌 ISP가 이러한 확장된 네트워크를 구축하는 데는 매우 많은 비용이 든다.</li>
<li data-line="2" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>글로벌 ISP는 이익을 얻기 위해 <strong>각각의 접속 ISP에 연결을 위한 과금</strong>을 부과한다.
<ul dir="auto">
<li data-line="3" dir="auto">접속 ISP는 <code>고객(customer)</code></li>
<li data-line="4" dir="auto">글로벌 ISP는 <code>제공자(provider)</code></li>
</ul>
</li>
</ul></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="네트워크 구조 2" dir="auto" class="heading" id="네트워크_구조_2"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>네트워크 구조 2</h2><div class="heading-children"><div><p dir="auto">어느 회사가 수익을 내는 글로벌 ISP를 구축하고 운영한다면, 다른 회사가 자신의 글로벌 ISP를 구축하여 경쟁하는 것은 자연스러운 일이다.</p></div><div><p dir="auto">이것이 네트워크 구조 2로 진화한다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">수십만 개의 접속 ISP와 <strong>다중의 글로벌 ISP</strong></p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>2계층구조</code>
<ul dir="auto">
<li data-line="1" dir="auto">상위층 : 글로벌 ISP 서비스 제공자가 존재</li>
<li data-line="2" dir="auto">하위층 : 접속 ISP가 존재</li>
</ul>
</li>
<li data-line="3" dir="auto"><strong>글로벌 ISP들은 서로 연결해야만 한다.</strong></li>
<li data-line="4" dir="auto">서로 연결되지 않는다면 하나의 글로벌 ISP와 연결된 접속 ISP는 다른 글로벌 통과 서비스 제공자에 연결된 접속 ISP와 통신할 수 없다.</li>
</ul></div><div><br></div><div class="heading-wrapper"><h3 data-heading="지역 ISP와 1계층 ISP" dir="auto" class="heading" id="지역_ISP와_1계층_ISP"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>지역 ISP와 1계층 ISP</h3><div class="heading-children"><div><p dir="auto">현실적으로 전 세계의 모든 도시에 존재하는 ISP는 없다.</p></div><div><p dir="auto">대신, 어느 주어진 지역에서 그 지역에 있는 접속 ISP들이 연결하는 <code>지역(regional) ISP</code>가 존재하며, 각 지역 ISP는 <code>1계층(tier-1) ISP</code>들과 연결된다.<br>
<em>(실제로 존재하는 1계층 ISP는 전 세계적으로 모든 도시에 존재하지는 않는다.)</em></p></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="네트워크 구조 3" dir="auto" class="heading" id="네트워크_구조_3"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>네트워크 구조 3</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto"><strong>다중계층구조(접속 ISP, 지역 ISP, 1계층 ISP)</strong> <em>→ 오늘날의 인터넷과 대략적으로 유사</em></p>
</blockquote></div><div><p dir="auto">여러 경쟁적인 1계층 ISP들이 존재하며, 한 지역에 여러 경쟁적인 지역 ISP들이 존재할 수 있다.</p></div><div><p dir="auto">더 복잡한 경우, 작은 지역 ISP들이 연결하는 좀 더 큰 지역 ISP들이 있을 수 있다.</p></div><div><br></div><div><p dir="auto">이런 계층구조에서의 과금은 크게 다음과 같이 진행된다.</p></div><div><p dir="auto">고객 ISP는 글로벌 인터넷 연결성(interconnectivity)을 얻기 위해 서비스 제공 ISP에게 요금을 지불하기 때문에<br>
"각 레벨에는 고객-제공자 관계가 존재한다"고 할 수 있다.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">각각의 <strong>접속 ISP</strong>는 자신이 연결하는 <strong>지역 ISP에게</strong> 요금을 지불한다.</li>
<li data-line="1" dir="auto">각 <strong>지역 ISP</strong>는 자신이 연결하는 <strong>1계층 ISP에게</strong> 요금을 지불한다.</li>
<li data-line="2" dir="auto">1계층 ISP는 계층구조의 최상위에 있기 때문에 아무에게도 요금을 지불하지 않는다.</li>
</ol></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="네트워크 구조 4" dir="auto" class="heading" id="네트워크_구조_4"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>네트워크 구조 4</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">다중계층구조(접속 ISP, 지역 ISP, 1계층 ISP) + <strong>PoP + 멀티홈 + 피어링 + IXP</strong></p>
</blockquote></div><div><br></div><div><p dir="auto">오늘날의 인터넷과 좀 더 유사한 네트워크를 구축하기 위해서는 네트워크 구조 3에 아래 4가지 항목들을 포함해야 한다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>PoP(Points of Presence)</code></p>
<ul dir="auto">
<li data-line="1" dir="auto">단지 제공자의 네트워크 내에 있는(같은 위치에 존재하는) 하나 혹은 그 이상의 라우터 그룹</li>
<li data-line="2" dir="auto">최하위(접속 ISP) 계층을 제외한 모든 계층에 존재하며, <strong>고객 ISP가 제공자 ISP에 연결될 수 있다.</strong></li>
<li data-line="3" dir="auto">고객 네트워크가 제공자의 PoP에 연결되기 위해,<br>
고객은 자신의 라우터 중 하나를 PoP에 있는 라우터에 직접 연결하도록 <strong>고속 링크를 제3자(third-party) 통신 서비스 제공자로부터 임대할 수 있다.</strong></li>
</ul>
</li>
<li data-line="7" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>멀티홈(multi-homing)</code></p>
<ul dir="auto">
<li data-line="8" dir="auto"><strong>둘 혹은 그 이상의 제공자 ISP에 연결하는 것</strong></li>
<li data-line="9" dir="auto">e.g., 한 접속 ISP가 2개의 ISP에 연결, 2개의 지역 ISP와 함께 하나의 1계층 ISP에 연결</li>
<li data-line="10" dir="auto">1계층 ISP를 제외한 모든 ISP는 멀티홈을 선택할 수 있다.</li>
<li data-line="11" dir="auto">한 ISP가 멀티홈을 하면 서비스 제공자 중 하나가 연결되지 않더라도 인터넷으로 패킷을 계속 송수신할 수 있게 된다.</li>
</ul>
</li>
<li data-line="14" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>피어링(peering)</code></p>
<ul dir="auto">
<li data-line="15" dir="auto">고객 ISP가 서비스 제공 ISP에게 지불하는 요금을 줄이기 위해 <strong>인터넷 계층구조의 같은 계층에 있는 가까운 ISP들은 피어링할 수 있다.</strong><br>
(두 ISP가 피어링하면 일반적으로 서로 요금을 지불하지 않음)</li>
<li data-line="17" dir="auto">즉, 이들 간에 송수신되는 모든 트래픽을 <strong>상위 계층 ISP를 통하지 않고 직접 송수신할 수 있도록</strong> 자신들의 네트워크를 서로 직접 연결하는 것이다.</li>
<li data-line="18" dir="auto">1계층 ISP들도 서로 피어링할 수 있다.</li>
</ul>
</li>
<li data-line="21" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>IXP(Internet Exchange Point)</code></p>
<ul dir="auto">
<li data-line="22" dir="auto">다중의 ISP들이 서로 피어링할 수 있는 만남의 장소</li>
<li data-line="23" dir="auto">일반적으로 교환기를 갖춘 독자적인 빌딩에 존재한다.</li>
</ul>
</li>
</ul></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="네트워크 구조 5" dir="auto" class="heading" id="네트워크_구조_5"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>네트워크 구조 5</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">다중계층구조(접속 ISP, 지역 ISP, 1계층 ISP) + PoP + 멀티홈 + 피어링 + IXP + <strong>콘텐츠 제공 네트워크</strong></p>
</blockquote></div><div><br></div><div><p dir="auto">이는 2012년의 인터넷을 기술하며, <strong>구글</strong>이 이러한 콘텐츠 제공자 네트워크 주도하는 한 예이다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">구글 데이터 센터는 모두 구글의 사설 TCP/IP 네트워크를 통해 연결되어 있으며, 이 네트워크는 전 세계를 연결하며 공중 인터넷과는 분리되어 있다.</li>
<li data-line="1" dir="auto"><strong>구글 사설 네트워크는 구글 서버로 오가는 트래픽만 전달한다.</strong></li>
<li data-line="2" dir="auto">즉, 하위 계층 ISP들과 피어링을 함으로써(그들과 직접 연결하거나 IXP에서 그들과 연결함으로써) 인터넷의 상위 계층을 ‘<code>우회(bypass)</code>’하고 있다.<br>
(아래 그림 참고)</li>
</ul></div><div><br></div><div><ul dir="auto">
<li data-line="0" dir="auto">많은 접속 ISP는 여전히 1계층 네트워크를 통해서만 도달할 수 있기 때문에<br>
구글 네트워크도 1계층 ISP들과 연결하고 그들과 교환하는 트래픽에 대해 이 ISP들에게 요금을 지불한다.</li>
<li data-line="2" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>콘텐츠 제공자들이 자신의 네트워크를 구축함으로써 얻는 이점
<ul dir="auto">
<li data-line="3" dir="auto">상위 계층 ISP들에게 지불하는 요금을 줄일 수 있다.</li>
<li data-line="4" dir="auto">최종 사용자들에게 자신들의 서비스가 궁극적으로 어떻게 전달되는지에 대한 더 많은 통제권을 가질 수 있다.</li>
</ul>
</li>
</ul></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210137433-fd5cf02e-5e56-4acc-94c1-d3bdb4697b13.png" alt="ISP의 연결" referrerpolicy="no-referrer" style="width: 580px; max-width: 100%;"></p></div><div><br>
<br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">최종 정리하자면 다음과 같다.</p></div><div><blockquote dir="auto">
<p dir="auto">💡 오늘날의 <b>인터넷(네트워크의 네트워크)</b>는 12개 정도의 1계층 ISP들과 수십만 개의 하위 계층 ISP들로 구성되어 있다.</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">하위 계층 ISP들은 상위 계층 ISP들과 연결하고, 상위 계층 ISP들은 서로 연결한다.</li>
<li data-line="1" dir="auto">사용자와 콘텐츠 제공자는 하위 계층 ISP 고객이고, 하위 계층 ISP들은 상위 계층 ISP들이 고객이다.</li>
<li data-line="2" dir="auto">최근에 주요 콘텐츠 제공자도 자신의 네트워크를 구축했고 가능한 곳에서 하위 계층 ISP들과 직접 연결한다.</li>
</ul></div><div class="mod-footer"></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#1.3 네트워크 코어"><div class="tree-item-contents heading-link" heading-name="1.3 네트워크 코어"><span class="tree-item-title">1.3 네트워크 코어</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#1.3.1_패킷_교환(packet_switching)"><div class="tree-item-contents heading-link" heading-name="1.3.1 패킷 교환(packet switching)"><span class="tree-item-title">1.3.1 패킷 교환(packet switching)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#저장-후-전달_전송(store-and-forward_transmission)_방식"><div class="tree-item-contents heading-link" heading-name="저장-후-전달 전송(store-and-forward transmission) 방식"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">저장-후-전달 전송(store-and-forward transmission) 방식</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#경과_시간에_대한_계산"><div class="tree-item-contents heading-link" heading-name="경과 시간에 대한 계산"><span class="tree-item-title">경과 시간에 대한 계산</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#종단_간_지연"><div class="tree-item-contents heading-link" heading-name="종단 간 지연"><span class="tree-item-title">종단 간 지연</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#큐잉_지연(queuing_delay)과_패킷_손실"><div class="tree-item-contents heading-link" heading-name="큐잉 지연(queuing delay)과 패킷 손실"><span class="tree-item-title">큐잉 지연(queuing delay)과 패킷 손실</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#포워딩_테이블과_라우팅_프로토콜"><div class="tree-item-contents heading-link" heading-name="포워딩 테이블과 라우팅 프로토콜"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">포워딩 테이블과 라우팅 프로토콜</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#IP_주소"><div class="tree-item-contents heading-link" heading-name="IP 주소"><span class="tree-item-title">IP 주소</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#포워딩_테이블(forwarding_table)"><div class="tree-item-contents heading-link" heading-name="포워딩 테이블(forwarding table)"><span class="tree-item-title">포워딩 테이블(forwarding table)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#라우팅_프로토콜(routing_protocol)"><div class="tree-item-contents heading-link" heading-name="라우팅 프로토콜(routing protocol)"><span class="tree-item-title">라우팅 프로토콜(routing protocol)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#1.3.2_회선_교환(circuit_switching)"><div class="tree-item-contents heading-link" heading-name="1.3.2 회선 교환(circuit switching)"><span class="tree-item-title">1.3.2 회선 교환(circuit switching)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#종단_간_연결(end-to-end_connection)"><div class="tree-item-contents heading-link" heading-name="종단 간 연결(end-to-end connection)"><span class="tree-item-title">종단 간 연결(end-to-end connection)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#회선_교환_네트워크에서의_다중화"><div class="tree-item-contents heading-link" heading-name="회선 교환 네트워크에서의 다중화"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">회선 교환 네트워크에서의 다중화</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#주파수_분할_다중화(Frequency-Division_Multiplexing,_FDM)"><div class="tree-item-contents heading-link" heading-name="주파수 분할 다중화(Frequency-Division Multiplexing, FDM)"><span class="tree-item-title">주파수 분할 다중화(Frequency-Division Multiplexing, FDM)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#시분할_다중화(Time-Division_Multiplexing,_TDM)"><div class="tree-item-contents heading-link" heading-name="시분할 다중화(Time-Division Multiplexing, TDM)"><span class="tree-item-title">시분할 다중화(Time-Division Multiplexing, TDM)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#패킷_교환_대_회선_교환"><div class="tree-item-contents heading-link" heading-name="패킷 교환 대 회선 교환"><span class="tree-item-title">패킷 교환 대 회선 교환</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#1.3.3_네트워크의_네트워크"><div class="tree-item-contents heading-link" heading-name="1.3.3 네트워크의 네트워크"><span class="tree-item-title">1.3.3 네트워크의 네트워크</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#접속_ISP"><div class="tree-item-contents heading-link" heading-name="접속 ISP"><span class="tree-item-title">접속 ISP</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#네트워크_구조_1"><div class="tree-item-contents heading-link" heading-name="네트워크 구조 1"><span class="tree-item-title">네트워크 구조 1</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#네트워크_구조_2"><div class="tree-item-contents heading-link" heading-name="네트워크 구조 2"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">네트워크 구조 2</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#지역_ISP와_1계층_ISP"><div class="tree-item-contents heading-link" heading-name="지역 ISP와 1계층 ISP"><span class="tree-item-title">지역 ISP와 1계층 ISP</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#네트워크_구조_3"><div class="tree-item-contents heading-link" heading-name="네트워크 구조 3"><span class="tree-item-title">네트워크 구조 3</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#네트워크_구조_4"><div class="tree-item-contents heading-link" heading-name="네트워크 구조 4"><span class="tree-item-title">네트워크 구조 4</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.3-네트워크-코어\readme.html#네트워크_구조_5"><div class="tree-item-contents heading-link" heading-name="네트워크 구조 5"><span class="tree-item-title">네트워크 구조 5</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>