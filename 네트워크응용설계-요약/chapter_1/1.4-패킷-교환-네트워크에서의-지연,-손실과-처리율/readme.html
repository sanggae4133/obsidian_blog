<!DOCTYPE html> <html><head>
		<title>README</title>
		<base href="..\..\..\..\../">
		<meta id="root-path" root-path="..\..\..\..\../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Obsidian_main - README">
		<meta property="og:title" content="README">
		<meta property="og:description" content="Obsidian_main - README">
		<meta property="og:type" content="website">
		<meta property="og:url" content="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_1/1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율/readme.html">
		<meta property="og:image" content="https://user-images.githubusercontent.com/86337233/210216460-d4e1eacc-cde9-4185-aca8-661e78a20427.png">
		<meta property="og:site_name" content="Obsidian_main">
		<meta name="author" content="dustbox"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title show-ribbon mk-readable-line mk-folder-lines mk-spaces-enabled mk-inline-context-enabled mk-flow-seamless"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="1.4 패킷 교환 네트워크에서의 지연, 손실과 처리율"><p dir="auto">1.4 패킷 교환 네트워크에서의 지연, 손실과 처리율</p></h1><div class="heading-wrapper"><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">인터넷은 종단 시스템에서 수행되는 <strong>분산 애플리케이션에게 서비스를 제공하는 인프라스트럭처</strong>이다. (1.1절)</p>
</blockquote></div><div><p dir="auto">이상적으로는 인터넷 서비스가 데이터의 손실 없이 즉시 두 종단 시스템 간에 원하는 만큼의 데이터를 이동시키기를 원한다.</p></div><div><p dir="auto">하지만 현실에서 이는 어려우며, 컴퓨터 네트워크는 두 종단 시스템 간에 전달될 수 있는 초당 데이터의 양, 즉 <strong>처리율을 제한한다.</strong></p></div><div><p dir="auto"><strong>이로 인해 종단 시스템 간에 지연이 발생하며, 패킷을 잃어버리게 되기도 한다.</strong></p></div><div><br>
<br>
<br></div></div></div><div class="heading-wrapper"><h1 data-heading="1.4.1 패킷 교환 네트워크에서의 지연 개요" dir="auto" class="heading" id="1.4.1_패킷_교환_네트워크에서의_지연_개요">1.4.1 패킷 교환 네트워크에서의 지연 개요</h1><div class="heading-children"><div><p dir="auto">패킷은 한 호스트(출발지)에서 시작하고 일련의 라우터들을 통과하며 다른 호스트(목적지)에 도달한다.</p></div><div><p dir="auto">패킷이 경로를 따라 한 노드에서 다음 노드로 전달될 때 패킷은 경로상의 <strong>각 노드에서</strong> 다양한 지연을 겪게 되며,<br>
이들은 쌓여서 <code>전체 노드 지연(total nodal delay)</code>을 일으킨다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><code>노드 처리 지연(nodal processing delay)</code></li>
<li data-line="1" dir="auto"><code>큐잉 지연(queuing delay)</code></li>
<li data-line="2" dir="auto"><code>전송 지연(transmission delay)</code></li>
<li data-line="3" dir="auto"><code>전파 지연(propagation delay)</code></li>
</ul></div><div><br></div><div><p dir="auto">아래의 그림을 보며 큰 그림을 그려보자. 이는 라우터 A에서의 노드 지연을 나타낸 것이다.</p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210216460-d4e1eacc-cde9-4185-aca8-661e78a20427.png" alt="노드 지연" referrerpolicy="no-referrer" style="width: 470px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">출발지와 목적지 사이 종단 간 경로의 일부로서, 한 패킷이 업스트림 노드로부터 라우터 A를 통해 라우터 B로 보내진다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><code>업스트림(upstream)</code> : 클라이언트에서 서버로 전송되는 데이터의 흐름</li>
<li data-line="1" dir="auto"><code>다운스트림(downstream)</code> : 서버에서 클라이언트로 전송되는 데이터의 흐름, 일반적으로 다운스트림 트래픽은 업스트림 트래픽보다 더 많은 볼륨이 있다.</li>
</ul></div><div><br></div><div><p dir="auto">라우터 A는 라우터 B에 이르는 <code>하나의 출력(outgoing) 링크</code>를 가지며, 이 링크 앞에 <code>큐(queue, 버퍼(buffer))</code>가 존재한다.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">패킷이 업스트림 노드로부터 라우터 A에 도착한다.</li>
<li data-line="1" dir="auto">라우터 A는 그 패킷에 대한 적당한 출력 링크를 결정하기 위해 패킷 헤더를 조사한다.</li>
<li data-line="2" dir="auto">라우터 A는 선택된 링크로 그 패킷을 보낸다. (그림에서 선택된 링크 = 라우터 B에 이르는 링크)</li>
</ol></div><div><br></div><div><pre dir="auto"><code>만약 라우터 B에 이르는 링크에 현재 전송되는 다른 패킷이 존재하거나, 큐에 자신보다 앞선 다른 패킷들이 존재한다면 어떻게 되는가?
</code><button class="copy-code-button">복사</button></pre></div><div><p dir="auto">새로 도착하는 패킷은 그 링크를 이용하기 위해 큐에 들어갈 것이다.</p></div><div><br></div><div><p dir="auto"><em>이 모든 과정에서 여러 지연이 발생한다.</em></p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="처리 지연(processing delay)" dir="auto" class="heading" id="처리_지연(processing_delay)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>처리 지연(processing delay)</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 패킷 헤더를 조사하고 그 패킷을 어디로 보낼지 결정하는 시간</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">라우터 A로 패킷의 비트를 전송할 때 업스트림 노드에서 발생하는 <strong>패킷의 비트 레벨 오류를 조사</strong>하는 데 필요한 시간과 같은 요소를 포함할 수도 있다.</li>
<li data-line="1" dir="auto">라우터는 이 노드 처리 후, 그 패킷을 라우터 B에 이르는 링크에 앞선 큐에 보낸다.</li>
<li data-line="2" dir="auto">고속 라우터의 처리 지연은 일반적으로 수 마이크로초이다.</li>
</ul></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="큐잉 지연(queuing delay)" dir="auto" class="heading" id="큐잉_지연(queuing_delay)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>큐잉 지연(queuing delay)</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 패킷이 큐에서 링크로 전송되기를 기다리는 시간</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">특정 패킷의 큐잉 지연 길이는 큐에 저장되어 링크로 전송되기를 기다리는, <strong>앞서 도착한 다른 패킷의 수에 의해 결정된다.</strong></li>
<li data-line="1" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>주어진 패킷의 지연은 패킷마다 상당히 다르다.
<ul dir="auto">
<li data-line="2" dir="auto">큐가 비어있고 다른 패킷이 전송 중인 상태가 아니라면 패킷의 큐잉 지연 → 0</li>
<li data-line="3" dir="auto">트래픽이 많고 다른 많은 패킷이 전송 대기 중이라면 패킷의 큐잉 지연 → 매우 길어진다.</li>
</ul>
</li>
<li data-line="4" dir="auto">수 마이크로초 ~ 수 밀리초</li>
</ul></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="전송 지연(transmission delay)" dir="auto" class="heading" id="전송_지연(transmission_delay)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>전송 지연(transmission delay)</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 패킷의 모든 비트를 링크로 밀어내는 데(또는 전송하는 데) 필요한 시간</p>
</blockquote></div><div><p dir="auto">패킷이 <strong>선입선출(FIFO)</strong> 방식으로 전송된다고 가정해보자. (앞서 도착한 다른 모든 패킷이 전송된 다음에 전송)</p></div><div><p dir="auto">패킷의 길이는 <code>L 비트</code>, 라우터 A에서 라우터 B까지 링크의 전송률은 <code>R bps</code>라고 해보자. (R는 라우터 B로 가는 링크의 전송률에 의해 결정됨)</p></div><div><p dir="auto">이때 전송 지연은 <code>L/R</code>이다. (수 마이크로초 ~ 수 밀리초)</p></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="전파 지연(propagation delay)" dir="auto" class="heading" id="전파_지연(propagation_delay)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>전파 지연(propagation delay)</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 비트가 라우터 A 상에서의 링크에서 라우터 B까지의 전파에 필요한 시간</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">비트는 링크의 전파 속도로 전파된다.</li>
<li data-line="1" dir="auto">전파 속도는 링크의 물리 매체(광섬유, 꼬임쌍선 등)에 따라 다르며, 범위는 2×(10^8)미터/초 ~ 3×(10^8)미터/초이다.<br>
→ 빛의 속도와 같거나 약간 작다.</li>
</ul></div><div><p dir="auto">라우터 A와 B 사이의 거리를 <code>d</code>, 링크의 전파 속도를 <code>s</code>라고 한다면 전파 지연은 <code>d/s</code>이다. (일반적으로 수 밀리초)</p></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="전송 지연(transmission delay)과 전파 지연(propagation delay)의 비교" dir="auto" class="heading" id="전송_지연(transmission_delay)과_전파_지연(propagation_delay)의_비교"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>전송 지연(transmission delay)과 전파 지연(propagation delay)의 비교</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="전송 지연" dir="auto" class="heading" id="전송_지연"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>전송 지연</h4><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto"><strong>라우터가 패킷을 내보내는 데</strong> 필요한 시간</li>
<li data-line="1" dir="auto">패킷 길이와 링크 전송률의 함수 → 두 라우터 사이의 거리와는 관계가 없다.</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="전파 지연" dir="auto" class="heading" id="전파_지연"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>전파 지연</h4><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">비트가 <strong>한 라우터에서 다음 라우터로 전파되는 데</strong> 걸리는 시간</li>
<li data-line="1" dir="auto">두 라우터 사이의 거리에 대한 함수 → 패킷 길이나 링크 전송률과는 관계가 없다.</li>
</ul></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="전체 노드 지연(total nodal delay)" dir="auto" class="heading" id="전체_노드_지연(total_nodal_delay)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>전체 노드 지연(total nodal delay)</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 전체 노드 지연 = 처리 지연 + 큐잉 지연 + 전송 지연 + 전파 지연</p>
</blockquote></div><div><br></div><div><p dir="auto">각각 지연 요소의 기여도에는 상당한 차이가 존재한다.</p></div><div class="heading-wrapper"><h4 data-heading="전파 지연(propagation delay)" dir="auto" class="heading" id="전파_지연(propagation_delay)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>전파 지연(propagation delay)</h4><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">내부의 두 라우터를 연결하는 링크에서는 2마이크로초 정도 → 무시 가능</li>
<li data-line="1" dir="auto">정지 위성 링크로 연결된 두 라우터의 경우 수백 밀리초 → 전체 노드 지연의 주요 요소가 된다.</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="전송 지연(transmission delay)" dir="auto" class="heading" id="전송_지연(transmission_delay)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>전송 지연(transmission delay)</h4><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">LAN처럼 10 Mbps 이상의 전송률인 경우 → 무시 가능</li>
<li data-line="1" dir="auto">저속 다이얼업 모뎀 링크에서 보내지는 인터넷 패킷은 수백 밀리초에 이를 수 있다.</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="처리 지연(nodal processing delay)" dir="auto" class="heading" id="처리_지연(nodal_processing_delay)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>처리 지연(nodal processing delay)</h4><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">이는 보통 전체 노드 지연에서는 무시될 수 있다.</li>
<li data-line="1" dir="auto">하지만 라우터가 패킷을 전달할 수 있는 최대율(최대 속도)에는 상당한 영향을 준다.</li>
</ul></div><div><br>
<br>
<br></div></div></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="1.4.2 큐잉 지연과 패킷 손실" dir="auto" class="heading" id="1.4.2_큐잉_지연과_패킷_손실">1.4.2 큐잉 지연과 패킷 손실</h1><div class="heading-children"><div><p dir="auto"><b>노드 지연(한 라우터에서의 지연)</b>에 대하여 알아보자.</p></div><div><p dir="auto">다른 세 가지 지연과 다르게, 큐잉 지연은 패킷마다 다를 수 있다.</p></div><div><br></div><div><p dir="auto">e.g., 10개의 패킷이 동시에 비어 있는 큐에 도착한다면?</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">전송된 첫 패킷은 큐잉 지연을 겪지 않는다.</li>
<li data-line="1" dir="auto">마지막으로 전송되는 패킷은 많은 큐잉 지연을 겪게 된다. (다른 9개 패킷이 전송되기를 기다림)</li>
</ul></div><div><p dir="auto">따라서 큐잉 지연의 특성 묘사는 평균 큐잉 지연, 큐잉 지연의 분산, 큐잉 지연이 어느 특정 값을 넘을 확률 같은 <strong>통계 측정을 일반적으로 이용한다.</strong></p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="큐잉 지연을 결정하는 주 요소들" dir="auto" class="heading" id="큐잉_지연을_결정하는_주_요소들"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>큐잉 지연을 결정하는 주 요소들</h3><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">트래픽이 큐에 도착하는 비율</li>
<li data-line="1" dir="auto">링크의 전송률</li>
<li data-line="2" dir="auto">도착하는 트래픽의 특성 (트래픽이 주기에 맞춰서 또는 버스트(burst)하게 도착하는가?)</li>
</ul></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">아래의 상황을 가정해보자.</p></div><div><pre dir="auto"><code>패킷이 큐에 도착하는 평균율 : a 패킷/초
전송률(패킷이 큐에서 밀려나는 비율) : R 비트/초
모든 패킷은 L 비트
큐가 매우 커서 무한대 비트를 저장할 수 있음
</code><button class="copy-code-button">복사</button></pre></div><div><p dir="auto">이때 <code>트래픽 강도</code>(traffic intensity, <strong>비트가 큐에 도착하는 평균율</strong>)은 <code>La</code> 비트/초다.<br>
(트래픽 강도는 큐잉 지연의 정도를 측정하는 데에 매우 중요)</p></div><div><br></div><div><p dir="auto">✅ <code>La/R &gt; 1</code>이라면 <strong>비트가 큐에 도착하는 평균율이 비트가 큐에서 전송되는 비율을 초과한다</strong>는 것을 의미한다.</p></div><div><p dir="auto">따라서 큐는 끝없이 증가, 큐잉 지연은 무한대에 도달한다. <em>→ 트래픽 강도가 1보다 크지 않게 시스템을 설계해야 한다.</em></p></div><div><br></div><div><p dir="auto">✅ <code>La/R ≤ 1</code>인 경우에는 도착 트래픽의 특성이 큐잉 지연에 영향을 미친다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">하나의 패킷이 L/R 초마다 주기적으로 도착한다면 모든 패킷은 빈 큐에 도착 → 큐잉 지연은 없을 것이다.</li>
<li data-line="1" dir="auto">패킷이 몰려서(burst) 도착한다면 상당한 <strong>평균 큐잉 지연이 발생</strong>할 것이다.</li>
</ul></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">일반적으로 패킷의 도착에는 고정된 패턴이 없고, 임의의 시간만큼 떨어져서 도착하게 된다. (random)</p></div><div><p dir="auto">아래 그래프는 <strong>트래픽 강도에 대한 평균 큐잉 지연의 질적 의존도</strong>를 나타낸다.</p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210216463-79992219-167f-4340-ab30-31383deac4d3.png" alt="평균 큐잉 지연의 트래픽 강도 의존성" referrerpolicy="no-referrer" style="width: 320px; max-width: 100%;"></p></div><div><br>
<br></div><div><blockquote dir="auto">
<p dir="auto">💡 트래픽 강도가 1에 접근할수록 평균 큐잉 지연이 급속히 증가한다.</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">트래픽 강도가 0에 가까울 경우</p>
<ul dir="auto">
<li data-line="1" dir="auto">패킷 도착이 드물고 간격이 멀어서 다음에 도착하는 패킷이 큐에서 다른 패킷을 발견하는 경우가 없다.</li>
<li data-line="2" dir="auto">따라서 평균 큐잉 지연은 0에 가까워진다.</li>
</ul>
</li>
<li data-line="5" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">트래픽 강도가 1에 가까울 경우</p>
<ul dir="auto">
<li data-line="6" dir="auto">패킷 도착이 전송용량을 초과하여 큐가 생성될 것이다.</li>
<li data-line="7" dir="auto">도착률이 전송률보다 작아질 때 큐의 길이가 줄어든다.</li>
</ul>
</li>
</ul></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="패킷 손실" dir="auto" class="heading" id="패킷_손실"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>패킷 손실</h3><div class="heading-children"><div><p dir="auto">앞에서는 큐가 무한대 패킷을 가질 수 있다고 가정했으나, 실제로는 <strong>유한 용량</strong>을 가지며 스위치 설계와 비용에 크게 의존한다.</p></div><div><p dir="auto">즉, 트래픽 강도가 1에 접근함에 따라 패킷 지연이 무한대가 되진 않으며, 대신 큐가 꽉 차게 된다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 큐가 꽉 차서 패킷을 저장할 수 없는 경우에 라우터는 그 패킷을 <strong>버린다(drop).</strong></p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto"><strong>손실 패킷의 비율은 트래픽 강도가 클수록 증가한다.</strong></li>
<li data-line="1" dir="auto">모든 데이터가 궁극적으로 목적지까지 전달되었음을 보장하기 위해 손실 패킷은 종단 간에 <strong>재전송</strong>될 수 있다.</li>
</ul></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">정리하자면, <strong>노드에서의 성능 측정 요소</strong>는 다음의 두 가지이다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">지연 정도</li>
<li data-line="1" dir="auto">패킷 손실 확률</li>
</ul></div><div><br>
<br>
<br></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="1.4.3 종단 간 지연" dir="auto" class="heading" id="1.4.3_종단_간_지연">1.4.3 종단 간 지연</h1><div class="heading-children"><div><p dir="auto"><strong>출발지에서 목적지까지의 지연</strong>에 대하여 알아보기 위해, 다음의 상황을 생각해보자.</p></div><div><pre dir="auto"><code>출발지 호스트와 목적지 호스트 사이에 N-1개의 라우터가 있다.
네트워크가 혼잡하지 않아 큐잉 지연을 무시할 수 있다.
각 호스트와 출발지 호스트에서의 전송률은 R 비트/초이다.
패킷의 크기는 L 비트이다.
</code><button class="copy-code-button">복사</button></pre></div><div><blockquote dir="auto">
<p dir="auto">종단 간 지연 = N(처리 지연 + 전송 지연(L/R) + 전파 지연)</p>
</blockquote></div><div><br></div><div><p dir="auto"><em>이는 1.3절에서 언급한, 처리와 전파 지연을 고려하지 않은 종단 간 지연 식을 일반화한 것이다.</em></p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210137330-0534c802-b6cd-41e4-915d-d8a3dac5d07a.png" alt="종단 간 지연" referrerpolicy="no-referrer" style="width: 250px; max-width: 100%;"></p></div><div><br>
<br>
<br>
<br></div></div></div><div class="heading-wrapper"><h1 data-heading="1.4.4 컴퓨터 네트워크에서의 처리율" dir="auto" class="heading" id="1.4.4_컴퓨터_네트워크에서의_처리율">1.4.4 컴퓨터 네트워크에서의 처리율</h1><div class="heading-children"><div><p dir="auto">컴퓨터 네트워크에서의 주요한 성능 수단은 다음의 세 가지이다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">지연 정도</li>
<li data-line="1" dir="auto">패킷 손실 확률</li>
<li data-line="2" dir="auto"><code>종단 간 처리율(throughput)</code></li>
</ul></div><div><br></div><div><p dir="auto">컴퓨터 네트워크를 통해 호스트 A에서 호스트 B로 커다란 파일을 전송하는 상황을 생각해보자.</p></div><div><p dir="auto">해당 파일은 <strong>F 비트</strong>로 구성되며, 호스트 B가 파일의 모든 F 비트를 수신하는 데 <strong>T초</strong>가 걸린다고 한다면,</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">어느 한 순간에서의 <code>순간적인 처리율(instantaneous throughput)</code> = 호스트 B가 파일을 수신하는 비율(비트/초)</li>
<li data-line="1" dir="auto"><code>평균 처리율(average throughtput)</code> = F/T 비트/초</li>
</ul></div><div><br></div><div><p dir="auto">인터넷 전화 같은 애플리케이션의 경우, <strong>낮은 지연과 순간적인 처리율이 지속적으로</strong> 어떤 임계값(threshold)을 넘는 것이 바람직하다.</p></div><div><p dir="auto">파일 전송을 포함하는 다른 애플리케이션의 경우, 지연은 심각하지 않으나 <strong>가능한 한 높은 처리율</strong>을 가지는 것이 바람직하다.</p></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">서버로부터 클라이언트로의 파일 전송에 대한 처리율을 생각해보기 위해 두 가지 예시를 보자.</p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210216470-eff94fd0-1b04-4efd-aa60-85f7bad15507.png" alt="파일 전송 처리율" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;"></p></div><div><br>
<br></div><div><pre dir="auto"><code>그림 a는 2개의 통신 링크와 라우터로 연결된 하나의 서버와 하나의 클라이언트를 나타낸다.
(전체 네트워크로 보내지는 비트는 서버에서 클라이언트로만 보내지는 비트라고 가정)

Rs : 서버와 라우터 간의 링크 속도
Rc : 라우터와 클라이언트 간의 링크 속도
</code><button class="copy-code-button">복사</button></pre></div><div><p dir="auto">이때 <strong>서버-클라이언트 처리율</strong>은 얼마인가? <em>(비트는 유체(fluid), 통신 링크는 파이프(pipe)로 생각해보자)</em></p></div><div><br></div><div><p dir="auto">서버는 Rs bps보다 빠른 속도로 링크상으로 비트를 내보낼 수 없고, 라우터는 Rc bps보다 빠른 속도로 비트를 전달할 수 없다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><code>Rs &lt; Rc</code>인 경우 : Rs bps</li>
<li data-line="1" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>Rc &lt; Rs</code>인 경우 : Rc bps
<ul dir="auto">
<li data-line="2" dir="auto">라우터는 자신이 수신하는 비트만큼 빠르게 그 비트들을 전달할 수 없다.</li>
<li data-line="3" dir="auto">클라이언트로의 전송을 위해 기다리는 라우터의 비트들은 계속해서 증가할 것이다.</li>
</ul>
</li>
</ul></div><div><blockquote dir="auto">
<p dir="auto">처리율 = min{Rc, Rs} = 병목 링크(bottleneck link)의 전송률</p>
</blockquote></div><div><br>
<br></div><div><pre dir="auto"><code>그림 b는 서버와 클라이언트 간에 N개의 링크를 가진 네트워크를 보여주고 있다.
N개 링크의 전송률 : R1, R2, ... , RN
</code><button class="copy-code-button">복사</button></pre></div><div><p dir="auto">이때의 서버-클라이언트 처리율은 그림 a에서와 마찬가지이다.</p></div><div><blockquote dir="auto">
<p dir="auto">처리율 = min{R1, R2, … , RN} = 서버와 클라이언트 간 경로상에서의 <strong>병목 링크(bottleneck link)의 전송률</strong></p>
</blockquote></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">아래는 오늘날의 인터넷에서 살펴볼 수 있는 다른 두 가지 예시이다.</p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/210216466-21232719-49ba-41e4-a6f9-af5491b6ffd2.png" alt="종단 간 처리율" referrerpolicy="no-referrer" style="width: 400px; max-width: 100%;"></p></div><div><br>
<br></div><div><pre dir="auto"><code>그림 a는 컴퓨터 네트워크로 연결된 2개의 종단 시스템을 나타낸다.
(전체 네트워크로 보내지는 비트는 서버에서 클라이언트로만 보내지는 비트라고 가정)

Rs : 서버가 네트워크에 연결되어 있는 접속 링크 속도
Rc : 클라이언트가 네트워크에 연결되어 있는 접속 링크 속도

통신 네트워크의 코어에 있는 모든 링크가 Rs와 Rc보다 매우 높은 전송률을 가지고 있다.
(실제로도 그렇다. → 오늘날 인터넷의 코어는 작은 혼잡을 경험)
</code><button class="copy-code-button">복사</button></pre></div><div><p dir="auto">이때도 마찬가지로, 출발지에서 목적지로 흐를 수 있는 비트 속도는 Rs와 Rc의 최솟값과 같다.</p></div><div><blockquote dir="auto">
<p dir="auto">처리율 = min{Rc, Rs}</p>
</blockquote></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 오늘날의 인터넷에서의 처리율에 대한 제한 요소는 전형적으로 접속 네트워크다.</p>
</blockquote></div><div><br>
<br></div><div><pre dir="auto"><code>그림 b는 컴퓨터 네트워크의 코어에 연결된 10개의 서버와 10개의 클라이언트를 나타내며,
10개의 동시적인 다운로드가 일어나고 있다. (10개의 클라이언트-서버 쌍)
(현 시각, 이러한 10개의 다운로드가 네트워크에서의 유일한 트래픽이라고 가정)

10개의 다운로드가 통과하는 코어에 하나의 링크 R가 존재한다.

R : 링크 R의 전송률
Rs : 모든 서버 접속 링크가 가지고 있는 속도
Rc : 모든 클라이언트 접속 링크가 가지고 있는 속도

코어에서의 모든 링크의 전송률(속도 R인 하나의 공통 링크는 예외)은 Rs, Rc, R보다 크다고 가정한다.
</code><button class="copy-code-button">복사</button></pre></div><div><p dir="auto">이때 <strong>다운로드의 처리율</strong>은 얼마인가?</p></div><div><p dir="auto">공통 링크 R의 속도가 크다면 각 다운로드에 대한 처리율은 min{Rs, Rc}이 될 것이다.</p></div><div><br></div><div><p dir="auto"><strong>하지만 공통 링크 R의 속도가 Rs, Rc와 같은 수준이라면 어떻게 되는가?</strong></p></div><div><p dir="auto">e.g., Rs = 2 Mbps, Rc = 1 Mbps, R = 5 Mbps<br>
→ 공유 링크는 각 다운로드에 500 kbps의 처리율을 제공하기에, 각 다운로드에 대한 종단 간 처리율은 500 kbps로 줄어든다.</p></div><div><p dir="auto"><strong>즉, 코어에서의 공유 링크가 각 다운로드에 대한 병목이 된다.</strong></p></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">위의 예시들을 한 줄로 정리하자면 다음과 같다.</p></div><div><blockquote dir="auto">
<p dir="auto">💡 처리율은 <strong>데이터가 흐르는 링크의 전송률</strong>에 의존할 뿐만 아니라 <strong>간섭 트래픽</strong>에도 의존한다.</p>
</blockquote></div><div class="mod-footer"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#1.4 패킷 교환 네트워크에서의 지연, 손실과 처리율"><div class="tree-item-contents heading-link" heading-name="1.4 패킷 교환 네트워크에서의 지연, 손실과 처리율"><span class="tree-item-title">1.4 패킷 교환 네트워크에서의 지연, 손실과 처리율</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#1.4.1_패킷_교환_네트워크에서의_지연_개요"><div class="tree-item-contents heading-link" heading-name="1.4.1 패킷 교환 네트워크에서의 지연 개요"><span class="tree-item-title">1.4.1 패킷 교환 네트워크에서의 지연 개요</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#처리_지연(processing_delay)"><div class="tree-item-contents heading-link" heading-name="처리 지연(processing delay)"><span class="tree-item-title">처리 지연(processing delay)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#큐잉_지연(queuing_delay)"><div class="tree-item-contents heading-link" heading-name="큐잉 지연(queuing delay)"><span class="tree-item-title">큐잉 지연(queuing delay)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#전송_지연(transmission_delay)"><div class="tree-item-contents heading-link" heading-name="전송 지연(transmission delay)"><span class="tree-item-title">전송 지연(transmission delay)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#전파_지연(propagation_delay)"><div class="tree-item-contents heading-link" heading-name="전파 지연(propagation delay)"><span class="tree-item-title">전파 지연(propagation delay)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#전송_지연(transmission_delay)과_전파_지연(propagation_delay)의_비교"><div class="tree-item-contents heading-link" heading-name="전송 지연(transmission delay)과 전파 지연(propagation delay)의 비교"><span class="tree-item-title">전송 지연(transmission delay)과 전파 지연(propagation delay)의 비교</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#전송_지연"><div class="tree-item-contents heading-link" heading-name="전송 지연"><span class="tree-item-title">전송 지연</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#전파_지연"><div class="tree-item-contents heading-link" heading-name="전파 지연"><span class="tree-item-title">전파 지연</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#전체_노드_지연(total_nodal_delay)"><div class="tree-item-contents heading-link" heading-name="전체 노드 지연(total nodal delay)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">전체 노드 지연(total nodal delay)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#전파_지연(propagation_delay)"><div class="tree-item-contents heading-link" heading-name="전파 지연(propagation delay)"><span class="tree-item-title">전파 지연(propagation delay)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#전송_지연(transmission_delay)"><div class="tree-item-contents heading-link" heading-name="전송 지연(transmission delay)"><span class="tree-item-title">전송 지연(transmission delay)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#처리_지연(nodal_processing_delay)"><div class="tree-item-contents heading-link" heading-name="처리 지연(nodal processing delay)"><span class="tree-item-title">처리 지연(nodal processing delay)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#1.4.2_큐잉_지연과_패킷_손실"><div class="tree-item-contents heading-link" heading-name="1.4.2 큐잉 지연과 패킷 손실"><span class="tree-item-title">1.4.2 큐잉 지연과 패킷 손실</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#큐잉_지연을_결정하는_주_요소들"><div class="tree-item-contents heading-link" heading-name="큐잉 지연을 결정하는 주 요소들"><span class="tree-item-title">큐잉 지연을 결정하는 주 요소들</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#패킷_손실"><div class="tree-item-contents heading-link" heading-name="패킷 손실"><span class="tree-item-title">패킷 손실</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#1.4.3_종단_간_지연"><div class="tree-item-contents heading-link" heading-name="1.4.3 종단 간 지연"><span class="tree-item-title">1.4.3 종단 간 지연</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_1\1.4-패킷-교환-네트워크에서의-지연,-손실과-처리율\readme.html#1.4.4_컴퓨터_네트워크에서의_처리율"><div class="tree-item-contents heading-link" heading-name="1.4.4 컴퓨터 네트워크에서의 처리율"><span class="tree-item-title">1.4.4 컴퓨터 네트워크에서의 처리율</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>