<!DOCTYPE html> <html><head>
		<title>README</title>
		<base href="..\..\..\..\../">
		<meta id="root-path" root-path="..\..\..\..\../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Obsidian_main - README">
		<meta property="og:title" content="README">
		<meta property="og:description" content="Obsidian_main - README">
		<meta property="og:type" content="website">
		<meta property="og:url" content="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_3/3.7-tcp-혼잡-제어/readme.html">
		<meta property="og:image" content="https://user-images.githubusercontent.com/86337233/211625829-2117ddf7-f325-4168-86cb-39d6bac3e2bd.png">
		<meta property="og:site_name" content="Obsidian_main">
		<meta name="author" content="dustbox"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title show-ribbon mk-readable-line mk-folder-lines mk-spaces-enabled mk-inline-context-enabled mk-flow-seamless"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="3.7 TCP 혼잡 제어"><p dir="auto">3.7 TCP 혼잡 제어</p></h1><div class="heading-wrapper"><div class="heading-children"><div><p dir="auto"><code>IP 계층</code>은 네트워크 혼잡에 관해 <strong>종단 시스템에게 어떠한 직접적인 피드백도 제공하지 않는다.</strong></p></div><div><br></div><div class="heading-wrapper"><h2 data-heading="3.7.1 전통적인 TCP의 혼잡 제어" dir="auto" class="heading" id="3.7.1_전통적인_TCP의_혼잡_제어"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.7.1 전통적인 TCP의 혼잡 제어</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto"><strong>네트워크의 혼잡에 따라</strong> 연결에 트래픽을 보내는 전송률을 각 송신자가 제한하도록 한다.</p>
</blockquote></div><div><ol dir="auto">
<li data-line="0" dir="auto">TCP 송신자가 자신과 목적지 간의 경로에서 혼잡이 없음을 감지 → 송신율을 높인다.</li>
<li data-line="1" dir="auto">TCP 송신자가 경로 사이에 혼잡을 감지 → 송신율을 줄인다.</li>
</ol></div><div><br></div><div class="heading-wrapper"><h3 data-heading="1. TCP 송신자는 자신의 연결에 송신자 전송 트래픽 전송률을 어떻게 제한하는가?" dir="auto" class="heading" id="1._TCP_송신자는_자신의_연결에_송신자_전송_트래픽_전송률을_어떻게_제한하는가?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1. TCP 송신자는 자신의 연결에 송신자 전송 트래픽 전송률을 어떻게 제한하는가?</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 송신 측에서 동작하는 TCP 혼잡 제어 메커니즘은<br>
추가적인 변수인 <code>혼잡 윈도(congestion window)</code>를 추적한다.</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto"><code>cwnd</code>로 표시</li>
<li data-line="1" dir="auto">TCP 송신자가 <strong>네트워크로 트래픽을 전송할 수 있는 속도</strong>에 제약을 가한다.</li>
</ul></div><div><br></div><div><p dir="auto">송신하는 쪽에서 확인응답이 안 된 데이터의 양은<br>
<code>cwnd</code>와 <code>rwnd(수신 윈도 = 버퍼의 여유 공간)</code>의 최솟값을 초과하지 않을 것이다.</p></div><div><blockquote dir="auto">
<p dir="auto">LastByteSent - LastByteAcked <strong>≤ min{cwnd, rwnd}</strong></p>
</blockquote></div><div><p dir="auto">→ 따라서 <strong>cwnd의 값을 조절하여</strong> 송신자는 링크에 데이터를 전송하는 속도를 조절할 수 있다.</p></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="2. TCP 송신자는 자신과 목적지 사이 경로의 혼잡을 어떻게 감지하는가?" dir="auto" class="heading" id="2._TCP_송신자는_자신과_목적지_사이_경로의_혼잡을_어떻게_감지하는가?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2. TCP 송신자는 자신과 목적지 사이 경로의 혼잡을 어떻게 감지하는가?</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">1️⃣ 손실 이벤트(loss event)가 발생한 경우</p>
</blockquote></div><div><p dir="auto">과도한 혼잡이 발생하면</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">경로에 있는 하나 이상의 라우터 버퍼들이 오버플로되고</p>
</li>
<li data-line="1" dir="auto">
<p dir="auto">그 결과 데이터그램이 버려진다.</p>
</li>
<li data-line="2" dir="auto">
<p dir="auto"><strong>버려진 데이터그램은 송신 측에서 손실 이벤트를 발생시킨다.</strong></p>
<p dir="auto">(e.g., 타임아웃 또는 3개의 중복된 ACK의 수신)</p>
</li>
</ol></div><div><p dir="auto">이를 통해 송신자는 송신자와 수신자 사이의 경로상의 혼잡이 발생했음을 알게 된다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">2️⃣ 손실 이벤트가 발생하지 않은 경우</p>
</blockquote></div><div><blockquote dir="auto">
<p dir="auto">💡 <code>자체 클로킹(self-clocking)</code><br>
TCP는 <strong>확인응답</strong>을 혼잡 윈도 크기의 증가를 유발하는 트리거(trigger)또는 클록(clock)으로 사용한다.</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">확인응답이 늦은 속도로 도착한다면 → 혼잡 윈도는 상대적으로 낮은 속도로 증가</li>
<li data-line="1" dir="auto">확인응답이 높은 속도로 도착한다면 → 혼잡 윈도는 더 빨리 증가</li>
</ul></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="3. TCP 송신자는 송신율을 변화시키기 위해 어떤 알고리즘을 사용해야 하는가?" dir="auto" class="heading" id="3._TCP_송신자는_송신율을_변화시키기_위해_어떤_알고리즘을_사용해야_하는가?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3. TCP 송신자는 송신율을 변화시키기 위해 어떤 알고리즘을 사용해야 하는가?</h3><div class="heading-children"><div><p dir="auto"><em>전송률을 제어하는 cwnd 값을 조정하는 매커니즘은 무엇인가?</em></p></div><div><ul dir="auto">
<li data-line="0" dir="auto">TCP 송신자들이 너무 빠르게 송신하면 → 혼잡 붕괴가 나타날 것이다.</li>
<li data-line="1" dir="auto">TCP 송신자들이 너무 천천히 송신한다면 → 네트워크 내의 대역폭을 충분히 활용하지 못할 것이다.</li>
</ul></div><div><br></div><div><p dir="auto">TCP는 다음과 같은 3가지 처리 원칙에 따라 자신이 송신할 속도를 결정하게 된다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">1️⃣ TCP 전송률은 한 세그먼트를 손실했을 때 줄여야 한다.</p>
</blockquote></div><div><p dir="auto"><code>손실된 세그먼트</code> = <strong>혼잡</strong>을 의미</p></div><div><p dir="auto">손실 세그먼트의 재전송을 야기하는 이벤트는 다음과 같다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">타임아웃 이벤트</li>
<li data-line="1" dir="auto">4개의 확인응답 수신 (하나의 원래의 ACK + 3개의 중복된 ACK)</li>
</ul></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">2️⃣ 확인응답되지 않은 세그먼트에 대해 ACK가 도착하면 송신자의 전송률은 증가할 수 있다.</p>
</blockquote></div><div><p dir="auto"><code>확인응답의 도착</code> = 네트워크가 송신자의 세그먼트를 수신자에게 성공적으로 전송하였다.</p></div><div><p dir="auto">즉, 네트워크는 혼잡하지 않다는 묵시적 표시로 받아들여진다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">3️⃣ 대역폭 탐색</p>
</blockquote></div><div><p dir="auto">혼잡이 없는 출발지에서 목적지까지의 경로를 표시하는 <code>ACK</code>와 혼잡한 경로를 표시하는 <code>손실 이벤트</code>가 주어지면,</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">TCP 송신자로 하여금 손실 이벤트가 발생할 때까지는 <strong>ACK가 도착함에 따라 전송률을 증가시킨다.</strong></li>
<li data-line="1" dir="auto"><strong>손실 이벤트가 발생한 시점에서 전송률을 줄인다.</strong></li>
</ol></div><div><br></div><div><p dir="auto">그러므로</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">TCP 송신자는 혼잡이 발생하는 시점까지 전송률을 증가시키고</li>
<li data-line="1" dir="auto">그 시점 이후로부터는 줄인 후,</li>
<li data-line="2" dir="auto">다시 혼잡 시작이 발생했는지를 보기 위한 탐색을 시작한다.</li>
</ol></div><div><br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="TCP 혼잡 제어 알고리즘(TCP congestion-control algorithm)" dir="auto" class="heading" id="TCP_혼잡_제어_알고리즘(TCP_congestion-control_algorithm)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP 혼잡 제어 알고리즘(TCP congestion-control algorithm)</h2><div class="heading-children"><div><p dir="auto">세 가지 구성요소</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><code>슬로 스타트(slow start)</code></p>
</li>
<li data-line="3" dir="auto">
<p dir="auto"><code>혼잡 회피(congestion avoidance)</code></p>
</li>
<li data-line="6" dir="auto">
<p dir="auto"><code>빠른 회복(fast recovery)</code> → 권고, 필수사항은 아니다.</p>
</li>
</ol></div><div><br></div><div class="heading-wrapper"><h3 data-heading="TCP 혼잡 제어의 FSM" dir="auto" class="heading" id="TCP_혼잡_제어의_FSM"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP 혼잡 제어의 FSM</h3><div class="heading-children"><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211625829-2117ddf7-f325-4168-86cb-39d6bac3e2bd.png" alt="TCP 혼잡 제어의 FSM" referrerpolicy="no-referrer" style="width: 780px; max-width: 100%;"></p></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="슬로 스타트(slow start)" dir="auto" class="heading" id="슬로_스타트(slow_start)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>슬로 스타트(slow start)</h2><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">TCP 연결 시작 시, <code>cwnd</code>의 값은 일반적으로 1 MSS로 초기화된다.<br>
→ 초기 전송률은 대략 <code>MSS/RTT</code></p>
</li>
<li data-line="4" dir="auto">
<p dir="auto">TCP 송신자에게 가용 대역폭은 MSS/RTT보다 훨씬 크기 때문에 TCP 송신자는 가용 대역폭 양을 조속히 찾고자 한다.</p>
</li>
</ol></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">슬로 스타트 상태에서는 <code>cwnd</code> 값을 1 MSS에서 시작하여,<br>
<strong>한 전송 세그먼트가 첫 번째로 확인응답을 받을 때마다</strong> <strong>1 MSS 씩 증가한다.</strong></p>
</blockquote></div><div><br></div><div><p dir="auto">아래 그림처럼 TCP 전송률은 지수적으로 증가하게 된다.</p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211625835-f36ebe84-04de-4091-86a2-fcedfb50fe4f.png" alt="TCP 슬로 스타트" referrerpolicy="no-referrer" style="width: 380px; max-width: 100%;"></p></div><div><br>
<br></div><div class="heading-wrapper"><h3 data-heading="슬로스타트의 종료 조건" dir="auto" class="heading" id="슬로스타트의_종료_조건"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>슬로스타트의 종료 조건</h3><div class="heading-children"><div><p dir="auto">이 지수적 증가는 언제 끝나는 것인가?</p></div><div><p dir="auto">아래와 같이 3가지 경우가 존재한다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">1️⃣  <strong>타임아웃</strong>으로 표시되는 손실 이벤트(혼잡)가 있을 경우</p>
</blockquote></div><div><ol dir="auto">
<li data-line="0" dir="auto">TCP 송신자는 <code>cwnd</code> 값을 <strong>1</strong>로 설정</li>
<li data-line="1" dir="auto"><strong>새로운 슬로 스타트</strong>를 시작한다.</li>
</ol></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">2️⃣ cwnd 값이 <strong>ssthreah</strong> 값과 같을 경우</p>
</blockquote></div><div><ol dir="auto">
<li data-line="0" dir="auto"><strong>슬로 스타트는 종료되고</strong></li>
<li data-line="1" dir="auto">TCP는 <code>혼잡 회피 모드</code>로 전환한다.</li>
</ol></div><div><br></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><code>ssthreah(slow start threshold, 슬로 스타트 임곗값)</code>는 두 번째 상태 변수로, <code>cwnd/2</code>로 정한다.<br>
(= 혼잡이 검출되었을 시점에서의 혼잡 윈도 값의 반)</p>
</li>
<li data-line="4" dir="auto">
<p dir="auto">TCP는 <code>혼잡 회피 모드</code>에서는 <code>cwnd</code>를 좀 더 조심스럽게 증가시킨다.</p>
</li>
</ul></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">3️⃣ <strong>중복 ACK</strong>가 검출되는 경우</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">TCP는 빠른 재전송을 수행하여 빠른 회복 상태로 들어간다.</li>
</ul></div><div><br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="혼잡 회피" dir="auto" class="heading" id="혼잡_회피"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>혼잡 회피</h2><div class="heading-children"><div><p dir="auto">혼잡 회피 상태로 들어가는 시점에서 <code>cwnd</code>의 값은 대략 <strong>혼잡이 마지막으로 발견된 시점에서의 값의 반</strong>이 된다.</p></div><div><blockquote dir="auto">
<p dir="auto"><code>혼잡 회피 상태</code>에서 일반적으로 TCP는 RTT마다 하나의 MSS만큼 <code>cwnd</code>를 증가시킨다.</p>
</blockquote></div><div><p dir="auto">즉, 새로운 승인이 도착할 때마다 <code>cwnd</code>를 <b>MSS 바이트(MSS/cwnd)</b>만큼 증가시킨다.</p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="혼잡 회피 상태의 종료 조건" dir="auto" class="heading" id="혼잡_회피_상태의_종료_조건"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>혼잡 회피 상태의 종료 조건</h3><div class="heading-children"><div><p dir="auto">언제 혼잡 회피의 (RTT당 1 MSS) 선형 증가가 끝날 것인가?</p></div><div><br></div><div><p dir="auto">TCP 혼잡 회피 알고리즘은 <strong>타임아웃</strong>이 발생했을 때 슬로 스타트의 경우와 같이,</p></div><div><blockquote dir="auto">
<p dir="auto"><code>cwnd</code>의 값은 <strong>1 MSS</strong>로 설정하고,<br>
<code>ssthreash</code>의 값은 <strong>손실 이벤트가 발생할 때의 cwnd 값의 반</strong>으로 설정한다.</p>
</blockquote></div><div><br></div><div><p dir="auto">그러나 손실 이벤트는 3개의 중복된 ACK 이벤트에 의해 야기되며,<br>
<em>이 경우 네트워크는 송신자로부터 세그먼트를 수신자에게 계속 전달하고 있는 중이다.</em></p></div><div><br></div><div><p dir="auto">따라서 이러한 타입의 손실 이벤트에 대해서 TCP는</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">3개의 중복 ACK를 수신한 시점에서 <code>cwnd</code>의 값을 반으로 줄이고</li>
<li data-line="1" dir="auto"><code>ssthresh</code> 값을 <code>cwnd 값의 반</code>으로 기록한다.</li>
<li data-line="2" dir="auto">이후 <code>빠른 회복 상태</code>로 들어간다.</li>
</ol></div><div><br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="빠른 회복" dir="auto" class="heading" id="빠른_회복"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>빠른 회복</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto"><code>빠른 회복 상태</code>에서는 <code>cwnd</code> 값을 <strong>손실된 세그먼트에 대해 수신된</strong><br>
모든 중복된 ACK에 대해 <code>1 MSS</code> 만큼씩 증가시킨다.</p>
</blockquote></div><div><p dir="auto">이때 손실된 세그먼트는 TCP를 빠른 회복 상태로 들어가게 했던 세그먼트를 말한다.</p></div><div><br></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><strong>손실된 세그먼트에 대한 ACK가 도착하면</strong> TCP는 <code>cwnd 혼잡 회피 상태</code>로 들어간다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">만약 타임아웃 이벤트가 발생한다면 빠른 회복은 슬로 스타트 및 혼잡 회피에서와 같은 동작을 수행한 후 슬로 스타트로 전이한다.</p>
<blockquote dir="auto">
<p dir="auto">즉, <code>cwnd</code> 값은 <strong>1 MSS</strong>로 하고, <code>ssthresh</code> 값은 <strong>손실 이벤트가 발생할 때의 cwnd 값의 반</strong>으로 한다.</p>
</blockquote>
</li>
</ol></div><div><br></div><div><p dir="auto">빠른 회복은 구성요소의 권고사항이며, 필수는 아니다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>TCP 타호(TCP Tahoe, 초기 TCP 버전)</code><br>
: 타임아웃으로 표시되거나 3개의 중복 ACK로 표시되는 손실이 발생하면</p>
<ol dir="auto">
<li data-line="2" dir="auto">무조건 혼잡 윈도를 1 MSS로 줄이고</li>
<li data-line="3" dir="auto"><strong>슬로 스타드 단계</strong>로 들어간다.</li>
</ol>
</li>
<li data-line="6" dir="auto">
<p dir="auto"><code>TCP 리노(TCP Reno, 새로운 TCP 버전)</code>는 <strong>빠른 회복</strong>을 채택했다.</p>
</li>
</ul></div><div><br></div><div><p dir="auto">아래는 리노와 타노에 대한 TCP의 혼잡 윈도 변화를 나타낸 그래프이다.</p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211625839-e0b75f39-a78a-4265-aad1-b9382257e8de.png" alt="TCP의 혼잡 윈도의 발달" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">손실 이벤트가 발생했을 때</p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>TCP 리노</code></p>
<ol dir="auto">
<li data-line="1" dir="auto">혼잡 윈도가 9•MSS로 설정되고</li>
<li data-line="2" dir="auto"><strong>선형적으로 증가한다.</strong></li>
</ol>
</li>
<li data-line="5" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>TCP 타호</code></p>
<ol dir="auto">
<li data-line="6" dir="auto">혼잡 윈도는 <strong>1 MSS</strong>로 설정되고</li>
<li data-line="7" dir="auto"><strong>ssthreash에 도달할 때까지 지수적으로 증가하며</strong></li>
<li data-line="8" dir="auto">그 이후에는 선형적으로 증가한다.</li>
</ol>
</li>
</ul></div><div><br></div></div></div><div class="heading-wrapper"><h2 data-heading="TCP 혼잡 제어: 복습" dir="auto" class="heading" id="TCP_혼잡_제어:_복습"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP 혼잡 제어: 복습</h2><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">연결이 시작되고 초기 슬로 스타트 기간을 무시하고,</li>
<li data-line="1" dir="auto">손실이 타임아웃이 아니라 3개의 중복 ACK로 표신된다고 가정한다면,</li>
</ul></div><div><blockquote dir="auto">
<p dir="auto">💡 TCP의 혼잡 제어는<br>
RTT마다 1 MSS씩 <strong>cwnd의 선형(가법적인) 증가</strong>와<br>
3개의 중복 ACK 이벤트에서 <b>cwnd의 절반화(승법적 감소)</b>로 구성된다.</p>
</blockquote></div><div><p dir="auto">→ TCP의 혼잡 제어는 <code>가법적 증가, 승법적 감소(additive-increase, multiplicative decrease, AIMD)</code>의 혼잡 제어 형식이라고 불린다.</p></div><div><br></div><div><ol dir="auto">
<li data-line="0" dir="auto">TCP는 3개의 중복 ACK 이벤트가 발생할 때까지 <strong>선형으로 그 혼잡 윈도 크기(결국 전송률)를 증가시킨다.</strong></li>
<li data-line="1" dir="auto">그러고 나서는 혼잡 윈도 크기를 <strong>감소</strong>시키지만,</li>
<li data-line="2" dir="auto">다시 추가적인 가용 대역폭이 있는지를 <code>탐색</code>하기 위해 <strong>선형으로 증가</strong>시키기 시작한다.</li>
</ol></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211625842-798c4c59-a967-4847-b29f-4e4a3ebfcc32.png" alt="AIMD 혼잡 제어" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;"></p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="TCP 큐빅(CUBIC)" dir="auto" class="heading" id="TCP_큐빅(CUBIC)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP 큐빅(CUBIC)</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">패킷 손실이 발생한 혼잡한 링크의 상태가 많이 변경되지 않은 경우<br>
<strong>전송 속도를 더 빠르게 높여 손실 전 전송 속도에 근접한 다음</strong> 대역폭을 신중하게 조사한다.</p>
</blockquote></div><div><br></div><div><p dir="auto">ACK 수신 시에만 혼잡 윈도를 늘리고 슬로 스타트 단계와 빠른 복구 단계는 TCP 리노와 동일하지만,<br>
아래의 혼잡 회피 단계가 수정되었다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">✅ 몇 가지 조율 가능한 큐빅 매개변수들이 프로토콜의 혼잡 윈도 크기가 얼마나 빨리 <code>Wmax</code>에 도달하는가(<code>K</code>)를 결정한다.</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto"><code>Wmax</code> : 손실이 마지막으로 감지되었을 때 TCP의 혼잡 제어 윈도 크기</li>
<li data-line="1" dir="auto"><code>K</code> 시각 : 손실이 없다고 가정할 때 TCP 큐빅의 <strong>윈도 크기가 다시 Wmax에 도달하는 미래 시점</strong></li>
</ul></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">✅ 큐빅은 <strong>혼잡 윈도</strong>를 현재 시각 <code>t</code>와 <code>K</code> 시각 사이 거리의 <strong>세제곱 함수로 증가시킨다.</strong></p>
</blockquote></div><div><p dir="auto">→ <code>t</code>가 <code>K</code>에 가까울 때보다 <strong>멀리 떨어졌을 때 혼잡 윈도 크기 증가가 훨씬 더 커진다.</strong></p></div><div><br></div><div><p dir="auto">즉,</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">큐빅은 손실 전 속도인 <code>Wmax</code>에 가까워지도록 TCP의 전송 속도를 빠르게 증가시킨 다음,</li>
<li data-line="1" dir="auto"><code>Wmax</code><strong>에 가까워지면 대역폭을 조심스럽게 탐지한다.</strong></li>
</ol></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">✅ 손실을 유발한 링크의 수준이 크게 변경된 경우 큐빅이 새 작동 지점을 더 빨리 찾을 수 있다.</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto"><code>t가 K에 가까울 때</code>는 큐빅의 혼잡 윈도 증가가 작다.<br>
(이는 손실을 유발하는 링크의 혼잡 수준이 많이 변경되지 않은 경우 좋음)</li>
<li data-line="2" dir="auto"><code>t가 K를 크게 초과함</code><strong>에 따라 혼잡 윈도가 급격히 증가한다.</strong></li>
</ul></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">아래 그래프는 <code>TCP 리노</code>와 <code>TCP 큐빅</code>의 이상적인 성능 비교를 나타낸 것이다.</p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211625843-6a80951a-f492-41bc-9cf2-635b8159ce7b.jpg" alt="TCP 리노와 TCP 큐빅" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">슬로 스타트 단계는 <code>t0</code>에서 끝나며,<br>
<code>t1</code>, <code>t2</code>, <code>t3</code>에서 혼잡 손실이 발생하면 큐빅은 <code>Wmax</code><strong>에 가깝게 더 빠르게 증가한다.</strong></p></div><div><p dir="auto">→ 따라서 TCP 큐빅이 더 많은 전체 처리량을 누린다.</p></div><div><p dir="auto">TCP 큐빅은 혼잡 임곗값 바로 아래에서 가능한 한 오랫동안 흐름을 유지하려고 시도한다.</p></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="3.7.2 네트워크 지원 명시적 혼잡 알림과 지연 기반 혼잡 제어" dir="auto" class="heading" id="3.7.2_네트워크_지원_명시적_혼잡_알림과_지연_기반_혼잡_제어"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.7.2 네트워크 지원 명시적 혼잡 알림과 지연 기반 혼잡 제어</h2><div class="heading-children"><div><p dir="auto">1980년대 후반 슬로 스타트와 혼잡 회피의 초기 표준화 이후, TCP는 <code>종단 끝 혼잡 제어 형식</code>을 구현했다.</p></div><div><p dir="auto">하지만 최근에는 <strong>네트워크가 TCP 송신자와 수신자에게 명시적으로 혼잡 신호를 보낼 수 있도록</strong><br>
IP 및 TCP에 대한 확장이 제안, 구현 및 배포되었다. (<code>네트워크 지원 혼잡 제어 방식</code>)</p></div><div><p dir="auto">또한 측정된 패킷 지연을 사용하여 혼잡을 추론하는 TCP 혼잡 제어 프로토콜의 일부 변형이 제안되었다.</p></div><div><br></div></div></div><div class="heading-wrapper"><h2 data-heading="명시적 혼잡 알림(Explicit Congestion Notification, ECN)" dir="auto" class="heading" id="명시적_혼잡_알림(Explicit_Congestion_Notification,_ECN)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>명시적 혼잡 알림(Explicit Congestion Notification, ECN)</h2><div class="heading-children"><div><p dir="auto">인터넷 내에서 수행되는 <code>네트워크 지원 혼잡 제어</code>의 한 형태이다.</p></div><div><br></div><div><p dir="auto">네트워크 계층에서 IP 데이터그램 헤더의 <strong>서비스 유형(Type of Service) 필드</strong>에 있는 2비트가 ECN에 사용된다.</p></div><div><blockquote dir="auto">
<p dir="auto">💡 손실이 발생하기 전에 혼잡 시작을 송신자에게 알리기 위해 <strong>혼잡 알림 비트를 설정</strong>한다.</p>
</blockquote></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211625847-eee59d74-7fa9-4570-adf2-2d007837b231.png" alt="명시적 혼잡 알림" referrerpolicy="no-referrer" style="width: 600px; max-width: 100%;"></p></div><div><br>
<br></div><div class="heading-wrapper"><h3 data-heading="ECN 비트의 설정" dir="auto" class="heading" id="ECN_비트의_설정"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>ECN 비트의 설정</h3><div class="heading-children"><div><p dir="auto">ECN 비트의 한 설정은 <strong>라우터가 정체를 겪고 있음을 나타내기 위해</strong> 라우터에서 사용된다.</p></div><div><p dir="auto">→ 이 혼잡 표시는 표시된 <code>IP 데이터그램</code>에서 목적지 호스트로 전달되어 위의 그림처럼 송신 호스트에게 알린다.</p></div><div><br></div><div><p dir="auto">ECN 비트의 두 번째 설정은 발신 호스트가 라우터에게 다음의 정보를 알리는 데에 사용된다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">송신자와 수신자가 ECN을 사용할 수 있다.</li>
<li data-line="1" dir="auto">이에 따라 ECN으로 표시된 네트워크 혼잡에 대한 응답으로 조취할 수 있다.</li>
</ul></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="과정" dir="auto" class="heading" id="과정"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>과정</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 혼잡해지는 라우터는<br>
그 라우터에서 버퍼가 가득 차서 패킷들이 삭제되기 <strong>전에</strong><br>
송신자에게 혼잡 시작을 알리는 <code>혼잡 알림 비트</code>를 설정할 수 있다.</p>
</blockquote></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">수신 호스트의 TCP가 <strong>수신 데이터그램을 통해</strong> <code>ECN 혼잡 알림 표시</code>를 수신하면,</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">수신 호스트의 TCP는 <strong>수신자-송신자 TCP ACK 세그먼트의</strong><br>
<code>ECE(Explicit Congestion Notification Echo, 명시적 혼잡 알림 에코) 비트</code>를 설정하여<br>
<strong>송신 호스트의 TCP에 혼잡 표시를 알린다.</strong></p>
</li>
<li data-line="8" dir="auto">
<p dir="auto">TCP 송신자는 <strong>혼잡 윈도를 절반으로 줄여</strong> 혼잡 알림 표시가 있는 ACK에 반응하고,</p>
</li>
<li data-line="11" dir="auto">
<p dir="auto"><strong>다음 전송되는 TCP 수신자 세그먼트 헤더에</strong> <code>CWR(Congestion Window Reduced) 비트</code>를 <strong>1</strong>로 설정한다.</p>
</li>
</ol></div><div><br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="지연 기반 혼잡 제어" dir="auto" class="heading" id="지연_기반_혼잡_제어"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>지연 기반 혼잡 제어</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">패킷 손실이 발생하기 전에 혼잡 시작을 <strong>사전에</strong> 감지</p>
</blockquote></div><div><br></div><div><blockquote dir="auto">
<p dir="auto"><code>TCP 베가스(Vegas)</code>는<br>
<strong>TCP 송신자가 파이프를 가득 채우되 그 이상으로 채우지 않도록 해야 한다</strong>는 원칙하에 동작한다.</p>
</blockquote></div><div><p dir="auto">즉, 파이프가 가득 찬 상태에서는 큰 큐가 쌓이도록 허용되는 경우가 좋을 게 없다는 것을 의미한다.</p></div><div><br></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">TCP 베가스는 모든 확인응답된 패킷에 대한 출발지에서 목적지까지 경로의 <code>RTT</code>를 측정한다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">RTTmin : 송신자에서 측정한 RTT 값 중 최솟값</p>
</li>
</ul></div><div><br></div><div><ul dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">실제 송신자가 측정한 처리량이 <code>cwnd/RTTmin</code>에 가깝다면</p>
<ul dir="auto">
<li data-line="1" dir="auto">경로가 아직 정체되지 않았고,</li>
<li data-line="2" dir="auto">따라서 TCP 전송 속도가 증가할 수 있다는 것이다.</li>
</ul>
</li>
<li data-line="5" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">실제 송신자가 측정한 처리량이 <strong>혼잡하지 않을 때의 처리율보다 현저히 낮다면</strong></p>
<ul dir="auto">
<li data-line="6" dir="auto">경로가 혼잡하고</li>
<li data-line="7" dir="auto"><strong>TCP 베가스 송신자는 전송 속도를 낮추게 된다.</strong></li>
</ul>
</li>
</ul></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="3.7.3 공평성" dir="auto" class="heading" id="3.7.3_공평성"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.7.3 공평성</h2><div class="heading-children"><div><p dir="auto">각각 다른 종단 간의 경로를 갖지만, 모두 <code>R bps</code><strong>의 전송률인</strong> <code>병목 링크(bottleneck link)</code>를 지나는 <code>K</code>개의 TCP 연결을 생각해보자.</p></div><div><br></div><div><p dir="auto">각 연결은 큰 파일을 전송하고 있고, 병목 링크를 통과하는 UDP 트래픽은 없다고 가정했을 때,</p></div><div><blockquote dir="auto">
<p dir="auto">각 연결의 평균 전송률이 <code>R/K</code>에 가깝다면 혼잡 제어는 메커니즘이 <strong>공평</strong>하다고 한다.<br>
즉, 각 연결은 링크 대역폭을 <strong>동등하게 공유한다.</strong></p>
</blockquote></div><div><br></div><div><p dir="auto">아래 그림처럼 전송률이 <code>R</code>인 링크 하나를 공유하는 2개의 TCP 연결을 살펴보자.</p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211625853-ca717317-75e6-47ec-ac70-971a8f475fcf.png" alt="병목 링크" referrerpolicy="no-referrer" style="width: 570px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">가정</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">두 연결이 <code>같은 MSS와 RTT</code>를 가진다.<br>
<strong>→ 그들이 같은 혼잡 윈도우 크기를 갖는다면 같은 처리율을 가질 것이다.</strong></li>
<li data-line="2" dir="auto">송신할 많은 양의 데이터가 있다.</li>
<li data-line="3" dir="auto">TCP의 슬로 스타트 현상을 무시한다.</li>
<li data-line="4" dir="auto">TCP 연결이 언제나 <code>혼잡 회피 방식</code>으로 동작한다.</li>
</ul></div><div><br></div><div><p dir="auto">TCP 연결 1과 2에 의해 실현되는 처리율은 다음과 같이 나타낼 수 있다.</p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211625855-65fb1a01-7341-46a3-85d6-1e38f5e0be51.png" alt="처리율" referrerpolicy="no-referrer" style="width: 360px; max-width: 100%;"></p></div><div><br>
<br></div><div><ul dir="auto">
<li data-line="0" dir="auto">만약 TCP가 두 연결 사이에서 링크 대역폭을 똑같이 공유한다면,<br>
실제 처리율은 원점에서부터 발산하면서 45º 각도의 화살표(동등한 대역폭 공유)를 따라야 한다.</li>
<li data-line="2" dir="auto">이상적으로는 두 처리율의 합이 R과 같아야 한다.</li>
</ul></div><div><br></div><div><p dir="auto">→ 목적 : <strong>동등한 대역폭 공유 선과 완전한 대역폭 이용선의 교차 지점</strong> 가까운 곳의 처리율을 얻는 것</p></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">1️⃣ TCP 윈도 크기가 어느 주어진 시점에서 연결 1과 2가 <code>A 지점</code>으로 나타내는 처리율을 실현한다고 하자.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">두 연결에 의해 공동으로 소비되는 링크 대역폭의 양이 R보다 적기 때문에<br>
<strong>어떠한 손실도 발생하지 않을 것이다.</strong></p>
</li>
<li data-line="4" dir="auto">
<p dir="auto">양 연결은 <code>TCP 혼잡 회피 알고리즘</code>의 결과로서 <strong>RTT당 1 MSS씩 이들의 윈도우를 증가</strong>시킬 것이다.</p>
</li>
</ul></div><div><br></div><div><p dir="auto">따라서 두 연결의 공동 처리율은 A 지점에서 시작하는 45º 각도의 선을 따라서 계속되며,</p></div><div><p dir="auto">2️⃣ 결국 두 연결에 의해 공동으로 소비되는 <strong>링크 대역폭은 R보다 커질 것이다. → 패킷 손실이 발생</strong></p></div><div><p dir="auto">(<code>B 지점</code>에 의해 나타내는 처리율을 실현할 때 패킷 손실을 경험한다고 하자)</p></div><div><br></div><div><p dir="auto">그러므로 연결 1과 2는 <strong>반으로 그들의 윈도를 감소시킨다.</strong></p></div><div><br></div><div><p dir="auto">3️⃣ 결과적으로 실현된 처리율은 <code>C 지점</code>에 있게 되는데, 이는 B와 원점의 중간이다.</p></div><div><p dir="auto">공동 대역폭 사용이 C 지점에서 R보다 낮으므로,<br>
두 연결은 다시 C로부터 시작하는 45º 각도의 선을 따라 처리율을 증가시킨다.</p></div><div><br></div><div><p dir="auto">4️⃣ 결국 손실은 다시 발생할 것이고(<code>D 지점</code>), 두 연결은 다시 반으로 윈도 크기를 감소시킨다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">즉, 두 연결에 의해 실현되는 대역폭은 <code>동등한 대역폭 공유선</code>을 따라서 결국에는 <strong>변동하며</strong><br>
2차원 공간 어디에 있든지 간에 상관없이 <strong>수렴한다.</strong></p>
</blockquote></div><div><p dir="auto"><em>→ 왜 TCP가 연결 사이에서 대역폭을 똑같이 공유하는지에 대한 직관적 느낌</em></p></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">위의 이상적인 시나리오와는 다르게,<br>
현실에서는 클라이언트-서버 애플리케이션들은 <strong>링크 대역폭의 각기 다른 양</strong>을 얻을 수 있다.</p></div><div><br></div><div><p dir="auto">특히 여러 연결이 공통의 병목 링크를 공유할 때,</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">더 작은 RTT를 갖는 세션은 <strong>대역폭이 좀 더 빠르게 비워지므로</strong> 링크에서 가용한 대역폭을 점유할 수 있고,</li>
<li data-line="1" dir="auto">그래서 큰 RTT를 갖는 연결보다 더 높은 처리율을 갖는다.</li>
</ul></div><div><br></div><div class="heading-wrapper"><h3 data-heading="공평성과 UDP" dir="auto" class="heading" id="공평성과_UDP"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>공평성과 UDP</h3><div class="heading-children"><div><p dir="auto">UDP는 혼잡 제어를 갖고 있지 않는다.</p></div><div><br></div><div><p dir="auto">TCP의 관점에서 보면 UDP 상에서 수행되는 멀티미디어 애플리케이션은 공평하지 못하다.</p></div><div><p dir="auto"><strong>즉, 다른 연결들과 협력하지도 않으며, 그들의 전송률을 적당하게 조절하지도 않는다.</strong></p></div><div><br></div><div><p dir="auto">TCP 혼잡 제어는 혼잡(손실) 증가에 대해 전송률을 감소시키므로,<br>
그럴 필요가 없는 <strong>UDP 송신자들이 TCP 트래픽을 밀어낼 가능성이 있다.</strong></p></div><div><p dir="auto">→ UPD 트래픽으로 인해 인터넷이 마비되는 것을 방지하는 인터넷을 위한 혼잡 제어 방식의 개발이 필요하다.</p></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="공평성과 병렬 TCP 연결" dir="auto" class="heading" id="공평성과_병렬_TCP_연결"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>공평성과 병렬 TCP 연결</h3><div class="heading-children"><div><p dir="auto">UDP 트래픽이 공평하게 행동하도록 강요하더라도,<br>
<code>TCP 기반 애플리케이션의 다중 병렬 연결</code>의 사용을 막을 방법이 없기 때문에 공평성 문제는 여전히 완전하게 해결되지 않는다.</p></div><div><p dir="auto">애플리케이션이 다중 병렬 연결을 사용할 때는 <strong>혼잡한 링크 대역폭의 더 많은 부분을 차지한다.</strong></p></div><div class="mod-footer"></div></div></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#3.7 TCP 혼잡 제어"><div class="tree-item-contents heading-link" heading-name="3.7 TCP 혼잡 제어"><span class="tree-item-title">3.7 TCP 혼잡 제어</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#3.7.1_전통적인_TCP의_혼잡_제어"><div class="tree-item-contents heading-link" heading-name="3.7.1 전통적인 TCP의 혼잡 제어"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.7.1 전통적인 TCP의 혼잡 제어</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#1._TCP_송신자는_자신의_연결에_송신자_전송_트래픽_전송률을_어떻게_제한하는가?"><div class="tree-item-contents heading-link" heading-name="1. TCP 송신자는 자신의 연결에 송신자 전송 트래픽 전송률을 어떻게 제한하는가?"><span class="tree-item-title">1. 
TCP 송신자는 자신의 연결에 송신자 전송 트래픽 전송률을 어떻게 제한하는가?
</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#2._TCP_송신자는_자신과_목적지_사이_경로의_혼잡을_어떻게_감지하는가?"><div class="tree-item-contents heading-link" heading-name="2. TCP 송신자는 자신과 목적지 사이 경로의 혼잡을 어떻게 감지하는가?"><span class="tree-item-title">2. 
TCP 송신자는 자신과 목적지 사이 경로의 혼잡을 어떻게 감지하는가?
</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#3._TCP_송신자는_송신율을_변화시키기_위해_어떤_알고리즘을_사용해야_하는가?"><div class="tree-item-contents heading-link" heading-name="3. TCP 송신자는 송신율을 변화시키기 위해 어떤 알고리즘을 사용해야 하는가?"><span class="tree-item-title">3. 
TCP 송신자는 송신율을 변화시키기 위해 어떤 알고리즘을 사용해야 하는가?
</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#TCP_혼잡_제어_알고리즘(TCP_congestion-control_algorithm)"><div class="tree-item-contents heading-link" heading-name="TCP 혼잡 제어 알고리즘(TCP congestion-control algorithm)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">TCP 혼잡 제어 알고리즘(TCP congestion-control algorithm)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#TCP_혼잡_제어의_FSM"><div class="tree-item-contents heading-link" heading-name="TCP 혼잡 제어의 FSM"><span class="tree-item-title">TCP 혼잡 제어의 FSM</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#슬로_스타트(slow_start)"><div class="tree-item-contents heading-link" heading-name="슬로 스타트(slow start)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">슬로 스타트(slow start)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#슬로스타트의_종료_조건"><div class="tree-item-contents heading-link" heading-name="슬로스타트의 종료 조건"><span class="tree-item-title">슬로스타트의 종료 조건</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#혼잡_회피"><div class="tree-item-contents heading-link" heading-name="혼잡 회피"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">혼잡 회피</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#혼잡_회피_상태의_종료_조건"><div class="tree-item-contents heading-link" heading-name="혼잡 회피 상태의 종료 조건"><span class="tree-item-title">혼잡 회피 상태의 종료 조건</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#빠른_회복"><div class="tree-item-contents heading-link" heading-name="빠른 회복"><span class="tree-item-title">빠른 회복</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#TCP_혼잡_제어:_복습"><div class="tree-item-contents heading-link" heading-name="TCP 혼잡 제어: 복습"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">TCP 혼잡 제어: 복습</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#TCP_큐빅(CUBIC)"><div class="tree-item-contents heading-link" heading-name="TCP 큐빅(CUBIC)"><span class="tree-item-title">TCP 큐빅(CUBIC)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#3.7.2_네트워크_지원_명시적_혼잡_알림과_지연_기반_혼잡_제어"><div class="tree-item-contents heading-link" heading-name="3.7.2 네트워크 지원 명시적 혼잡 알림과 지연 기반 혼잡 제어"><span class="tree-item-title">3.7.2 네트워크 지원 명시적 혼잡 알림과 지연 기반 혼잡 제어</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#명시적_혼잡_알림(Explicit_Congestion_Notification,_ECN)"><div class="tree-item-contents heading-link" heading-name="명시적 혼잡 알림(Explicit Congestion Notification, ECN)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">명시적 혼잡 알림(Explicit Congestion Notification, ECN)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#ECN_비트의_설정"><div class="tree-item-contents heading-link" heading-name="ECN 비트의 설정"><span class="tree-item-title">ECN 비트의 설정</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#과정"><div class="tree-item-contents heading-link" heading-name="과정"><span class="tree-item-title">과정</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#지연_기반_혼잡_제어"><div class="tree-item-contents heading-link" heading-name="지연 기반 혼잡 제어"><span class="tree-item-title">지연 기반 혼잡 제어</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#3.7.3_공평성"><div class="tree-item-contents heading-link" heading-name="3.7.3 공평성"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.7.3 공평성</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#공평성과_UDP"><div class="tree-item-contents heading-link" heading-name="공평성과 UDP"><span class="tree-item-title">공평성과 UDP</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.7-tcp-혼잡-제어\readme.html#공평성과_병렬_TCP_연결"><div class="tree-item-contents heading-link" heading-name="공평성과 병렬 TCP 연결"><span class="tree-item-title">공평성과 병렬 TCP 연결</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>