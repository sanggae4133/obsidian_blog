<!DOCTYPE html> <html><head>
		<title>README</title>
		<base href="..\..\..\..\../">
		<meta id="root-path" root-path="..\..\..\..\../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Obsidian_main - README">
		<meta property="og:title" content="README">
		<meta property="og:description" content="Obsidian_main - README">
		<meta property="og:type" content="website">
		<meta property="og:url" content="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/readme.html">
		<meta property="og:image" content="https://user-images.githubusercontent.com/76640167/212551546-16b6533b-58ec-421a-9863-e7d581e0cb41.png">
		<meta property="og:site_name" content="Obsidian_main">
		<meta name="author" content="dustbox"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title show-ribbon mk-readable-line mk-folder-lines mk-spaces-enabled mk-inline-context-enabled mk-flow-seamless"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="4.2 라우터 내부에는 무엇이 있을까?"><p dir="auto">4.2 라우터 내부에는 무엇이 있을까?</p></h1><div class="heading-wrapper"><div class="heading-children"><div><img src="https://user-images.githubusercontent.com/76640167/212551546-16b6533b-58ec-421a-9863-e7d581e0cb41.png" alt="라우터 구조" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;">
![[Pasted image 20240618004402.png]]
위 그림을 라우터의 구조를 나타낸다.</div><div><ul dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>입력 포트</code>
<ul dir="auto">
<li data-line="1" dir="auto">입력 포트의 <strong>맨 왼쪽과 맨 오른쪽 박스는 라우터로 들어오는 입력 링크로, 물리 계층 기능을 수행</strong>한다. </li>
<li data-line="2" dir="auto">또한 입력 포트는 들어오는 링크의 반대편에 있는 <strong>링크 계층과 상호 운용하기 위해 필요한 링크 계층 기능을 수행</strong>한다. 이것은 입력 및 출력 포트에서 미들박스로 표시된다.</li>
<li data-line="3" dir="auto">가장 중요한 기능은 입력 포트의 가장 오른쪽에서 수행되는 <strong>검색 기능</strong>이다. 여기서 <strong>포워딩 테이블을 참조하여 도착된 패킷이 스위치 구조를 통해 라우터 출력 포트를 결정</strong>한다.</li>
<li data-line="4" dir="auto">라우팅 프로토콜 정보를 전달하는 패킷인 <code>제어 패킷</code>은 입력 포트에서 라우팅 프로세서로 전달된다.</li>
<li data-line="5" dir="auto">여기서의 포트는 앞에서 언급한 포트와는 다르다.</li>
</ul>
</li>
<li data-line="6" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>스위치 구조</code>
<ul dir="auto">
<li data-line="7" dir="auto">스위치 구조는 <strong>라우터의 입력 포트와 출력 포트를 연결</strong>한다.</li>
<li data-line="8" dir="auto">라우터 내부에 포함되어 있다.</li>
</ul>
</li>
<li data-line="9" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>출력 포트</code>
<ul dir="auto">
<li data-line="10" dir="auto">출력 포트는 <strong>스위치 구조에서 수신한 패킷을 저장하고 필요한 링크 계층 및 물리 계층 기능을 수행하여 출력 링크로 패킷을 전송</strong>한다.</li>
<li data-line="11" dir="auto">링크가 양방향일 경우 출력 포트는 일반적으로 동일한 링크의 입력 포트와 한 쌍을 이룬다.</li>
</ul>
</li>
<li data-line="12" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>라우팅 프로세서</code>
<ul dir="auto">
<li data-line="13" dir="auto"><strong>제어평면 기능</strong>을 수행한다.</li>
<li data-line="14" dir="auto">전통적인 라우터에서는 라우팅 프로토콜을 실행하고 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리하며 라우터의 포워딩 테이블을 계산한다.</li>
<li data-line="15" dir="auto">SDN 라우터에서 라우팅 프로세서는 원격 컨트롤러와 통신하여 원격 컨트롤러에서 계산된 포워딩 테이블 엔트리를 수신하고 라우터의 입력 포트에 이러한 엔트리를 설치한다.</li>
<li data-line="16" dir="auto">네트워크 관리 기능을 수행한다.</li>
</ul>
</li>
</ul></div><div><p dir="auto">라우터의 입력 포트, 출력 포트, 스위치 구조는 거의 항상 하드웨어로 구현된다.</p></div><div><p dir="auto">제어 평면은 일반적으로 소프트웨어로 구현되며 라우팅 프로세서(일반적으로 기존 CPU)에서 실행된다.</p></div><div class="heading-wrapper"><h2 data-heading="4.2.1 입력 포트 처리 및 목적지 기반 전송" dir="auto" class="heading" id="4.2.1_입력_포트_처리_및_목적지_기반_전송"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.1 입력 포트 처리 및 목적지 기반 전송</h2><div class="heading-children"><div><img src="https://user-images.githubusercontent.com/76640167/212552679-134bbf97-c8fd-452c-a6dc-283454e8d745.png" alt="입력 포트 처리" referrerpolicy="no-referrer" style="width: 700px; max-width: 100%;">
![[Pasted image 20240618005140.png]]
입력 포트의 기능은 위에서 언급한 바와 같다.</div><div><p dir="auto">입력 포트에서 수행되는 검색은 라우터 동작의 핵심이다.</p></div><div><p dir="auto">라우터는 포워딩 테이블을 사용하여 도착 패킷이 스위치 구조를 통해 전달되는 출력 포트를 검색한다.</p></div><div><p dir="auto">포워딩 테이블은 라우팅 프로세서에서 계산되거나 갱신되거나 원격 SDN 컨트롤러에서 수신된다.</p></div><div><p dir="auto">포워딩 테이블은 라우팅 프로세서에서 맨 위 그림과 같이 각 라인 카드로 복사되고, 이렇게 각 라인이 복사본을 사용하여 패킷 단위로 중앙 집중식 라우팅 프로세서를 호출하지 않게 되어 병목 현상을 피할 수 있다.</p></div><div class="heading-wrapper"><h3 data-heading="목적지 주소 범위 포워딩 테이블" dir="auto" class="heading" id="목적지_주소_범위_포워딩_테이블"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>목적지 주소 범위 포워딩 테이블</h3><div class="heading-children"><div><p dir="auto">32비트의 IP 주소의 경우 포워딩 테이블을 억지로 구현한다면 모든 가능한 목적지 주소마다 하나의 엔트리가 필요하고, 이는 40억개 이상의 주소가 있어야 하므로 불가능하다.</p></div><div><p dir="auto">라우터에서 0에서 3까지의 4개의 링크가 있다고 가정해보자.</p></div><div><p dir="auto"><span alt="Pasted image 20240618014252.png" src="Pasted image 20240618014252.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618014252.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618014252.png"></span><br>
목적지 주소 범위로 포워딩 테이블을 구성할 경우 4개의 엔트리를 갖는 포워딩 테이블이면 된다.</p></div></div></div><div class="heading-wrapper"><h3 data-heading="프리 픽스 포워딩 테이블" dir="auto" class="heading" id="프리_픽스_포워딩_테이블"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>프리 픽스 포워딩 테이블</h3><div class="heading-children"><div><p dir="auto"><span alt="Pasted image 20240618014249.png" src="Pasted image 20240618014249.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618014249.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618014249.png"></span><br>
이런 형식의 포워딩 테이블에서 라우터는 패킷의 목적지 주소의 <code>프리픽스(prefix)</code>를 테이블의 엔트리와 매치한다.</p></div><div><p dir="auto">예를 들어, 패킷의 목적지 주소가 <code>11001000 00010111 00010110 10100001</code> 라면 앞 21개의 비트 프리픽스가 테이블의 첫 번째 엔트리와 매치되므로 라우터는 이 패킷을 링크 인터페이스 0으로 보낸다.</p></div><div><p dir="auto"><code>11001000 00010111 00011000 10101010</code>와 같이 처음 24비트는 2번째에 처음 21비트는 3번째에 매치되는 경우 라우터는 <code>최장 프리픽스 매치 규칙(longest prefix matching rule)</code>을 사용한다.</p></div><div><p dir="auto">즉, 테이블에서 가장 긴 매치 엔트리를 찾고, 여기에 연관된 링크 인터페이스로 패킷을 보낸다. (이유에 대해서는 4.3절에서 다룬다.)</p></div><div><p dir="auto">이러한 테이블 설계 뿐만 아니라  검색은 나노초 단위로 수행되어야 하므로 이외의 기술이 필요하다.</p></div><div><p dir="auto">메모리 접속 시간에 특별한 주의를 기울여야 하므로 내장형 DRAM과 빠른 SRAM 메모리가 있는 설계가 필요하다. 실제로 TCAM도 검색을 위해 자주 사용된다.</p></div><div><p dir="auto">검색을 통해 패킷의 출력 포트가 결정되면 패킷을 스위치 구조로 보낼 수 있다. 일부 설계에서는 다른 입력 포트로부터 패킷이 현재 구조를 사용하고 있다면 패킷이 스위칭 구조에 들어가는 것을 일시적으로 차단할 수 있다.</p></div><div><p dir="auto">앞으로 패킷의 차단, 큐잉, 스케줄링에 대해 자세히 살펴본다.</p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="4.2.2 스위칭" dir="auto" class="heading" id="4.2.2_스위칭"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.2 스위칭</h2><div class="heading-children"><div><p dir="auto">스위치 구조는 패킷이 입력 포트에서 출력 포트로 실제로 스위칭 되는 구조를 통과하므로 라우터의 핵심이다.</p></div><div><p dir="auto">여기서는 여러가지 스위칭 방법을 설명한다.<br>
<span alt="Pasted image 20240618014324.png" src="Pasted image 20240618014324.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618014324.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618014324.png"></span></p></div><div class="heading-wrapper"><h3 data-heading="메모리를 통한 교환" dir="auto" class="heading" id="메모리를_통한_교환"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>메모리를 통한 교환</h3><div class="heading-children"><div><p dir="auto"><span alt="Pasted image 20240618014330.png" src="Pasted image 20240618014330.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618014330.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618014330.png"></span><br>
초기의 라우터는 라우터 프로세서를 직접 제어해서 입력 포트와 출력 포트 사이에서 패킷을 스위칭하는 전통적인 컴퓨터다. 입력 포트와 출력 포트는 I/O 장치처럼 작동한다.</p></div><div><p dir="auto">패킷 전달 과정</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">패킷이 도착하면 입력 포트는 라우팅 프로세서에게 인터럽트를 보내 패킷을 프로세서 메모리에 복사한다.</li>
<li data-line="1" dir="auto">라우팅 프로세서는 헤더에서 목적지 주소를 추출한다. </li>
<li data-line="2" dir="auto">포워딩 테이블에서 적절한 출력 포트를 찾은 다음 패킷을 출력 포트의 버퍼에 복사한다.</li>
</ol></div><div><p dir="auto">위 과정에서 메모리 대역폭이 초당 최대 B인 패킷을 메모리에 쓰거나 메모리에서 읽을 수 있는 경우 전체 전달 처리량은 B/2 보다 작아야하며 목적지 포트가 다른 경우라도 공유 시스템 버스를 통해 한 번에 하나의 메모리 읽기/쓰기 작업을 수행할 수 있기 때문에 두 패킷을 동시에 전달할 수 없다.</p></div><div><p dir="auto">최근의 메모리를 통해 스위칭하는 라우터는 목적지 주소를 검색하고 해당 메모리 위치에 패킷을 저장하는 것이 입력 라인 카드에서 처리함으로써 수행한다.</p></div></div></div><div class="heading-wrapper"><h3 data-heading="버스(bus)를 통한 교환" dir="auto" class="heading" id="버스(bus)를_통한_교환"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>버스(bus)를 통한 교환</h3><div class="heading-children"><div><p dir="auto"><span alt="Pasted image 20240618014413.png" src="Pasted image 20240618014413.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618014413.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618014413.png"></span><br>
입력 포트는 라우팅 프로세서의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷을 전송한다.</p></div><div><p dir="auto">일반적으로 미리 준비된 입력 포트 스위치 내부 레이블이 로컬 출력 포트를 나타내는 패킷에게 전송되거나 버스에 패킷을 전송하여 수행된다.</p></div><div><p dir="auto">모든 출력 포트에 패킷이 수신되지만 레이블과 매치되는 포트만 패킷을 유지한다.</p></div><div><p dir="auto">레이블은 버스를 통과하기 위해서만 사용되므로 출력 포트에서 제거된다.</p></div><div><p dir="auto">동시에 여러 패킷이 다른 입력 포트에 있는 라우터에 도착하면 한 번에 하나의 패킷만 버스를 통과할 수 있기 때문에 하나를 제외한 모든 패킷이 대기 해야한다.</p></div><div><p dir="auto">모든 패킷이 하나의 버스를 통과해야하므로 라우터의 교환 속도는 버스 속도에 의해 제한된다.</p></div></div></div><div class="heading-wrapper"><h3 data-heading="상호 연결 네트워크(Crossbar)를 통한 교환" dir="auto" class="heading" id="상호_연결_네트워크(Crossbar)를_통한_교환"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>상호 연결 네트워크(Crossbar)를 통한 교환</h3><div class="heading-children"><div><p dir="auto"><span alt="Pasted image 20240618014341.png" src="Pasted image 20240618014341.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618014341.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618014341.png"></span><br>
크로스바 스위치는 N개의 입력 포트를 N개의 출력 포트에 연결하는 2N 버스로 구성된 상호연결 네트워크다.</p></div><div><p dir="auto">각 수직 버스는 교차점에서 각 수평 버스와 교차하며 스위치 구조 컨트롤러에 의해 언제든지 열거나 닫을 수 있다.</p></div><div><p dir="auto">이를 통해 앞의 두가지 방식과 달리 크로스바 스위치는 여러 패킷을 병렬로 전달할 수 있다.</p></div><div><p dir="auto">그러나 두개의 서로 다른 입력 포트에서 나오는 2개의 패킷이 동일한 출력 포트로 보내지는 경우 한번에 하나의 패킷만 특정 버스에서 전송될 수 있기 때문에 입력을 기다려야한다.</p></div><div><p dir="auto">좀 더 정교한 상호연결 네트워크는 다단계 스위치 구조를 통해 각기 다른 입력 포트의 패킷이 동일한 출력 포트를 향해 동시에 전달할 수 있도록 여러 단계의 스위칭 요소를 사용한다.</p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="4.2.3 출력 포트 처리" dir="auto" class="heading" id="4.2.3_출력_포트_처리"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.3 출력 포트 처리</h2><div class="heading-children"><div><p dir="auto"><span alt="Pasted image 20240618015505.png" src="Pasted image 20240618015505.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618015505.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618015505.png"></span><br>
위 그림의 출력 포트 처리는 출력 포트의 메모리에 저장된 패킷을 가져와서 출력 링크를 통해 전송한다. 여기에는 전송을 위한 패킷 선택 및 큐 제거, 필요한 링크 계층 및 물리 계층 전송 기능을 수행하는 것이 포함된다.</p></div></div></div><div class="heading-wrapper"><h2 data-heading="어디에서 큐잉이 일어날까?" dir="auto" class="heading" id="어디에서_큐잉이_일어날까?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>어디에서 큐잉이 일어날까?</h2><div class="heading-children"><div><p dir="auto">패킷 큐는 입력 포트와 출력 포트 모두에서 형성될 수 있다.</p></div><div><p dir="auto">큐의 위치와 범위는 트래픽 로드, 스위치 구조의 상대 속도 및 라인 속도에 따라서 달라진다.</p></div><div><p dir="auto">이 큐가 커지면 라우터의 메모리가 결국 소모될 수 있고 도착하는 패킷을 저장할 수 있는 메모리가 없을 때 패킷 손실이 발생한다.</p></div><div class="heading-wrapper"><h3 data-heading="입력 큐잉" dir="auto" class="heading" id="입력_큐잉"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>입력 큐잉</h3><div class="heading-children"><div><p dir="auto">지연 없이 구조를 통해 도착하는 모든 패킷을 전송하기에 스위치 구조가 충분히 빠르지 않으면 어떻게 될까?</p></div><div><p dir="auto">이 경우에는 패킷이 스위치 구조를 통해 출력 포트로 전송되기 위해 차례를 기다려야 한다.</p></div><div><p dir="auto">이 큐잉의 결과를 살펴보기 위해 크로스바 스위치 구조를 가정해보자.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">모든 링크의 속도는 같다.</li>
<li data-line="1" dir="auto">입력 링크가 패킷을 받는 것과 같은 속도로 하나의 패킷을 입력 포트에서 주어진 출력 포트로 전달한다.</li>
<li data-line="2" dir="auto">FCFS (First-Come-First-Served) 방식으로 패킷은 입력 큐에서 출력 큐로 이동된다.</li>
</ol></div><div><p dir="auto">출력 포트가 다르다면 여러 패킷이 병렬로 전달 가능하지만, 같다면 하나의 패킷만 지정된 출력 포트로 전송이 가능하고 나머지 패킷은 기다려야한다.</p></div><div><p dir="auto"><span alt="Pasted image 20240618020508.png" src="Pasted image 20240618020508.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618020508.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618020508.png"></span><br>
위 그림에서 왼쪽 상단 큐의 앞쪽에서 먼저 패킷을 전송한다고 가정해보자.</p></div><div><p dir="auto">왼쪽 하단 큐의 가장 앞쪽의 패킷은 출력 포트가 같으므로 대기하여야 하고, 두 번째 패킷은 출력 포트가 다름에도 앞의 패킷 때문에 대기하여야 한다.</p></div><div><p dir="auto">이 현상은 입력 대기 중인 스위치에서의 <code>HOL(Head-of-the-line) 차단</code> 이라고 한다.</p></div></div></div><div class="heading-wrapper"><h3 data-heading="츌력 큐잉" dir="auto" class="heading" id="츌력_큐잉"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>츌력 큐잉</h3><div class="heading-children"><div><p dir="auto">입력 포트와 출력 포트의 개수가 각각 N개이고 속도가 R이라 할 때, 스위치의 속도가 R보다 N배 빠르고 모든 입력 포트의 패킷이 동일한 출력 포트로 향한다고 가정해보자.</p></div><div><p dir="auto">이 경우, 출력 링크에서 단일 패킷을 보내는 데 걸리는 시간에 N개의 새로운 패킷이 출력 포트에 도착한다. 출력 포트는 <strong>시간 단위에 단일 패킷만을 전송할 수 있기 때문에 N개의 도착 패킷은 출력 링크를 통한 전송 큐에서 대기</strong> 해야 한다.</p></div><div><p dir="auto">이때 큐의 공간이 충분하지 않을 때, 즉 <strong>메모리가 충분하지 않을 때 도착한 패킷을 삭제하거나 이미 대기 중인 하나 이상의 패킷을 제거하여 새로 도착한 패킷을 저장하기 위한 공간을 확보</strong>해야 한다. </p></div><div><p dir="auto"><span alt="Pasted image 20240618021412.png" src="Pasted image 20240618021412.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618021412.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618021412.png"></span></p></div><div><p dir="auto">위 그림은 출력 포트 큐잉의 예시이다.</p></div><div><p dir="auto">이러한 큐잉의 결과는 출력 포트의 <code>패킷 스케줄러</code>가 전송 대기 중인 패킷 중 하나의 패킷을 선택하여 큐에서 제거 해야한다는 것이다. (다음 절에서 다룬다.)</p></div></div></div><div class="heading-wrapper"><h3 data-heading="얼마나 많은 버퍼가 요구되는가?" dir="auto" class="heading" id="얼마나_많은_버퍼가_요구되는가?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>얼마나 많은 버퍼가 요구되는가?</h3><div class="heading-children"><div><p dir="auto">몇 년 동안 [RFC3439]의 버퍼의 크기에 대한 규칙은 링크 용량이 C일 때, 버퍼링의 양은 평균 왕복 시간(RTT)와 같아야 한다는 것이다.</p></div><div><p dir="auto">즉, <code>B = RTT x C</code> 와 같은 버퍼의 양이 필요하다.</p></div><div><p dir="auto">최근의 실험과 이론에서는 많은 수의 독립적인 TCP 흐름 N이 링크를 통과할 때, 필요한 버퍼링은 <code>B = RTT x C / √N</code> 이라고 제안하고 있다.</p></div><div><p dir="auto">버퍼링이 클수록 라우터가 패킷 도착 속도의 큰 변동을 흡수하여 라우터의 패킷 손실률을 감소 시킬 수 있기 때문에 버퍼링이 낫다고 생각하는 것보다 버퍼가 클수록 큐잉 지연이 길어진다고 생각하는 편이 좋다.</p></div><div><p dir="auto">예를 들어, 패킷 손실을 줄이기 위해 홉당 버퍼의 양을 10배 늘리면 종단 간 지연이 10의 배만큼 증가한다.</p></div><div><p dir="auto">즉, <strong>버퍼의 크기 증가는 패킷 손실율을 줄일 수 있지만 종단 간 지연을 증가시킬 수 있는 양날의 검</strong>이다.</p></div><div><p dir="auto"><span alt="Pasted image 20240618022356.png" src="Pasted image 20240618022356.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618022356.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618022356.png"></span><br>
네트워크 가장자리의 라우터를 생각해보자.</p></div><div><p dir="auto">a는 TCP 세그먼트를 원격 게임 서버로 보내는 홈 라우터에 대한 설명이다. 게이머의 TCP 세그먼트를 포함하는 패킷을 전송하는 데 20ms가 소요되며, 큐잉 지연이 무시해도 될 정도라고 가정한다.</p></div><div><p dir="auto">게임 서버 경로의 다른 곳에서 지연되며 RTT는 200ms다.</p></div><div><p dir="auto">b에서와 같이 t = 0 에서 25개 패킷의 버스트가 큐에 도착한다고 가정한다.</p></div><div><p dir="auto">대기 중인 패킷들 중 하나는 20ms 마다 한 번씩 전송되므로, 21 번째 패킷이 전송되고 있는 것처럼 t = 200ms에서 첫 번째 ACK가 도착한다. 이 ACK 도착은 송신자가 다른 패킷을 보내게 한다.</p></div><div><p dir="auto">홈 라우터의 송신 링크 t = 220에서 다음 ACK가 도착하고, 또 다른 ACK가 도착한다. TCP 세그먼트는 게이머에 의해 해제되며, 22번째 패킷은 전송되는 큐에 놓인다.</p></div><div><p dir="auto">위 과정에서 ACK 클록은 대기 중인 패킷이 있을 때마다 새 패킷이 큐에 도착하게 되고, 전송되어 홈 라우터의 송신 링크에서 큐 크기가 항상 5 패킷이 된다.</p></div><div><p dir="auto">즉, <strong>종단 간 파이프는 꽉 찼지만 큐잉 지연의 양은 일정하고 지속적</strong>이다.</p></div><div><p dir="auto">결과로 게이머는 홈 네트워크에 다른 트래픽이 존재하지 않는 경우에도 지연이 지속적으로 지나치게 긴 이유를 이해하지 못하게 된다.</p></div><div><p dir="auto">이러한 지속적 버퍼링으로 인한 긴 지연에 대한 위 과정을 버퍼블로트(bufferbloat)라고 한다.</p></div><div><p dir="auto">이를 극복하기 위해 6장에서 연구할 케이블 네트워크용 DOCIS 3.1 표준은 AQM 메커니즘을 추가하여 대량 처리 성능을 보존했다.</p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="4.2.5 패킷 스케줄링" dir="auto" class="heading" id="4.2.5_패킷_스케줄링"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.5 패킷 스케줄링</h2><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="FIFO" dir="auto" class="heading" id="FIFO"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>FIFO</h3><div class="heading-children"><div><p dir="auto"><span alt="Pasted image 20240618023140.png" src="Pasted image 20240618023140.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618023140.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618023140.png"></span><br>
링크가 현재 다른 패킷을 전송 중이면, 출력 링크 큐에 도착한 패킷은 전송을 기다린다.</p></div><div><p dir="auto">도착한 패킷을 담을 버퍼 공간이 충분하지 않은 경우 도착 패킷의 공간을 확보하기 위해 큐의 패킷 폐기 정책은 패킷 손실 여부 또는 다른 패킷을 큐에서 제거할 것인지 여부를 결정한다.</p></div><div><p dir="auto"><span alt="Pasted image 20240618023208.png" src="Pasted image 20240618023208.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618023208.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618023208.png"></span><br>
FIFO 스케줄링 규칙은 출력 링크 큐에 도착한 순서와 동일한 순서로 출력 링크에서 전송할 패킷을 선택한다. </p></div><div><p dir="auto">위 그림에서는 FIFO 큐의 동작을 보여준다.</p></div></div></div><div class="heading-wrapper"><h3 data-heading="우선순위 큐잉" dir="auto" class="heading" id="우선순위_큐잉"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>우선순위 큐잉</h3><div class="heading-children"><div><img src="https://user-images.githubusercontent.com/76640167/212632896-9184e337-91f4-4277-9b70-31d4ab83794d.png" alt="우선순위 큐 개념도" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;">
![[Pasted image 20240618025704.png]]
우선순위 큐잉에서 출력 링크에 도착한 패킷은 우선순위 클래스로 분류된다.</div><div><p dir="auto">실제로 네트워크 오퍼레이터는 네트워크 관리 정보를 운반하는 패킷이 사용자 트래픽보다 우선순위를 수신하도록 큐를 구성할 수 있다.</p></div><div><p dir="auto">전송할 패킷을 선택할 때 전송 대기 중인 패킷으로 차 있는 상태이고 가장 높은 우선순위 클래스에서 패킷을 전송한다.</p></div><div><p dir="auto">우선순위가 동일한 패킷들 중에서의 선택은 FIFO 방식으로 행해진다.<br>
<span alt="Pasted image 20240618030307.png" src="Pasted image 20240618030307.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618030307.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618030307.png"></span></p></div><div><p dir="auto">위 그림은 우선순위 클래스가 2개인 경우의 큐 동작을 보여준다.</p></div><div><p dir="auto">패킷 1,3,4가 우선순위가 높기 때문에 먼저 전송된다.</p></div><div><p dir="auto">이때는 <code>비선점 우선순위 큐잉</code>이기 때문에 패킷 4의 우선순위가 높더라도 패킷 2의 전송이 시작되면 선점하지 않고 전송이 끝난 후에야 전송이 시작된다.</p></div></div></div><div class="heading-wrapper"><h3 data-heading="라운드 로빈과 WFQ" dir="auto" class="heading" id="라운드_로빈과_WFQ"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>라운드 로빈과 WFQ</h3><div class="heading-children"><div><p dir="auto">라운드 로빈 큐잉 큐칙에서는 패킷은 우선순위 큐잉과 같이 클래스로 분류되지만 클래스 간에는 엄격한 서비스 우선순위가 존재하지 않으며, 라운드 로빈 스케줄러가 클래스 간에 서비스를 번갈아서 제공한다.</p></div><div><p dir="auto">가장 단순한 라운드 로빈 스케줄링에서는 그저 클래스를 번갈아가면서 패킷을 전송한다.</p></div><div><p dir="auto"><code>작업 보존 큐잉(work-conserving queuing)</code> 규칙의 경우 전송을 위해 큐에서 기다리는 패킷이 있다면 링크는 유휴 상태가 되는 것을 허용하지 않는다.</p></div><div><p dir="auto">즉, 클래스에 패킷이 없다면 바로 시퀀스의 다음 클래스를 검사한다.<br>
<span alt="Pasted image 20240618030554.png" src="Pasted image 20240618030554.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618030554.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618030554.png"></span></p></div><div><p dir="auto">위 그림은 라운드 로빈 큐의 동작을 보여준다.<br>
<span alt="Pasted image 20240618031441.png" src="Pasted image 20240618031441.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240618031441.png" src="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_4/4.2-라우터-내부에는-무엇이-있을까_/attachments/pasted-image-20240618031441.png"></span><br>
라우터에서 널리 구현된 라운드 로빈 큐잉의 일반화된 형태는 소위 <code>WFQ(Weighted Fair Queueing) 규칙</code>이다.</p></div><div><p dir="auto">도착하는 패킷은 적절한 클래스별 대기 영역에서 분류되며 대기한다. </p></div><div><p dir="auto">WFQ 스케줄러는 <strong>라운드 로빈과 같이 순환식</strong>으로 동작한다.</p></div><div><p dir="auto">또한, <strong>작업 보존 큐잉 규칙</strong>을 따른다.</p></div><div><p dir="auto">WFQ는 각 클래스 i 는 가중치 w(i)를 할당 받는다.</p></div><div><p dir="auto">WFQ에서는 전송할 클래스 i 패킷이 있는 동안에 클래스 i는 <code>w(i) / ∑w(i)</code> 만큼의 서비스 시간을 보장받으며, 이 식에서 분모 부분은 전송을 위해 큐에 패킷이 있는 모든 클래스의 합이다.</p></div><div><p dir="auto">즉, 최악의 경우 모든 큐에 패킷이 있을 때도 위의 시간을 보장 받는다.</p></div><div><p dir="auto">따라서 전송률 R인 링크에 대해 클래스 i는 항상 최소한 <code>R x w(i) / ∑w(i)</code>의 처리율을 갖는다.</p></div><div><p dir="auto">패킷이 이상적인 단위 데이터라는 것과 패킷 전송이 다른 패킷을 전송하기 위해 방해되지 않는다는 사실을 고려하지 않았기 때문에 위 설명은 이상적이다.</p></div><div class="mod-footer"></div></div></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#4.2 라우터 내부에는 무엇이 있을까?"><div class="tree-item-contents heading-link" heading-name="4.2 라우터 내부에는 무엇이 있을까?"><span class="tree-item-title">4.2 라우터 내부에는 무엇이 있을까?</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#4.2.1_입력_포트_처리_및_목적지_기반_전송"><div class="tree-item-contents heading-link" heading-name="4.2.1 입력 포트 처리 및 목적지 기반 전송"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.2.1 입력 포트 처리 및 목적지 기반 전송</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#목적지_주소_범위_포워딩_테이블"><div class="tree-item-contents heading-link" heading-name="목적지 주소 범위 포워딩 테이블"><span class="tree-item-title">목적지 주소 범위 포워딩 테이블</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#프리_픽스_포워딩_테이블"><div class="tree-item-contents heading-link" heading-name="프리 픽스 포워딩 테이블"><span class="tree-item-title">프리 픽스 포워딩 테이블</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#4.2.2_스위칭"><div class="tree-item-contents heading-link" heading-name="4.2.2 스위칭"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.2.2 스위칭</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#메모리를_통한_교환"><div class="tree-item-contents heading-link" heading-name="메모리를 통한 교환"><span class="tree-item-title">메모리를 통한 교환</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#버스(bus)를_통한_교환"><div class="tree-item-contents heading-link" heading-name="버스(bus)를 통한 교환"><span class="tree-item-title">버스(bus)를 통한 교환</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#상호_연결_네트워크(Crossbar)를_통한_교환"><div class="tree-item-contents heading-link" heading-name="상호 연결 네트워크(Crossbar)를 통한 교환"><span class="tree-item-title">상호 연결 네트워크(Crossbar)를 통한 교환</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#4.2.3_출력_포트_처리"><div class="tree-item-contents heading-link" heading-name="4.2.3 출력 포트 처리"><span class="tree-item-title">4.2.3 출력 포트 처리</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#어디에서_큐잉이_일어날까?"><div class="tree-item-contents heading-link" heading-name="어디에서 큐잉이 일어날까?"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">어디에서 큐잉이 일어날까?</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#입력_큐잉"><div class="tree-item-contents heading-link" heading-name="입력 큐잉"><span class="tree-item-title">입력 큐잉</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#츌력_큐잉"><div class="tree-item-contents heading-link" heading-name="츌력 큐잉"><span class="tree-item-title">츌력 큐잉</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#얼마나_많은_버퍼가_요구되는가?"><div class="tree-item-contents heading-link" heading-name="얼마나 많은 버퍼가 요구되는가?"><span class="tree-item-title">얼마나 많은 버퍼가 요구되는가?</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#4.2.5_패킷_스케줄링"><div class="tree-item-contents heading-link" heading-name="4.2.5 패킷 스케줄링"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.2.5 패킷 스케줄링</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#FIFO"><div class="tree-item-contents heading-link" heading-name="FIFO"><span class="tree-item-title">FIFO</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#우선순위_큐잉"><div class="tree-item-contents heading-link" heading-name="우선순위 큐잉"><span class="tree-item-title">우선순위 큐잉</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_4\4.2-라우터-내부에는-무엇이-있을까_\readme.html#라운드_로빈과_WFQ"><div class="tree-item-contents heading-link" heading-name="라운드 로빈과 WFQ"><span class="tree-item-title">라운드 로빈과 WFQ</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>