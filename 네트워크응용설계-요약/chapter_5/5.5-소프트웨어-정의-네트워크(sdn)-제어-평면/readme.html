<!DOCTYPE html> <html><head>
		<title>README</title>
		<base href="..\..\..\..\../">
		<meta id="root-path" root-path="..\..\..\..\../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Obsidian_main - README">
		<meta property="og:title" content="README">
		<meta property="og:description" content="Obsidian_main - README">
		<meta property="og:type" content="website">
		<meta property="og:url" content="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_5/5.5-소프트웨어-정의-네트워크(sdn)-제어-평면/readme.html">
		<meta property="og:image" content="https://user-images.githubusercontent.com/86337233/213711658-f229ca35-e7a3-4818-b85f-ac2276e417e5.png">
		<meta property="og:site_name" content="Obsidian_main">
		<meta name="author" content="dustbox"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title show-ribbon mk-readable-line mk-folder-lines mk-spaces-enabled mk-inline-context-enabled mk-flow-seamless"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="5.5 소프트웨어 정의 네트워크(SDN) 제어 평면"><p dir="auto">5.5 소프트웨어 정의 네트워크(SDN) 제어 평면</p></h1><div class="heading-wrapper"><div class="heading-children"><div><p dir="auto">이 절에서는 4.4절에서 사용한 SDN 용어들을 다시 채택하여<br>
네트워크의 포워딩 장비들은 ‘<code>패킷 스위치</code>’ 또는 그냥 ‘<code>스위치</code>’라고 부를 것이다.</p></div><div><p dir="auto">이 스위치들에서의 포워딩 결정은 네트워크 계층에서의 출발지/목적지 주소, 링크 계층에서의 출발지/목적지 주소 외에도<br>
트랜스포트 계층, 네트워크 계층, 링크 계층 패킷 헤더의 다른 많은 값에 기반하여 이루어진다.</p></div><div><br></div><div class="heading-wrapper"><h2 data-heading="SDN 구조의 특징" dir="auto" class="heading" id="SDN_구조의_특징"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>SDN 구조의 특징</h2><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="플로우 기반 포워딩" dir="auto" class="heading" id="플로우_기반_포워딩"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>플로우 기반 포워딩</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto"><code>SDN</code>으로 제어되는 스위치들에서의 패킷 전달은 트랜스포트 계층, 네트워크 계층, 또는 링크 계층 헤더의 <strong>어떤 값을 기반으로 하든 이루어질 수 있다.</strong></p>
</blockquote></div><div><p dir="auto">이는 앞 절에서 살펴본,<br>
<code>IP 데이터그램</code>의 포워딩이 온전히 데이터그램의 목적지 주소를 기반으로 이루어지는 전통적인 라우터 기반 포워딩과는 매우 대조적인 특성이다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 SDN에서는 모든 네트워크 스위치의 플로우 테이블 항목들을 계산하고 관리, 설치하는 일이 모두 <code>SDN 제어 평면</code>의 임무다.</p>
</blockquote></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="데이터 평면과 제어 평면의 분리" dir="auto" class="heading" id="데이터_평면과_제어_평면의_분리"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>데이터 평면과 제어 평면의 분리</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="데이터 평면" dir="auto" class="heading" id="데이터_평면"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>데이터 평면</h4><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">네트워크의 <code>스위치</code>들로 구성된다. (이들은 상대적으로 단순하지만 빠른 장치들)</li>
<li data-line="1" dir="auto">자신들의 플로우 테이블 내용을 기반으로 ‘매치 플러스 액션’을 수행한다.</li>
</ul></div><div><br></div></div></div><div class="heading-wrapper"><h4 data-heading="제어 평면" dir="auto" class="heading" id="제어_평면"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>제어 평면</h4><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">서버와 스위치들의 플로우 테이블을 결정, 관리하는 <code>소프트웨어</code>로 이루어진다.</li>
</ul></div><div><br></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="네트워크 제어 기능이 데이터 평면 스위치 외부에 존재" dir="auto" class="heading" id="네트워크_제어_기능이_데이터_평면_스위치_외부에_존재"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>네트워크 제어 기능이 데이터 평면 스위치 외부에 존재</h3><div class="heading-children"><div><p dir="auto"><code>SDN 제어 평면</code>은 소프트웨어로 구현되어 있으며, 네트워크 스위치로부터 멀리 떨어진 별도의 서버에서 수행된다.</p></div><div><br></div><div><p dir="auto">아래의 그림에서 볼 수 있듯, 제어 평면은 2개의 구성요소로 이루어진다.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto"><code>SDN 컨트롤러</code>(또는 네트워크 운영체제)</li>
<li data-line="1" dir="auto"><code>SDN 네트워크 제어 애플리케이션</code>들의 집합</li>
</ol></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/213711658-f229ca35-e7a3-4818-b85f-ac2276e417e5.png" alt="SDN의 구성요소" referrerpolicy="no-referrer" style="width: 600px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">SDN 컨트롤러는</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">정확한 상태정보(e.g., 원격 링크와 스위치, 호스트들의 상태)를 유지하고,</li>
<li data-line="1" dir="auto">이 정보를 네트워크 제어 애플리케이션들에 제공하며,</li>
<li data-line="2" dir="auto">애플리케이션들이 하부 네트워크 장치들을 모니터하고 프로그램하고 제어까지 할 수 있도록 수단을 제공한다.</li>
</ol></div><div><br></div><div><p dir="auto">그림에서의 컨트롤러는 단일 중앙 서버의 형태이지만, 실제로 컨트롤러는 <strong>논리적으로만 중앙 집중 형태</strong>다.</p></div><div><p dir="auto">(일반적으로는 협업 능력과 확장성, 높은 이용성을 갖도록 몇 개의 서버에 구현)</p></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="프로그램이 가능한 네트워크" dir="auto" class="heading" id="프로그램이_가능한_네트워크"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>프로그램이 가능한 네트워크</h3><div class="heading-children"><div><p dir="auto">제어 평면에서 수행 중인 네트워크 제어 애플리케이션을 통해 네트워크를 프로그램할 수 있다.</p></div><div><p dir="auto">이 애플리케이션들은 <strong>SDN 컨트롤러가 제공하는 API를 이용하여</strong> 네트워크 장치들에 있는 데이터 평면을 명세하고 제어한다.</p></div><div><p dir="auto">e.g.,<br>
라우팅 네트워크 제어 애플리케이션은 <strong>SDN 컨트롤러가 갖고 있는 노드 상태 및 링크 상태 정보에 기반한</strong> 다익스트라 알고리즘을 수행하여<br>
출발지와 목적지 사이의 종단 간 경로를 결정한다.</p></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="5.5.1 SDN 제어 평면" dir="auto" class="heading" id="5.5.1_SDN_제어_평면"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.5.1 SDN 제어 평면</h2><div class="heading-children"><div><p dir="auto">: SDN 컨트롤러와 SDN 네트워크 제어 애플리케이션</p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="SDN 컨트롤러" dir="auto" class="heading" id="SDN_컨트롤러"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>SDN 컨트롤러</h3><div class="heading-children"><div><p dir="auto">컨트롤러의 기능은 크게 3개의 계층으로 구성된다.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto"><code>네트워크 제어 애플리케이션 계층과의 인터페이스</code></li>
<li data-line="1" dir="auto"><code>네트워크 전역 상태 관리 계층</code></li>
<li data-line="2" dir="auto"><code>통신 계층</code></li>
</ol></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/213711664-270bb750-0349-4109-aaca-cc97627caee1.png" alt="SDN 컨트롤러 구성요소" referrerpolicy="no-referrer" style="width: 580px; max-width: 100%;"></p></div><div><br>
<br></div><div class="heading-wrapper"><h4 data-heading="통신 계층: SDN 컨트롤러와 **제어받는 네트워크 장치들 사이**의 통신" dir="auto" class="heading" id="통신_계층:_SDN_컨트롤러와_**제어받는_네트워크_장치들_사이**의_통신"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>통신 계층: SDN 컨트롤러와 <strong>제어받는 네트워크 장치들 사이</strong>의 통신</h4><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 제어받는 장치들과의 통신</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">SDN 컨트롤러가 원격의 SDN 기능이 가능한 장치들의 동작을 제어하려면 컨트롤러와 그 장치들 사이에 정보를 전달하는 프로토콜이 필요하다.</li>
<li data-line="1" dir="auto">장치는 주변에서 관찰한 이벤트를 컨트롤러에 알려, 네트워크 상태에 대한 최신의 정보를 제공해야 한다.</li>
</ul></div><div><p dir="auto">컨트롤러와 제어받는 장치들 간의 통신은 ‘<code>사우스바운드(southbound)</code>’라고 알려진 <strong>컨트롤러 인터페이스</strong>를 넘나든다.</p></div><div><p dir="auto">이 통신 기능을 제공하는 구체적 프로토콜은 <code>OpenFlow</code>이며, 이는 모두는 아니지만 대부분의 SDN 컨트롤러에 구현되어 있다.</p></div><div><br></div></div></div><div class="heading-wrapper"><h4 data-heading="네트워크 전역 상태 관리 계층" dir="auto" class="heading" id="네트워크_전역_상태_관리_계층"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>네트워크 전역 상태 관리 계층</h4><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 네트워크 전역에 분산되고 견고한 상태 관리</p>
</blockquote></div><div><p dir="auto">SDN 제어 평면의 궁극적인 제어 결정을 위해서는<br>
컨트롤러가 네트워크 호스트와 링크, 스위치, 그리고 SDN으로 제어되는 다른 장치들에 대한 최신 정보를 알아야 한다.</p></div><div><p dir="auto">제어 평면의 궁극적인 목적은 다양한 제어 장치들의 플로우 테이블을 결정하는 것이므로 컨트롤러도 이 테이블들의 복사본을 유지해야 할 것이다.</p></div><div><p dir="auto">스위치의 플로우 테이블이 가지는 카운터들과 같은 이러한 정보 조각들은 모두 SDN 컨트롤러가 유지하는 <b>네트워크 전역 ‘상태’</b>의 예들이다.</p></div><div><br></div></div></div><div class="heading-wrapper"><h4 data-heading="네트워크 제어 애플리케이션 계층과의 인터페이스" dir="auto" class="heading" id="네트워크_제어_애플리케이션_계층과의_인터페이스"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>네트워크 제어 애플리케이션 계층과의 인터페이스</h4><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 네트워크 제어 애플리케이션들을 위한 인터페이스와 추상화</p>
</blockquote></div><div><p dir="auto">컨트롤러는 <code>‘노스바운드(northbound)’ 인터페이스</code>를 통해 네트워크 제어 애플리케이션과 상호작용한다.</p></div><div><p dir="auto">이 API는 네트워크 제어 애플리케이션이 상태 관리 계층 내의 네트워크 상태 정보와 플로우 테이블을 읽고 쓸 수 있도록 해준다.</p></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">SDN 컨트롤러는 외부에서 볼 때 <em>‘논리적으로 중앙 집중된’</em>, 잘 짜여진 하나의 서비스로 보일 수 있지만,</p></div><div><p dir="auto">이 서비스들과 상태 정보를 보관하기 위한 데이터베이스는<br>
장애 허용성(fault tolerance)과 높은 가용성, 또는 다른 성능상의 이유로 실제로는 <strong>분산된</strong> 서버의 집합에 구현된다.</p></div><div><br></div><div><p dir="auto">근래의 컨트롤러는 논리적으로는 중앙 집중 형태이나 물리적으로는 분리된 컨트롤러 플랫폼 구조이다.</p></div><div><p dir="auto">이런 구조는 제어되는 장치와 네트워크 제어 애플리케이션에게 늘어나는 장치 수에 따라 확장 가능한 서비스와 높은 가용성을 제공한다.</p></div><div><br>
<br></div></div></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="5.5.2 OpenFlow 프로토콜" dir="auto" class="heading" id="5.5.2_OpenFlow_프로토콜"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.5.2 OpenFlow 프로토콜</h2><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">OpenFlow 프로토콜은 SDN 컨트롤러와 SDN으로 제어되는 스위치 또는 OpenFlow API를 구현하는 다른 장치와의 사이에서 동작한다.</li>
<li data-line="1" dir="auto">OpenFlow 프로토콜은 TCP상에서 디폴트 포트 번호 <code>6653</code>을 가지고 동작한다.</li>
</ul></div><div><br></div><div><p dir="auto"><strong>컨트롤러가 제어되는 스위치로 전달하는</strong> 중요한 메시지는 다음과 같다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><code>설정</code> : 이 메시지는 컨트롤러가 스위치의 설정 파라미터들을 문의하거나 설정할 수 있도록 한다.</p>
</li>
<li data-line="2" dir="auto">
<p dir="auto"><code>상태 수정</code> : 이 메시지는 컨트롤러가 스위치 플로우 테이블의 엔트리를 추가/제거 또는 수정하거나 스위치 포트의 특성을 설정하기 위해 사용한다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto"><code>상태 읽기</code> : 이 메시지는 컨트롤러가 스위치 플로우 테이블과 포트로부터 통계 정보와 카운터값을 얻기 위해 사용한다.</p>
</li>
<li data-line="4" dir="auto">
<p dir="auto"><code>패킷 전송</code> : 이 메시지는 컨트롤러가 제어하는 스위치의 지정된 포트에서 특정 패킷을 내보내기 위해 사용한다.<br>
이 메시지 자체는 페이로드 부분에 보낼 패킷을 포함한다.</p>
</li>
</ul></div><div><br></div><div><p dir="auto">SDN으로 제어되는 <strong>스위치에서 컨트롤러로 전달되는</strong> 주요 메시지는 다음과 같다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><code>플로우 제거</code> : 이 메시지는 컨트롤러에게 어떤 플로우 테이블 엔트리가 시간이 만료되었거나 <strong>상태 수정</strong> 메시지를 수신한 결과로 삭제되었음을 알린다.</li>
<li data-line="1" dir="auto"><code>포트 상태</code> : 이 메시지는 스위치가 컨트롤러에게 포트의 상태 변화를 알리기 위해 사용된다.</li>
<li data-line="2" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>패킷 전달</code>
<ul dir="auto">
<li data-line="3" dir="auto">4.4절에서 스위치 포트에 도착한 패킷 중에서 플로우 테이블의 어떤 엔트리와도 일치하지 않는 패킷은 처리를 위해 컨트롤러에게 전달된다고 했다.</li>
<li data-line="4" dir="auto">어떤 엔트리와 일치한 패킷 중에서도 일부는 그에 대한 작업을 수행하기 위해 컨트롤러에게 보내지기도 한다.<br>
이 메시지는 그러한 패킷을 컨트롤러에게 보내기 위해 사용한다.</li>
</ul>
</li>
</ul></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="5.5.3 데이터 평면과 제어 평면의 상호작용: 예제" dir="auto" class="heading" id="5.5.3_데이터_평면과_제어_평면의_상호작용:_예제"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.5.3 데이터 평면과 제어 평면의 상호작용: 예제</h2><div class="heading-children"><div><p dir="auto">아래 그림은 SDN의 제어를 받는 스위치와 SDN 컨트롤러 간의 상호작용에 대한 것이다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">여기서는 다익스트라 알고리즘이 최단 경로를 결정하기 위해 사용되는데,<br>
다익스트라 알고리즘은 <strong>패킷 스위치 외부에서</strong> 별도의 애플리케이션으로 수행된다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">패킷 스위치들이 <strong>링크 갱신 정보를</strong> 서로 간이 아닌 <strong>SDN 컨트롤러에게 전송한다.</strong></p>
</li>
</ul></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/213711666-386f50a2-908c-4aad-b862-92b868626000.png" alt="SDN 컨트롤러 시나리오" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;"></p></div><div><br>
<br></div><div><ul dir="auto">
<li data-line="0" dir="auto">최단 경로 알고리즘이 사용되고 있다.</li>
<li data-line="1" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>스위치 s1과 s2 사이의 링크가 단절되었다</code>고 가정해보자.
<ul dir="auto">
<li data-line="2" dir="auto">따라서 s1, s3, s4로 들어오고 나가는 플로우 포워딩 규칙은 변경되었으나, s2의 동작은 바뀌지 않았다고 가정한다.</li>
</ul>
</li>
<li data-line="3" dir="auto">통신 계층 프로토콜로는 OpenFlow가 사용된다.</li>
<li data-line="4" dir="auto">제어 평면은 링크 상태 라우팅 외의 기능은 수행하지 않는다.</li>
</ul></div><div><br></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><strong>스위치 s2와의 링크 단절을 감지한 s1</strong>은 OpenFlow의 <code>포트 상태 메시지</code>를 사용하여 링크 상태의 변화를 SDN 컨트롤러에게 알린다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">링크 상태 변화를 알리는 OpenFlow 메시지를 받은 <code>SDN 컨트롤러</code>는 링크 상태 관리자에게 알리고,<br>
<code>링크 상태 관리자</code>는 링크 상태 데이터베이스를 갱신한다.</p>
</li>
<li data-line="7" dir="auto">
<p dir="auto">다익스트라 링크 상태 라우팅을 담당하는 <code>네트워크 제어 애플리케이션</code>은 링크 상태의 변화가 있을 경우 알려달라고 이전에 등록해두었다.<br>
이 애플리케이션이 링크 상태의 변화에 대한 알림을 받게 된다.</p>
</li>
<li data-line="11" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>링크 상태 라우팅 애플리케이션</code>이 링크 상태 관리자에게 요청하여 <strong>갱신된 링크 상태</strong>를 가져온다.</p>
<ul dir="auto">
<li data-line="12" dir="auto">이 작업은 상태 관리 계층에 있는 다른 구성 요소의 도움이 필요할 수도 있다.</li>
<li data-line="13" dir="auto"><strong>그 후 새로운 최소 비용 경로를 계산한다.</strong></li>
</ul>
</li>
<li data-line="16" dir="auto">
<p dir="auto">링크 상태 라우팅 애플리케이션은 갱신되어야 할 플로우 테이블을 결정하는 플로우 테이블 관리자와 접촉한다.</p>
</li>
<li data-line="19" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>플로우 테이블 관리자</code>는 OpenFlow 프로토콜을 사용하여 <strong>링크 상태 변화에 영향을 받는 스위치들의 플로우 테이블을 갱신한다.</strong></p>
<ul dir="auto">
<li data-line="20" dir="auto">이 예에서는 s1, s2, s4가 이에 해당한다.</li>
<li data-line="21" dir="auto">s1 : 이제부터 s2를 목적지로 하는 패킷을 s4로 보낸다.</li>
<li data-line="22" dir="auto">s2 : 이제부터 s1로부터의 패킷을 중간 스위치 s4를 통해 받는다.</li>
<li data-line="23" dir="auto">s4 : s1에서 s2로 가는 패킷을 전달해야 한다.</li>
</ul>
</li>
</ol></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 컨트롤러가 플로우 테이블을 마음대로 변경할 수 있기 때문에<br>
단순히 애플리케이션 제어 소프트웨어를 바꿈으로써 원하는 어떤 형태의 포워딩 방식도 구현할 수 있다.</p>
</blockquote></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="5.5.4 SDN: 과거와 미래" dir="auto" class="heading" id="5.5.4_SDN:_과거와_미래"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.5.4 SDN: 과거와 미래</h2><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="과거" dir="auto" class="heading" id="과거"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>과거</h3><div class="heading-children"><div><p dir="auto">SDN이 많은 관심을 받게 된 것은 비교적 최근의 현상이지만,<br>
SDN의 기술적인 뿌리, 특히 데이터와 제어 평면의 분리를 상당히 거슬러 올라간다.</p></div><div><br></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">2004년에 [Feamster 2004, Lakshman 2004, RFC 3746]은 모두 <strong>네트워크 데이터와 제어 평면의 분리</strong>를 주장했다.</p>
</li>
<li data-line="3" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>에탄(Ethane) 프로젝트[Casado 2007]</code>는<br>
(1) ‘매치 플러스 액션’ 플로우 테이블이 있는 간단한 플로우 기반 이더넷 스위치,<br>
(2) 플로우 수용 및 라우팅을 관리하는 중앙 집중식 컨트롤러,<br>
(3) 그리고 플로우 테이블의 어떤 엔트리와도 일치하지 않는 <strong>패킷을 스위치에서 컨트롤러로 전달하는 개념</strong>을 개척했다.</p>
 <br>
<ul dir="auto">
<li data-line="10" dir="auto">300개 이상의 에탄 스위치로 구성된 네트워크가 2007년에 운영되었다.</li>
<li data-line="11" dir="auto">에탄은 OpenFlow 프로젝트로 빠르게 진화했다.</li>
</ul>
</li>
</ul></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="미래" dir="auto" class="heading" id="미래"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>미래</h3><div class="heading-children"><div><p dir="auto">SDN 혁명은 ‘<code>단순한 상용 스위칭 하드웨어와 정교한 소프트웨어 제어 평면</code>’으로<br>
’모든 기능이 하나로 통합된 스위치와 라우터(데이터 및 제어 평면 모두)’를 교체해나가고 있다.</p></div><div><p dir="auto"><code>네트워크 기능 가상화(network functions virtualization, NFV)</code>로 알려진 <strong>SDN의 일반화</strong>는 단순한 상용 서버, 스위칭 및 저장소를 가지고<br>
복잡한 미들박스(전용 하드웨어 및 미디어 캐싱/서비스를 위한 고유의 소프트웨어를 가진 미들박스)를 혁신적으로 교체하는 것을 목표로 한다.</p></div><div><br></div><div><p dir="auto">연구의 중요한 두 번째 영역은 SDN 개념을 AS 내부 설정에서 <strong>AS 간 설정으로 확장</strong>하려는 것이다.</p></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="SDN 컨트롤러 사례연구: OpenDaylight와 ONOS 컨트롤러" dir="auto" class="heading" id="SDN_컨트롤러_사례연구:_OpenDaylight와_ONOS_컨트롤러"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>SDN 컨트롤러 사례연구: OpenDaylight와 ONOS 컨트롤러</h2><div class="heading-children"><div><p dir="auto">일부 SDN 컨트롤러는 특정 회사를 위한 고유 제품이다.</p></div><div><p dir="auto">그러나 더 많은 컨트롤러는 오픈소스이며 다양한 프로그래밍 언어로 구현된다.</p></div><div><br></div><div><p dir="auto">가장 최근에는 <code>OpenDaylight 컨트롤러</code>와 <code>ONOS 컨트롤러</code>가 산업계에서 상당한 지지를 얻었다.</p></div><div><p dir="auto">이 둘은 모두 오픈소스이며, 리눅스 재단(Linux Foundation)과 공동으로 개발 중이다.</p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="OpenDaylight 컨트롤러" dir="auto" class="heading" id="OpenDaylight_컨트롤러"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>OpenDaylight 컨트롤러</h3><div class="heading-children"><div><p dir="auto">아래 그림은 <code>ODL(OpenDaylight) 컨트롤러 플랫폼[OpenDaylight 2020, Eckel 2017]</code>의 간략한 구조다.</p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/213711668-cf0281bd-cc01-444e-a547-425e81297c10.png" alt="OpenDaylight 컨트롤러" referrerpolicy="no-referrer" style="width: 620px; max-width: 100%;"></p></div><div><br>
<br></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">ODL의 기본 네트워크 서비스 기능들은 컨트롤러의 핵심부에 있다.</p>
</li>
<li data-line="3" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>서비스 추상 계층(Service Abstraction Layer, SAL)</code></p>
<ul dir="auto">
<li data-line="4" dir="auto">컨트롤러 구성요소와 애플리케이션이 서로의 서비스를 호출하고 그들이 생성한 이벤트에 대한 알림을 받을 수 있도록 한다.</li>
<li data-line="5" dir="auto">OpenFlow와 SNMP(Simple Network Management Protocol) 및 NETCONF(Network Configuration) 같은,<br>
ODL 컨트롤러와 제어 장치 간 프로토콜들에게 <strong>균일한 추상 인터페이스</strong>를 제공한다.</li>
</ul>
</li>
<li data-line="9" dir="auto">
<p dir="auto"><code>OVSDB(Open vSwitch Database Management Protocol)</code>는 <strong>데이터 센터 스위칭</strong>을 관리하는 데 사용된다.<br>
<em>(데이터 센터 네트워킹에 대해서는 6장에서 다룸)</em></p>
</li>
</ul></div><div><br></div><div><p dir="auto">가장 상단의 <code>네트워즈 조정 및 애플리케이션</code>부는<br>
데이터 평면의 포워딩과 방화벽 및 로드 밸런싱 같은 <strong>서비스들이 제어 장치에서 어떻게 수행될지를 결정한다.</strong></p></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="ONOS 컨트롤러" dir="auto" class="heading" id="ONOS_컨트롤러"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>ONOS 컨트롤러</h3><div class="heading-children"><div><p dir="auto">아래 그림은 <code>ONOS 컨트롤러[ONOS 2020]</code>를 간략화한 모습이다.</p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/213711671-83b1df03-db2f-409b-8870-f750a34af119.png" alt="ONOS 컨트롤러" referrerpolicy="no-referrer" style="width: 620px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">표준 컨트롤러와 유사하게 3개의 계층을 구분할 수 있다.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>노스바운드</code> 추상화 프로토콜</p>
<ul dir="auto">
<li data-line="1" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>ONOS는 의도(intent) 프레임워크이다.
<ul dir="auto">
<li data-line="2" dir="auto">이는 애플리케이션이 해당 서비스가 구체적으로 어떻게 구현되는지 몰라도<br>
높은 수준의 서비스(e.g., 어떤 호스트 A와 B 사이의 연결을 설정)를 요청할 수 있게 해준다.</li>
</ul>
</li>
<li data-line="4" dir="auto">상태 정보가 노스바운드 API를 통과하여<br>
네트워크 제어 애플리케이션에게 동기적(직접 질의를 통해) 또는 비동기적(e.g,. 네트워크 상태가 변화했을 때 알림 기능)으로 제공된다.</li>
</ul>
</li>
<li data-line="8" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>분산 코어</code></p>
<ul dir="auto">
<li data-line="9" dir="auto">네트워크 링크, 호스트, 장치의 상태는 ONOS의 분산 코어에 유지된다.</li>
<li data-line="10" dir="auto">ONOS 코어는 서비스 복제와 인스턴스 간 협력 메커니즘을 제공함으로써<br>
상부의 애플리케이션과 하부의 네트워크 장치에게 논리적 중앙 집중형 코어 서비스의 추상화를 제공한다.</li>
</ul>
</li>
<li data-line="14" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>사우스바운드</code> 추상화와 프로토콜</p>
<ul dir="auto">
<li data-line="15" dir="auto">사우스바운드 추상화는 하부의 호스트, 링크, 스위치, 프로토콜의 이질성을 숨겨준다.</li>
<li data-line="16" dir="auto">따라서 분산 코어가 장치나 프로토콜 종류에 상관없이 동작할 수 있다.</li>
<li data-line="17" dir="auto">이 추상화 때문에 분산 코어 아래의 사우스 바운드 인터페이스는 표준 컨트롤러나 ODL 컨트롤러보다 논리적으로 높다.</li>
</ul>
</li>
</ol></div><div class="mod-footer"></div></div></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#5.5 소프트웨어 정의 네트워크(SDN) 제어 평면"><div class="tree-item-contents heading-link" heading-name="5.5 소프트웨어 정의 네트워크(SDN) 제어 평면"><span class="tree-item-title">5.5 소프트웨어 정의 네트워크(SDN) 제어 평면</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#SDN_구조의_특징"><div class="tree-item-contents heading-link" heading-name="SDN 구조의 특징"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">SDN 구조의 특징</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#플로우_기반_포워딩"><div class="tree-item-contents heading-link" heading-name="플로우 기반 포워딩"><span class="tree-item-title">플로우 기반 포워딩</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#데이터_평면과_제어_평면의_분리"><div class="tree-item-contents heading-link" heading-name="데이터 평면과 제어 평면의 분리"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">데이터 평면과 제어 평면의 분리</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#데이터_평면"><div class="tree-item-contents heading-link" heading-name="데이터 평면"><span class="tree-item-title">데이터 평면</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#제어_평면"><div class="tree-item-contents heading-link" heading-name="제어 평면"><span class="tree-item-title">제어 평면</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#네트워크_제어_기능이_데이터_평면_스위치_외부에_존재"><div class="tree-item-contents heading-link" heading-name="네트워크 제어 기능이 데이터 평면 스위치 외부에 존재"><span class="tree-item-title">네트워크 제어 기능이 데이터 평면 스위치 외부에 존재</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#프로그램이_가능한_네트워크"><div class="tree-item-contents heading-link" heading-name="프로그램이 가능한 네트워크"><span class="tree-item-title">프로그램이 가능한 네트워크</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#5.5.1_SDN_제어_평면"><div class="tree-item-contents heading-link" heading-name="5.5.1 SDN 제어 평면"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5.5.1 SDN 제어 평면</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#SDN_컨트롤러"><div class="tree-item-contents heading-link" heading-name="SDN 컨트롤러"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">SDN 컨트롤러</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#통신_계층:_SDN_컨트롤러와_**제어받는_네트워크_장치들_사이**의_통신"><div class="tree-item-contents heading-link" heading-name="통신 계층: SDN 컨트롤러와 **제어받는 네트워크 장치들 사이**의 통신"><span class="tree-item-title">통신 계층: SDN 컨트롤러와 <strong>제어받는 네트워크 장치들 사이</strong>의 통신</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#네트워크_전역_상태_관리_계층"><div class="tree-item-contents heading-link" heading-name="네트워크 전역 상태 관리 계층"><span class="tree-item-title">네트워크 전역 상태 관리 계층</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#네트워크_제어_애플리케이션_계층과의_인터페이스"><div class="tree-item-contents heading-link" heading-name="네트워크 제어 애플리케이션 계층과의 인터페이스"><span class="tree-item-title">네트워크 제어 애플리케이션 계층과의 인터페이스</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#5.5.2_OpenFlow_프로토콜"><div class="tree-item-contents heading-link" heading-name="5.5.2 OpenFlow 프로토콜"><span class="tree-item-title">5.5.2 OpenFlow 프로토콜</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#5.5.3_데이터_평면과_제어_평면의_상호작용:_예제"><div class="tree-item-contents heading-link" heading-name="5.5.3 데이터 평면과 제어 평면의 상호작용: 예제"><span class="tree-item-title">5.5.3 데이터 평면과 제어 평면의 상호작용: 예제</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#5.5.4_SDN:_과거와_미래"><div class="tree-item-contents heading-link" heading-name="5.5.4 SDN: 과거와 미래"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5.5.4 SDN: 과거와 미래</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#과거"><div class="tree-item-contents heading-link" heading-name="과거"><span class="tree-item-title">과거</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#미래"><div class="tree-item-contents heading-link" heading-name="미래"><span class="tree-item-title">미래</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#SDN_컨트롤러_사례연구:_OpenDaylight와_ONOS_컨트롤러"><div class="tree-item-contents heading-link" heading-name="SDN 컨트롤러 사례연구: OpenDaylight와 ONOS 컨트롤러"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">SDN 컨트롤러 사례연구: OpenDaylight와 ONOS 컨트롤러</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#OpenDaylight_컨트롤러"><div class="tree-item-contents heading-link" heading-name="OpenDaylight 컨트롤러"><span class="tree-item-title">OpenDaylight 컨트롤러</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_5\5.5-소프트웨어-정의-네트워크(sdn)-제어-평면\readme.html#ONOS_컨트롤러"><div class="tree-item-contents heading-link" heading-name="ONOS 컨트롤러"><span class="tree-item-title">ONOS 컨트롤러</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>