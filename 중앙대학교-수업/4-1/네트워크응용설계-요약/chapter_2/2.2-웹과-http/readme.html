<!DOCTYPE html> <html><head>
		<title>README</title>
		<base href="..\..\..\..\../">
		<meta id="root-path" root-path="..\..\..\..\../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Obsidian_main - README">
		<meta property="og:title" content="README">
		<meta property="og:description" content="Obsidian_main - README">
		<meta property="og:type" content="website">
		<meta property="og:url" content="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_2/2.2-웹과-http/readme.html">
		<meta property="og:image" content="https://user-images.githubusercontent.com/76640167/210488592-53e2960a-2ec3-4ecf-8408-8d51a3ebb968.png">
		<meta property="og:site_name" content="Obsidian_main">
		<meta name="author" content="dustbox"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title show-ribbon mk-readable-line mk-folder-lines mk-spaces-enabled mk-inline-context-enabled mk-flow-seamless"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="2.2 웹과 HTTP"><p dir="auto">2.2 웹과 HTTP</p></h1><div class="heading-wrapper"><div class="heading-children"><div><p dir="auto">웹은 <code>온디맨드(on-demand) 방식</code>으로 <strong>사용자가 원할 때 원하는 것을 수신한다.</strong></p></div><div><p dir="auto">개인은 또한, 웹 상에서 많은 정보를 얻고 상호작용할 수 있다.</p></div><div><br>
<br>
<br></div></div></div><div class="heading-wrapper"><h1 data-heading="2.2.1 HTTP 개요" dir="auto" class="heading" id="2.2.1_HTTP_개요">2.2.1 HTTP 개요</h1><div class="heading-children"><div><p dir="auto"><code>웹 애플리케이션 계층 프로토콜</code>은 웹의 중심이다.</p></div><div><p dir="auto">RFC 1945, RFC 7230, RFC 7540에 정의되어 있다.</p></div><div><p dir="auto"><code>HTTP</code>는 <strong>메시지의 구조</strong> 및 <strong>클라이언트와 서버가 메시지를 어떻게 교환하는지</strong>에 대해 정의하고 있다.</p></div><div><p dir="auto">자세히 설명하기 전에 웹 전문 용어들을 알아보자.</p></div><div><br>
<br></div><div class="heading-wrapper"><h2 data-heading="웹 페이지(web page)" dir="auto" class="heading" id="웹_페이지(web_page)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>웹 페이지(web page)</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">웹 페이지들은 객체(object)로 구성된다.</p>
</blockquote></div><div><p dir="auto">객체는 단순히 단일 URL로 지정할 수 있는 하나의 파일(HTML, JPEG 이미지, 자바스크립트 등)이다.</p></div><div><br></div><div><p dir="auto">대부분의 웹 페이지는 기본 HTML 파일과 여러 참조 객체로 구성된다.</p></div><div><p dir="auto">예를 들어, 웹 페이지가 HTML 텍스트와 5개의 JPEG 이미지로 구성되어 있으면, 이 웹페이지는 6개의 객체를 갖는다.</p></div><div><br></div><div><p dir="auto">기본 HTML 파일은 페이지 내부의 다른 객체를 그 객체의 <code>URL</code>로 참조한다.</p></div><div><p dir="auto">URL은 객체를 갖고 있는 서버의 호스트 이름과 객체의 경로 이름을 갖고 있다.</p></div><div><p dir="auto">e.g.,</p></div><div><pre dir="auto"><code>http://www.school.edu/picture.gif 
</code><button class="copy-code-button">복사</button></pre></div><div><ul dir="auto">
<li data-line="0" dir="auto">호스트의 이름 : <code>www.school.edu</code></li>
<li data-line="1" dir="auto">경로 이름 : <code>picture.gif</code></li>
</ul></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="웹 브라우저와 클라이언트" dir="auto" class="heading" id="웹_브라우저와_클라이언트"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>웹 브라우저와 클라이언트</h2><div class="heading-children"><div><p dir="auto"><code>웹 브라우저(Web browser)</code>는 HTTP의 클라이언트 측을 구현하기 때문에, 웹의 관점에서 브라우저와 <code>클라이언트(client)</code>라는 용어를 혼용하여 사용한다.</p></div><div><p dir="auto">브라우저는 요구한 웹 페이지를 보여주고 여러가지 인터넷 항해와 구성 특성을 제공한다.</p></div><div><br></div><div><p dir="auto"><code>웹 서버(Web server)</code>는 URL로 각각을 지정할 수 있는 웹 객체를 갖고 있다.</p></div><div><p dir="auto">일반적으로, 사용자가 웹 페이지를 요청할 때<br>
(1) 브라우저는 페이지 내부의 객체에 대한 HTTP 요청 메세지를 서버에게 보내고,<br>
(2) 서버는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지로 응답한다.</p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/76640167/210488592-53e2960a-2ec3-4ecf-8408-8d51a3ebb968.png" alt="웹서버와 브라우저" referrerpolicy="no-referrer" style="width: 450px; max-width: 100%;"></p></div><div><br>
<br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="HTTP와 TCP" dir="auto" class="heading" id="HTTP와_TCP"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>HTTP와 TCP</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">HTTP는 <code>TCP</code>를 전송 프로토콜로 사용한다.</p>
</blockquote></div><div><br></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">연결이 이루어지면, 브라우저와 서버 프로세스는 각각의 소켓 인터페이스를 통해 TCP로 접속한다.</p>
</li>
<li data-line="6" dir="auto">
<p dir="auto">클라이언트는 <code>HTTP 요청 메시지</code>를 소켓 인터페이스로 보내고, 소켓 인터페이스로부터 <code>HTTP 응답 메시지</code>를 받는다.<br>
마찬가지로, HTTP 서버는 소켓 인터페이스로부터 요청 메시지를 받고 응답 메시지를 소켓 인터페이스로 보낸다.</p>
</li>
</ol></div><div><br></div><div><p dir="auto">이렇게 TCP를 통해 메시지를 보내면 <strong>TCP는 신뢰적인 데이터 전송 서비스를 제공하므로</strong><br>
<strong>모든 HTTP 요청 메시지가 궁극적으로 서버에 도착한다.</strong> (서버에서 보낸 메시지도 마찬가지다.)</p></div><div><p dir="auto">HTTP는 TCP가 어떻게 손실 데이터를 복구하고, 올바른 순서로 데이터를 배열하는지 <strong>전혀 걱정할 필요가 없어</strong> 계층 구조의 장점이 드러난다.</p></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="비상태(stateless) 프로토콜" dir="auto" class="heading" id="비상태(stateless)_프로토콜"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>비상태(stateless) 프로토콜</h2><div class="heading-children"><div><p dir="auto">특정 클라이언트가 몇 초 후에 같은 객체를 두 번 요청해도 서버는 전에 보냈다고 알려주지 않고 객체를 또 보낸다.</p></div><div><p dir="auto">HTTP 서버는 클라이언트에 대한 정보를 유지하지 않으므로, <code>비상태(stateless) 프로토콜</code>이라고 부른다.</p></div><div><br>
<br>
<br></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="2.2.2 비지속 연결과 지속 연결" dir="auto" class="heading" id="2.2.2_비지속_연결과_지속_연결">2.2.2 비지속 연결과 지속 연결</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="비지속(non-persistent) 연결" dir="auto" class="heading" id="비지속(non-persistent)_연결"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>비지속(non-persistent) 연결</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 클라이언트-서버 상호작용이 TCP 상에서 발생할 때 <strong>각 요구/응답 쌍이 분리된 TCP 연결</strong>을 통해 보내지는 것을 말한다.</p>
</blockquote></div><div><br></div><div><p dir="auto">웹 페이지를 서버에서 클라이언트로 전송하는 단계를 살펴보자.</p></div><div><p dir="auto">페이지가 <strong>기본 HTML 파일과 10개의 이미지</strong>로 구성되고, 이 11개의 객체가 같은 서버에 있다고 가정하자.</p></div><div><br></div><div><p dir="auto">연결 수행 과정은 다음과 같다.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">HTTP 클라이언트는 <code>HTTP 기본 포트 80</code>을 통해 서버로 <code>TCP 연결</code>을 시도한다. TCP 연결과 관련하여 클라이언트와 서버에 각각 소켓이 있게 된다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">HTTP 클라이언트는 설정된 TCP 연결 소켓을 통해 서버로 HTTP 요청 메시지를 보낸다. 이 요청에 객체 경로도 포함된다.</p>
</li>
<li data-line="6" dir="auto">
<p dir="auto">HTTP 서버는 TCP 연결 소켓을 통해 요청 메시지를 받는다. 저장 장치로부터 경로의 객체를 추출한다.<br>
HTTP 응답 메시지에 그 객체를 캡슐화 하여 소켓을 통해 클라이언트로 보낸다.</p>
</li>
<li data-line="10" dir="auto">
<p dir="auto">HTTP 서버는 TCP에게 연결을 끊으라고 한다. (그러나 실제로 클라이언트가 응답 메시지를 올바로 받을 때까지 끊지 않는다.)</p>
</li>
<li data-line="13" dir="auto">
<p dir="auto">HTTP 클라이언트가 응답 메시지를 받으면, TCP 연결이 중단된다. 메시지는 캡슐화된 객체가 HTML 파일인 것을 나타낸다.<br>
클라이언트는 응답 메시지로부터 파일을 추출하고 HTML 파일을 조사하여 10개의 JPEG 객체에 대한 참조를 찾는다.</p>
</li>
<li data-line="17" dir="auto">
<p dir="auto"><strong>참조되는 JPEG 객체에 대해 1 ~ 4단계를 반복한다.</strong></p>
</li>
</ol></div><div><br></div><div><p dir="auto">브라우저는 웹 페이지를 수신하면서, 사용자에게 그 페이지를 보여준다. 다른 브라우저는 웹 페이지를 각기 다른 방식으로 해석하여 보여준다.</p></div><div><blockquote dir="auto">
<p dir="auto">HTTP는 통신 프로토콜만 정의할 뿐, 웹 페이지에 대한 관심은 없다.</p>
</blockquote></div><div><br></div><div><p dir="auto">사용자는 앞의 단계를 동시에 받을지 순차적으로 받을지의 동시성 정도를 조절할 수 있도록 브라우저를 구성할 수 있다.</p></div><div><p dir="auto">브라우저는 <strong>여러 개의 TCP 연결을 설정하며 다중 연결상에서 웹 페이지의 각기 다른 원하는 부분을 요청</strong>할 수 있다.</p></div><div><p dir="auto">HTTP 1.0은 비지속 연결을 지원한다.</p></div><div><br>
<br></div><div><p dir="auto">클라이언트가 HTML 파일을 요청하고 그 파일이 클라이언트로 수신될 때까지의 시간을 측정해보자.</p></div><div><p dir="auto">이를 위해 RTT를 알아야 하는데,<br>
<code>RTT(round-trip-time)</code>란 <strong>작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간</strong>이다.</p></div><div><p dir="auto">RTT는 패킷 전파 지연, 큐잉 지연, 처리 지연 등을 포함한다. (1장에 논의되어 있다.)</p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/76640167/210491569-3638ca03-2d17-4eea-8a5f-d984bb831d00.png" alt="HTML 요청 시간 계산" referrerpolicy="no-referrer" style="width: 600px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">사용자가 하이퍼링크를 클릭하면, 브라우저와 웹 서버 사이에서 TCP 연결을 시도한다. 이는 <code>3-way handshake</code>를 포함한다.</p></div><div><blockquote dir="auto">
<p dir="auto">즉, 클라이언트가 서버로 작은 TCP 메시지를 보내고, 서버는 작은 메시지로 응답하고, 마지막으로 클라이언트가 다시 서버에 응답한다.</p>
</blockquote></div><div><br></div><div><p dir="auto">서버가 작은 메시지로 응답하면 한 RTT가 계산된다. 이때, <strong>클라이언트는 HTTP 요청 메시지를 TCP 연결로 보내면서 세 번째 응답 부분을 함께 보낸다.</strong></p></div><div><p dir="auto">일단, 요청 메시지가 도착하면 서버는 HTML 파일을 TCP 연결로 보내고 이 요청은 또 하나의 RTT를 필요로 한다.</p></div><div><blockquote dir="auto">
<p dir="auto">즉, 대략 총 응답 시간은 2RTT와 HTML 파일을 서버가 전송하는 데 걸리는 시간을 더한 것이다.</p>
</blockquote></div><div><br>
<br></div><div class="heading-wrapper"><h3 data-heading="비지속 연결의 단점" dir="auto" class="heading" id="비지속_연결의_단점"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>비지속 연결의 단점</h3><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><strong>각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다.</strong></p>
<ul dir="auto">
<li data-line="1" dir="auto">TCP 버퍼가 할당되어야 하고, TCP 변수들이 클라이언트와 서버 양쪽에 유지되어야 하는데<br>
이는 수많은 클라이언트들의 요청을 동시에 서비스하는 웹 서버에는 심각한 부담이다.</li>
</ul>
</li>
<li data-line="5" dir="auto">
<p dir="auto">매번 2RTT를 필요로 한다.</p>
</li>
</ol></div><div><br>
<br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="지속(persistent) 연결" dir="auto" class="heading" id="지속(persistent)_연결"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>지속(persistent) 연결</h2><div class="heading-children"><div><p dir="auto">HTTP/1.1 지속 연결에서 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지한다. (비지속 연결도 지원한다.)</p></div><div><p dir="auto"><strong>같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내진다.</strong></p></div><div><p dir="auto">즉, 같은 서버에 있는 여러 웹 페이지들을 하나의 지속 TCP 연결을 통해 보낼 수 있다.</p></div><div><br></div><div><p dir="auto">이들 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들 수 있다. (파이프라이닝, pipelining)</p></div><div><p dir="auto">일반적으로 HTTP 서버는 일정 기간 사용되지 않으면 연결을 닫는다.</p></div><div><p dir="auto">HTTP의 디폴트 모드는 파이프라이닝을 이용한 지속 연결을 사용한다.</p></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="HTTP 메시지 포맷" dir="auto" class="heading" id="HTTP_메시지_포맷"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>HTTP 메시지 포맷</h2><div class="heading-children"><div><p dir="auto">RFC는 HTTP 메시지 포맷을 정의한다.</p></div><div class="heading-wrapper"><h3 data-heading="HTTP 요청 메시지" dir="auto" class="heading" id="HTTP_요청_메시지"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>HTTP 요청 메시지</h3><div class="heading-children"><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/76640167/210494014-891426d1-0c27-47dc-8271-c6f5bab316e9.png" alt="요청 메시지 포맷" referrerpolicy="no-referrer" style="width: 600px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">다음은 전형적인 HTTP 요청 메시지이다.</p></div><div><pre dir="auto"><code>GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
</code><button class="copy-code-button">복사</button></pre></div><div><br></div><div class="heading-wrapper"><h4 data-heading="특징" dir="auto" class="heading" id="특징"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>특징</h4><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto">ASCII 텍스트로 쓰여 있어 사람들이 읽을 수 있다.</li>
<li data-line="1" dir="auto">메시지가 다섯 줄로 되어 있고, <strong>각 줄은 CR(carriage return)과 LF(line feed)로 구별된다.</strong> 마지막 줄에 이어서 CR과 LF가 따른다.</li>
</ol></div><div><p dir="auto">HTTP 요청 메시지의 첫 줄은 <code>요청 라인</code>이라 부르고, 이후의 줄들은 <code>헤더 라인</code>이라고 부른다.</p></div><div><br></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="요청 라인" dir="auto" class="heading" id="요청_라인"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>요청 라인</h3><div class="heading-children"><div><p dir="auto">요청 라인은 3개의 필드, 즉 <code>방식(method)</code> 필드, <code>URL 필드</code>, <code>HTTP 버전 필드</code>를 갖는다.</p></div><div><p dir="auto">방식 필드는 <code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code> 등의 여러 가지 값을 가질 수 있다.</p></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h3 data-heading="헤더 라인" dir="auto" class="heading" id="헤더_라인"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>헤더 라인</h3><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Host
<ul dir="auto">
<li data-line="1" dir="auto">객체가 존재하는 호스트를 명시한다.</li>
<li data-line="2" dir="auto">이미 호스트까지 TCP 연결이 맺어져 있어 불필요하다고 생각될 수 있지만, 2.2.5절에서 나오는 웹 프록시 캐시에서 필요로 한다.</li>
</ul>
</li>
<li data-line="3" dir="auto">Connection : 이 헤더 라인을 포함함으로써, 브라우저는 서버에게 지속 연결 사용을 원하는지 비지속 연결 사용을 원하는지 전달한다.</li>
<li data-line="4" dir="auto">User-agent : 서버에게 요청을 하는 브라우저 타입을 명시한다.</li>
<li data-line="5" dir="auto">Accept-language : 헤더는 사용자가 객체의 어떤 언어 버전을 원하고 있음을 나타낸다.</li>
</ol></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="개체 몸체(entity body)" dir="auto" class="heading" id="개체_몸체(entity_body)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>개체 몸체(entity body)</h2><div class="heading-children"><div><p dir="auto">GET일 때는 비어있고, <code>POST</code>일 때 사용된다.</p></div><div><p dir="auto">POST 메시지로 사용자는 서버에 웹 페이지를 요청하고 있으나, 웹 페이지의 특정 내용은 사용자가 폼 필드에 무엇을 입력하는가에 달려 있다.</p></div><div><p dir="auto">폼으로 생성한 요구가 반드시 POST일 필요는 없다. 대신에 흔히 요청된 URL의 입력 데이터를 전송한다.</p></div><div><br></div><div><p dir="auto"><code>HEAD</code> 방식은 GET과 유사하다.</p></div><div><p dir="auto"><strong>서버가 HEAD 방식을 가진 요청을 받으면 HTTP 메시지로 응답하는데, 요청 객체는 보내지 않는다.</strong> 흔히 디버깅을 위해 사용된다.</p></div><div><br></div><div><p dir="auto"><code>PUT</code> 방식은 웹 서버에 업로드할 객체를 필요로 하는 애플리케이션에 의해 사용된다.</p></div><div><p dir="auto"><code>DELETE</code> 방식은 사용자 또는 애플리케이션이 웹 서버에 있는 객체를 지우는 것을 허용한다.</p></div><div><br>
<br></div><div><hr dir="auto"></div><div><br></div><div class="heading-wrapper"><h3 data-heading="HTTP 응답 메시지" dir="auto" class="heading" id="HTTP_응답_메시지"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>HTTP 응답 메시지</h3><div class="heading-children"><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/76640167/210497215-8265b94b-c82f-4ea8-9374-5f41fc6eaed1.png" alt="응답 메시지" referrerpolicy="no-referrer" style="width: 600px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">다음은 전형적인 HTTP 응답 메시지를 보여준다.</p></div><div><pre dir="auto"><code>HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
(data data data data data ...)
</code><button class="copy-code-button">복사</button></pre></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="상태 라인과 상태 코드" dir="auto" class="heading" id="상태_라인과_상태_코드"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>상태 라인과 상태 코드</h3><div class="heading-children"><div><p dir="auto"><code>상태 라인(status line)</code>은 버전 필드와 상태 코드, 해당 상태 메시지를 갖는다.</p></div><div><p dir="auto">상태 코드와 메시지</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">200 OK: 요청이 성공했고, 정보가 응답으로 보내졌다.</li>
<li data-line="1" dir="auto">301 Moved Permanently: 요청 객체가 영원히 이동되었다. 이때, 새로운 URL은 응답 메시지의 Location 헤더에 나와있다.</li>
<li data-line="2" dir="auto">400 Bad Request : 서버가 요청을 이해할 수 없다.</li>
<li data-line="3" dir="auto">404 Not Found : 요청한 문서가 서버에 존재하지 않는다.</li>
<li data-line="4" dir="auto">505 HTTP Version Not Supported : 요청 HTTP 프로토콜 버전을 서버가 지원하지 않는다.</li>
</ul></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="헤더 라인" dir="auto" class="heading" id="헤더_라인"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>헤더 라인</h3><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto">Connection : 클라이언트에게 메시지를 보낸 후 TCP 연결을 닫을지 말지 결정한다.</li>
<li data-line="1" dir="auto">Date : HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간을 나타낸다.</li>
<li data-line="2" dir="auto">Server : 메시지가 어떤 웹 서버에 의해 만들어졌는지 나타낸다.</li>
<li data-line="3" dir="auto">Last-Modified : 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 나타낸다.</li>
<li data-line="4" dir="auto">Content-Length : 송신되는 객체의 바이트 수를 나타낸다.</li>
<li data-line="5" dir="auto">Content-Type : 개체 몸체 내부(Entity body)의 객체가 어떤 타입인지 나타낸다.</li>
</ol></div><div><br></div><div><p dir="auto">HTTP 명세서는 많은 헤더라인을 정의하고 있고, 위는 그 중 일부다.</p></div><div><p dir="auto">브라우저는 브라우저 타입과 여러 설정, 캐싱하고 있는지에 따라 헤더 라인을 동적으로 생성하고 웹 서버도 비슷하다.</p></div><div><br>
<br>
<br></div></div></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="2.2.4 사용자와 서버 간의 상호 작용: 쿠키(cookie)" dir="auto" class="heading" id="2.2.4_사용자와_서버_간의_상호_작용:_쿠키(cookie)">2.2.4 사용자와 서버 간의 상호 작용: 쿠키(cookie)</h1><div class="heading-children"><div><p dir="auto">HTTP 서버는 상태를 유지하지 않는다.</p></div><div><p dir="auto">그러나 서버가 사용자 접속을 제한하거나 사용자에 따라 콘텐츠를 제공하기 원하므로<br>
<strong>사용자를 확인하는 것이 바람직할 때가 있는데, 이때 HTTP는 <code>쿠키(cookie)</code>를 사용한다.</strong></p></div><div><blockquote dir="auto">
<p dir="auto">over stateless HTTP, <code>cookie</code> provides a <strong>state related service layer</strong></p>
</blockquote></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/76640167/210499304-190c6dc5-ab64-4864-9f25-bb27fc63f460.png" alt="쿠키를 이용한 상태 유지" referrerpolicy="no-referrer" style="width: 700px; max-width: 100%;"></p></div><div><br>
<br></div><div class="heading-wrapper"><h2 data-heading="쿠키 동작 과정" dir="auto" class="heading" id="쿠키_동작_과정"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>쿠키 동작 과정</h2><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto">웹 서버에 HTTP 요청 메시지를 전달한다.</li>
<li data-line="1" dir="auto">웹 서버는 유일한 식별 번호를 만들고 이 식별 번호로 인덱싱 되는 백엔드 데이터 베이스 안에 엔트리를 만든다.</li>
<li data-line="2" dir="auto"><strong>HTTP 응답 메시지에</strong> <code>Set-cookie: 식별 번호</code>의 헤더를 포함해서 전달한다.</li>
<li data-line="3" dir="auto">브라우저는 헤더를 보고, 관리하는 특정한 쿠키 파일에 그 라인을 덧붙인다.</li>
<li data-line="4" dir="auto">다시 <strong>동일 웹 서버에 요청을 보낼 때</strong><br>
브라우저는 쿠키 파일을 참조하고 이 사이트에 대한 식별번호를 발췌하여 <code>Cookie : 식별 번호</code>의 헤더를 요청과 함께 보낸다.</li>
</ol></div><div><p dir="auto">이렇게 웹 서버는 사용자를 식별할 수 있다.</p></div><div><br>
<br>
<br></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="2.2.5 웹 캐싱" dir="auto" class="heading" id="2.2.5_웹_캐싱">2.2.5 웹 캐싱</h1><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto"><code>웹 캐시(cache)</code>(<code>프록시(proxy) 서버</code>)는 기점 웹 서버를 대신하여 HTTP 요구를 충족시키는 개체이다.</p>
</blockquote></div><div><blockquote dir="auto">
<p dir="auto">Goal: satisfy client request <strong>without involving origin server</strong></p>
</blockquote></div><div><p dir="auto">웹 캐시는 자체의 저장 디스크를 갖고 있어, <strong>최근 호출된 객체의 사본을 저장 및 보존한다.</strong></p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/76640167/210502046-6dbbe817-240d-401d-8ec6-f3a73210e48d.png" alt="웹 캐싱" referrerpolicy="no-referrer" style="width: 450px; max-width: 100%;"></p></div><div><br>
<br></div><div class="heading-wrapper"><h2 data-heading="프록시 서버 동작 과정" dir="auto" class="heading" id="프록시_서버_동작_과정"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>프록시 서버 동작 과정</h2><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto">브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다.</li>
<li data-line="1" dir="auto">웹 캐시는 객체의 사본이 저장되어 있는지 확인하고, <strong>저장되어 있다면 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다.</strong></li>
<li data-line="2" dir="auto"><strong>갖고 있지 않다면, 기점 서버로 TCP 연결을 설정한다.</strong><br>
이후 웹 캐시는 캐시와 서버 간의 TCP 연결로 객체에 대한 HTTP 요청을 보낸다. 기점 서버는 웹 캐시로 HTTP 응답 메시지를 보낸다.</li>
<li data-line="4" dir="auto">웹 캐시의 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지를 보낸다. (이때, 이미 설정된 TCP를 통해 보낸다.)</li>
</ol></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">캐시(cache)는 요청과 응답을 모두 하는 클라이언트이면서 서버이다.</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto"><code>server</code> for original requesting client</li>
<li data-line="1" dir="auto"><code>client</code> to origin server</li>
</ul></div><div><br></div><div><p dir="auto">일반적으로 웹 캐시는 ISP(university, company, residential ISP)가 구입하고 설치한다.</p></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h2 data-heading="웹 캐싱의 사용 이유" dir="auto" class="heading" id="웹_캐싱의_사용_이유"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>웹 캐싱의 사용 이유</h2><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><strong>클라이언트 요구에 대한 응답 시간을 줄일 수 있다.</strong><br>
보통 클라이언트와 캐시 사이에 높은 속도의 연결이 설정되어 있어 웹서버 캐시에 객체를 갖고 있다면 병목 현상을 줄일 수 있다.</p>
</li>
<li data-line="4" dir="auto">
<p dir="auto">웹 캐시는 한 기관에서 인터넷으로의 접속하는 링크 상의 웹 트래픽을 대폭 줄일 수 있다.</p>
</li>
<li data-line="7" dir="auto">
<p dir="auto">인터넷 전체의 웹 트래픽을 실질적으로 줄여주어 모든 애플리케이션의 성능이 좋아진다.</p>
</li>
</ol></div><div><br></div><div class="heading-wrapper"><h3 data-heading="웹 캐시 미사용과 사용 성능 비교" dir="auto" class="heading" id="웹_캐시_미사용과_사용_성능_비교"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>웹 캐시 미사용과 사용 성능 비교</h3><div class="heading-children"><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/76640167/210504713-f02f053c-e503-413f-8cbc-046c55082359.png" alt="병목 현상" referrerpolicy="no-referrer" style="width: 370px; max-width: 100%;"></p></div><div><br>
<br></div><div><ul dir="auto">
<li data-line="0" dir="auto">평균 객체의 크기가 <code>1 Mb</code>이고, 기관 브라우저로부터 기점 서버에 대한 평균 요청 비율이 초당 <code>15 요청</code>이라고 가정하자.</li>
<li data-line="1" dir="auto">HTTP 메시지 요청이 무시할만큼 작으므로 네트워크 접속 회선에 어떤 트래픽도 발생시키지 않는다고 가정하자.</li>
<li data-line="2" dir="auto">또한, 접속 회선의 인터넷 부분 라우터가 <strong>HTTP 요청을 전달하고 응답을 받을 때까지 평균 소요 시간</strong>을 <code>2초</code>라고 가정하자.<br>
통상 이러한 지연을 <code>인터넷 지연</code>이라고 한다.</li>
</ul></div><div><blockquote dir="auto">
<p dir="auto">총 응답 시간 = LAN 지연 + 접속 지연 + 인터넷 지연</p>
</blockquote></div><div><br></div><div><p dir="auto">LAN의 트래픽 강도는 다음과 같다.</p></div><div><pre dir="auto"><code>(15 요청/초) X (1 Mb/요청) / 100 Mbps = 0.15
</code><button class="copy-code-button">복사</button></pre></div><div><br></div><div><p dir="auto">접속 회선(라우터와 라우터 사이)의 트래픽 강도는 다음과 같다.</p></div><div><pre dir="auto"><code>(15 요청/초) X (1 Mb/요청) / 15 Mbps = 1
</code><button class="copy-code-button">복사</button></pre></div><div><br></div><div><p dir="auto">LAN의 트래픽 강도는 많아야 수십 ms의 지연을 야기하므로 LAN 지연을 무시할 수 있지만,<br>
트래픽 강도가 1에 가까워지면 1.4절에서 논의한 것과 같이 회선의 지연은 매우 커지고 한없이 증가한다.</p></div><div><p dir="auto"><strong>접속 회선의 접속률을 100 Mbps 수준으로 늘리면 트래픽 강도를 0.15로 낮추어 해결할 수 있겠지만, 매우 많은 비용이 들어간다.</strong></p></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">웹 캐시를 사용한 예시를 보자.</p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/76640167/210506730-5cb70fea-a9ed-4817-afe0-4463bfd24a4a.png" alt="인터넷의 구성 요소" referrerpolicy="no-referrer" style="width: 370px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto"><code>캐시가 만족시킨 요청의 비율(hit rate)</code>은 일반적으로 0.2 ~ 0.7이며, 이 예시에서는 <code>0.4의 적중률</code>을 가진다고 가정하자.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">캐시와 클라이언트는 고속 LAN으로 연결되어 있어, 요청의 40%는 캐시에 의해(10ms 이내) 즉시 만족된다.</li>
<li data-line="1" dir="auto">나머지 60%의 요청은 여전히 기점 서버에 의해 만족되어야 하므로 트래픽 강도는 1.0에서 0.6으로 감소한다.</li>
</ul></div><div><p dir="auto">일반적으로 0.8 미만의 트래픽 강도는 작은 지연에 속한다. (2초에 의하면 무시할 수 있는 수준이다.)</p></div><div><br></div><div><p dir="auto">이들을 고려한 평균 지연은 다음과 같다.</p></div><div><pre dir="auto"><code>0.4 X 0.01초 + 0.6 X 2.01초 = 1.2....
</code><button class="copy-code-button">복사</button></pre></div><div><br></div><div><p dir="auto">많은 캐시가 저렴한 PC에서 실행되는 공개 소프트웨어를 사용한다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">콘텐츠 전송 네트워크(CDN)을 통해 웹 캐시는 인터넷에서 점진적으로 중요한 역할을 하고 있다.</p>
</li>
<li data-line="2" dir="auto">
<p dir="auto">CDN 회사는 인터넷 전역을 통해 많은 지역적으로 분산된 캐시를 설치하고 있으며,<br>
이를 통해 많은 트래픽을 지역화하고 있다. (전용 CDN을 사용하기도 한다.)</p>
</li>
</ul></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="조건부(conditional) GET" dir="auto" class="heading" id="조건부(conditional)_GET"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>조건부(conditional) GET</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">웹 캐싱이 사용자가 느끼는 응답 시간을 줄일 수 있지만, <strong>웹 캐시 내부에 있는 복사본이 새 것이 아닐 수 있다</strong>는 문제를 야기한다.</p>
</blockquote></div><div><p dir="auto">복사본이 클라이언트에 캐싱된 이후 웹 서버에 있는 객체가 갱신되었을 수도 있기 때문이다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 HTTP는 클라이언트가 <strong>브라우저로 전달되는 모든 객체가 최신의 것임을 확인하면서 캐싱</strong>해주는데,<br>
이러한 방식을 <code>조건부 GET(conditional GET)</code> 이라고 한다.</p>
</blockquote></div><div><blockquote dir="auto">
<p dir="auto">Goal: don't send object if cache has <strong>up-to-date cached version</strong></p>
</blockquote></div><div><p dir="auto">HTTP 요청 메시지가 (1) GET 방식을 사용하고, (2) <code>If-modified-since 헤더</code>를 포함한다면, 그것이 조건부 GET이다.</p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="조건부 GET 동작 과정" dir="auto" class="heading" id="조건부_GET_동작_과정"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>조건부 GET 동작 과정</h3><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto">브라우저의 요청을 대신해서 프록시 캐시는 요청 메시지를 웹 서버로 보낸다.</li>
</ol></div><div><pre dir="auto"><code>GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
</code><button class="copy-code-button">복사</button></pre></div><div><br></div><div><ol start="2" dir="auto">
<li data-line="0" dir="auto">웹 서버는 캐시에게 객체를 가진 응답 메시지를 보낸다.</li>
</ol></div><div><pre dir="auto"><code>HTTP/1.1 200 OK
Date: Sat, 3 Oct 2015 15:39:29
Server: Apache/1.3.0 (Unix)
Last-Modified: Wed, 9 Sep 2015 09:23:24
Content-Type: image/gif
(data data data data data ...)
</code><button class="copy-code-button">복사</button></pre></div><div><ul dir="auto">
<li data-line="0" dir="auto">캐시는 요청하는 브라우저에게 객체를 보내주고 자신에게도 객체를 저장한다.</li>
<li data-line="1" dir="auto">중요한 것은 캐시가 객체와 더불어 <strong>마지막으로 수정된 날짜를 함께 저장한다</strong>는 것이다.</li>
</ul></div><div><br></div><div><ol start="3" dir="auto">
<li data-line="0" dir="auto">일주일 후에 다른 브라우저가 같은 객체를 캐시에게 요청하면 캐시에 저장되어 있다.<br>
이 객체는 지난주에 웹 서버에서 수정되었으므로, 브라우저는 <code>조건부 GET</code>으로 조사를 수행한다.</li>
</ol></div><div><pre dir="auto"><code>GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
If-modified-since: Wed, 9 Sep 2015 09:23:24
</code><button class="copy-code-button">복사</button></pre></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><code>If-modified-since</code> 값이 일주일 전에 서버가 보낸 Last-Modified 값과 완벽히 일치한다.</p>
</li>
<li data-line="2" dir="auto">
<p dir="auto">이 조건부 GET은 서버에게 <strong>If-modified-since에 명시된 값 이후 수정된 경우에만 그 객체를 보내라고 한다.</strong></p>
</li>
</ul></div><div><br></div><div><ol start="4" dir="auto">
<li data-line="0" dir="auto">변경되지 않았다면,</li>
</ol></div><div><pre dir="auto"><code>HTTP/1.1 304 Not Modified
Date: Sat, 10 Oct 2015 15:39:29
Server: Apache/1.3.0 (Unix)
(empty entity body)
</code><button class="copy-code-button">복사</button></pre></div><div><ul dir="auto">
<li data-line="0" dir="auto">위와 같은 응답을 보낸다.<br>
데이터가 변화가 없어도 객체를 보내는 것은 대역폭을 낭비하는 것이고, 특히 그 개체가 크다면 사용자가 느끼는 응답 시간이 증가된다.</li>
<li data-line="2" dir="auto">위 응답 메시지는 클라이언트에게 요청 객체의 캐싱된 복사본을 사용하라는 것을 의미한다.</li>
</ul></div><div><br>
<br>
<br></div></div></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="2.2.6 HTTP/2" dir="auto" class="heading" id="2.2.6_HTTP/2">2.2.6 HTTP/2</h1><div class="heading-children"><div><p dir="auto">2020년 현재 주요 웹 사이트 천만 개의 40%가 <code>HTTP/2</code>를 지원하고 있다.</p></div><div><p dir="auto">HTTP/2의 주요 목표는 하나의 TCP 연결상에서 멀티플렉싱 요청/응답 지연 시간을 줄이는 데 있으며,<br>
요청 우선순위화, 서버 푸시, HTTP 헤더 필드의 효율적인 압축 기능 등을 제공한다.</p></div><div><p dir="auto">HTTP/2는 클라이언트와 서버 간의 데이터 포맷 방법과 전송 방법을 변경했다.</p></div><div><br>
<br></div><div class="heading-wrapper"><h2 data-heading="기존의 HTTP/1.1" dir="auto" class="heading" id="기존의_HTTP/1.1"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>기존의 HTTP/1.1</h2><div class="heading-children"><div><p dir="auto">지속적인 연결을 사용할 때 <strong>웹 페이지당 오직 하나의 TCP 연결</strong>을 가짐으로써,<br>
아래 설명하듯이 서버에서의 소켓 수를 줄이며 전송되는 각 웹 페이지는 공정한 네트워크 대역폭을 가질 수 있다.</p></div><div><p dir="auto">그러나 하나의 TCP 상에서 모든 웹페이지를 보내면 <code>HOL(Head of Line) 블로킹 문제</code>가 발생할 수 있다.</p></div><div><p dir="auto"><br><br></p></div><div class="heading-wrapper"><h3 data-heading="HOL 블로킹 문제" dir="auto" class="heading" id="HOL_블로킹_문제"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>HOL 블로킹 문제</h3><div class="heading-children"><div><p dir="auto">비디오 아래 수많은 작은 객체들을 포함할 때 서버와 클라이언트 사이에 저속에서 중간 속도의 <strong>병목 링크</strong>가 있다고 하자.</p></div><div><p dir="auto">비디오 클립은 병목 링크를 통과하는데 오래 걸리는 반면, <strong>작은 객체들은 비디오 클립 뒤에서 기다림이 길어진다.</strong></p></div><div><p dir="auto">즉, 비디오 클립이 객체들을 블로킹하게 된다.</p></div><div><br></div><div><p dir="auto">HTTP/1.1에서는 <strong>여러 개의 병렬 TCP 연결</strong>을 열어서 위 문제를 해결해왔다.</p></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h3 data-heading="TCP 혼잡 제어" dir="auto" class="heading" id="TCP_혼잡_제어"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP 혼잡 제어</h3><div class="heading-children"><div><p dir="auto">TCP 혼잡 제어는 각 TCP 연결이 공정하게 병목 링크를 공유하여 <strong>같은 크기의 가용한 대역폭을 공평하게 나누게 해준다.</strong></p></div><div><p dir="auto">만일 n개의 TCP 연결이 병목 링크에서 작동하고 있다면, 각 연결은 대략 대역폭의 1/n 씩을 사용하게 된다.</p></div><div><br></div><div><p dir="auto">하나의 웹 페이지를 전송하기 위해 여러 개의 병렬 TCP 연결을 열게 함으로써 브라우저는 일종의 속임수로 링크 대역폭의 많은 부분을 받게 된다.</p></div><div><p dir="auto">많은 HTTP/1.1 브라우저들은 6개까지 병렬 TCP 연결을 열고 HOL을 막을 뿐만 아니라 더 많은 대역폭을 사용할 수 있게 한다.</p></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="HTTP/2 프레이밍(framing)" dir="auto" class="heading" id="HTTP/2_프레이밍(framing)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>HTTP/2 프레이밍(framing)</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">HTTP/2의 주요 목표 중 하나는 하나의 웹 페이지를 전송하기 위한 병렬 TCP 연결의 수를 줄이거나 제거하는 데 있다.</p>
</blockquote></div><div><p dir="auto">이는 서버에서 열고 유지되는 데 필요한 소켓의 수를 줄일 뿐만 아니라 목표한 대로 TCP 혼잡 제어를 제어할 수 있게 하는 데 있다.</p></div><div><p dir="auto">그러나 웹 페이지를 전송하기 위해 오직 하나의 TCP 연결만을 사용하게 될 경우에 HTTP/2는 HOL 블로킹을 피하기 위해 신중하게 구현된 메커니즘이 필요하다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 <code>HTTP/2 프레이밍(framing)</code>이란, HTTP 메시지를 독립된 프레임들로 쪼개고, 인터리빙(interleaving)하고, 반대편 사이트에서 재조립하는 것이다.</p>
</blockquote></div><div><p dir="auto">예를 들어, 비디오 클립과 크기가 작은 객체 8개의 요청이 들어오면, 서버는 9개의 객체를 보내기 위한 TCP 병렬 요청을 받게된다.</p></div><div><p dir="auto">이때 (1) 비디오 클립을 1000개의 프레임으로 나누고 (2) 각 객체를 2개의 프레임으로 나누어 비디오 클립으로부터 하나의 프레임을 전송한다.</p></div><div><p dir="auto">이후 프레임 인터리빙을 이용하여 각 소형 객체의 첫 번째 프레임을 보내고 이를 반복하여 HOL 블로킹을 피할 수 있다.</p></div><div><br>
<br></div><div><p dir="auto"><strong>HTTP 메시지를 독립된 프레임들로 쪼개고 인터리빙하고 반대편 사이트에서 재조립하는 것이야말로 HTTP/2의 가장 중요한 개선점이다.</strong></p></div><div><p dir="auto">프레이밍은 HTTP/2 프로토콜의 프레임으로 구현된 다른 프레이밍 서브 계층에 의해 이루어진다.</p></div><div><p dir="auto">서버가 HTTP 응답을 보내고자 할 때, 응답은 프레이밍 서브 계층에 의해 처리되며 프레임들로 나눠진다.</p></div><div><p dir="auto">응답의 헤더필드는 하나의 프레임이 되고, 메시지 본문은 하나의 프레임으로 쪼개진다.</p></div><div><p dir="auto">응답 프레임들은 서버의 프레이밍 서브 계층에 의해 인터리빙된 후 하나의 지속적인 TCP 연결상에서 전송된다.</p></div><div><p dir="auto">프레임들이 클라이언트에 도착하면 프레이밍 서브 계층에서 처음 응답메시지로 재조립되며 브라우저에 의해 처리된다. (클라이언트에서 서버로 요청할 때도 마찬가지이다.)</p></div><div><br></div><div><p dir="auto">각 HTTP 메시지를 독립적인 프레임으로 쪼개는 것 외에도 프레이밍 서브 계층은 프레임을 바이너리 인코딩한다.</p></div><div><p dir="auto">바이너리 프로토콜은 파싱하기에 효율적이고, 더 작은 프레임 크기를 갖고, 에러에 강하다.</p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="메시지 우선순위화" dir="auto" class="heading" id="메시지_우선순위화"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>메시지 우선순위화</h3><div class="heading-children"><div><p dir="auto"><code>메시지 우선순위화</code>는 개발자들로 하여금 요청들의 상대적 우선 순위를 조정할 수 있게 함으로써 애플리케이션의 성능을 최적화할 수 있게 해준다.</p></div><div><br></div><div><p dir="auto">클라이언트가 하나의 특정 서버로 동시에 여러 개의 요청을 할 때, 각 메시지에 1에서 256 사이의 가중치를 부여함으로써 요청에 우선순위를 매길 수 있다.</p></div><div><blockquote dir="auto">
<p dir="auto">높은 수치일수록 높은 우선순위를 갖는다.</p>
</blockquote></div><div><p dir="auto">서버는 가장 높은 우선순위의 요청을 위한 프레임을 제일 먼저 보낼 수 있다.</p></div><div><br></div><div><p dir="auto">클라이언트 또한 각 의존도에 따라 메시지의 ID를 지정하여 서로 다른 메시지들 간의 의존성을 나타낼 수 있다.</p></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="서버 푸싱" dir="auto" class="heading" id="서버_푸싱"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>서버 푸싱</h3><div class="heading-children"><div><p dir="auto">HTTP/2의 또 다른 특징은 서버로 하여금 <strong>특정 클라이언트 요청에 대해 여러 개의 응답을 보낼 수 있게 해주는 데 있다.</strong></p></div><div><p dir="auto">처음 요청에 대한 응답 외에도, 서버는 클라이언트의 요청 없이도 추가적인 객체를 클라이언트에게 <strong>푸시</strong>하여 보낼 수 있다.</p></div><div><p dir="auto">이는 HTML 기반 페이지가 웹 페이지를 완벽하게 구동시킬 필요가 있는 객체들을 가리킬 수 있기에 가능하다.</p></div><div><p dir="auto">이러한 객체에 대한 HTTP 요청을 기다리는 대신 서버는 HTML을 분석할 수 있고, 필요한 객체들을 식별할 수 있고,<br>
<strong>해당 객체들에 대한 요청이 도착하기도 전에</strong> 해당 객체들을 클라이언트로 보낸다.</p></div><div><p dir="auto">서버는 해당 요청들을 기다리는 데 소요되는 추가 지연을 없앤다.</p></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="HTTP/3" dir="auto" class="heading" id="HTTP/3"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>HTTP/3</h2><div class="heading-children"><div><p dir="auto">트랜스 프로토콜인 QUIC(3장에서 다룬다) 위에서 작동하도록 설계된 새로운 HTTP 프로토콜로서, 완전히 표준화된 상태는 아니다.</p></div><div class="mod-footer"></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#2.2 웹과 HTTP"><div class="tree-item-contents heading-link" heading-name="2.2 웹과 HTTP"><span class="tree-item-title">2.2 웹과 HTTP</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#2.2.1_HTTP_개요"><div class="tree-item-contents heading-link" heading-name="2.2.1 HTTP 개요"><span class="tree-item-title">2.2.1 HTTP 개요</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#웹_페이지(web_page)"><div class="tree-item-contents heading-link" heading-name="웹 페이지(web page)"><span class="tree-item-title">웹 페이지(web page)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#웹_브라우저와_클라이언트"><div class="tree-item-contents heading-link" heading-name="웹 브라우저와 클라이언트"><span class="tree-item-title">웹 브라우저와 클라이언트</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#HTTP와_TCP"><div class="tree-item-contents heading-link" heading-name="HTTP와 TCP"><span class="tree-item-title">HTTP와 TCP</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#비상태(stateless)_프로토콜"><div class="tree-item-contents heading-link" heading-name="비상태(stateless) 프로토콜"><span class="tree-item-title">비상태(stateless) 프로토콜</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#2.2.2_비지속_연결과_지속_연결"><div class="tree-item-contents heading-link" heading-name="2.2.2 비지속 연결과 지속 연결"><span class="tree-item-title">2.2.2 비지속 연결과 지속 연결</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#비지속(non-persistent)_연결"><div class="tree-item-contents heading-link" heading-name="비지속(non-persistent) 연결"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">비지속(non-persistent) 연결</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#비지속_연결의_단점"><div class="tree-item-contents heading-link" heading-name="비지속 연결의 단점"><span class="tree-item-title">비지속 연결의 단점</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#지속(persistent)_연결"><div class="tree-item-contents heading-link" heading-name="지속(persistent) 연결"><span class="tree-item-title">지속(persistent) 연결</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#HTTP_메시지_포맷"><div class="tree-item-contents heading-link" heading-name="HTTP 메시지 포맷"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">HTTP 메시지 포맷</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#HTTP_요청_메시지"><div class="tree-item-contents heading-link" heading-name="HTTP 요청 메시지"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">HTTP 요청 메시지</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#특징"><div class="tree-item-contents heading-link" heading-name="특징"><span class="tree-item-title">특징</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#요청_라인"><div class="tree-item-contents heading-link" heading-name="요청 라인"><span class="tree-item-title">요청 라인</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#헤더_라인"><div class="tree-item-contents heading-link" heading-name="헤더 라인"><span class="tree-item-title">헤더 라인</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#개체_몸체(entity_body)"><div class="tree-item-contents heading-link" heading-name="개체 몸체(entity body)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">개체 몸체(entity body)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#HTTP_응답_메시지"><div class="tree-item-contents heading-link" heading-name="HTTP 응답 메시지"><span class="tree-item-title">HTTP 응답 메시지</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#상태_라인과_상태_코드"><div class="tree-item-contents heading-link" heading-name="상태 라인과 상태 코드"><span class="tree-item-title">상태 라인과 상태 코드</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#헤더_라인"><div class="tree-item-contents heading-link" heading-name="헤더 라인"><span class="tree-item-title">헤더 라인</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#2.2.4_사용자와_서버_간의_상호_작용:_쿠키(cookie)"><div class="tree-item-contents heading-link" heading-name="2.2.4 사용자와 서버 간의 상호 작용: 쿠키(cookie)"><span class="tree-item-title">2.2.4 사용자와 서버 간의 상호 작용: 쿠키(cookie)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#쿠키_동작_과정"><div class="tree-item-contents heading-link" heading-name="쿠키 동작 과정"><span class="tree-item-title">쿠키 동작 과정</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#2.2.5_웹_캐싱"><div class="tree-item-contents heading-link" heading-name="2.2.5 웹 캐싱"><span class="tree-item-title">2.2.5 웹 캐싱</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#프록시_서버_동작_과정"><div class="tree-item-contents heading-link" heading-name="프록시 서버 동작 과정"><span class="tree-item-title">프록시 서버 동작 과정</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#웹_캐싱의_사용_이유"><div class="tree-item-contents heading-link" heading-name="웹 캐싱의 사용 이유"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">웹 캐싱의 사용 이유</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#웹_캐시_미사용과_사용_성능_비교"><div class="tree-item-contents heading-link" heading-name="웹 캐시 미사용과 사용 성능 비교"><span class="tree-item-title">웹 캐시 미사용과 사용 성능 비교</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#조건부(conditional)_GET"><div class="tree-item-contents heading-link" heading-name="조건부(conditional) GET"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">조건부(conditional) GET</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#조건부_GET_동작_과정"><div class="tree-item-contents heading-link" heading-name="조건부 GET 동작 과정"><span class="tree-item-title">조건부 GET 동작 과정</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#2.2.6_HTTP/2"><div class="tree-item-contents heading-link" heading-name="2.2.6 HTTP/2"><span class="tree-item-title">2.2.6 HTTP/2</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#기존의_HTTP/1.1"><div class="tree-item-contents heading-link" heading-name="기존의 HTTP/1.1"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">기존의 HTTP/1.1</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#HOL_블로킹_문제"><div class="tree-item-contents heading-link" heading-name="HOL 블로킹 문제"><span class="tree-item-title">HOL 블로킹 문제</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#TCP_혼잡_제어"><div class="tree-item-contents heading-link" heading-name="TCP 혼잡 제어"><span class="tree-item-title">TCP 혼잡 제어</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#HTTP/2_프레이밍(framing)"><div class="tree-item-contents heading-link" heading-name="HTTP/2 프레이밍(framing)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">HTTP/2 프레이밍(framing)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#메시지_우선순위화"><div class="tree-item-contents heading-link" heading-name="메시지 우선순위화"><span class="tree-item-title">메시지 우선순위화</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#서버_푸싱"><div class="tree-item-contents heading-link" heading-name="서버 푸싱"><span class="tree-item-title">서버 푸싱</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_2\2.2-웹과-http\readme.html#HTTP/3"><div class="tree-item-contents heading-link" heading-name="HTTP/3"><span class="tree-item-title">HTTP/3</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>