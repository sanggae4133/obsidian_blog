<!DOCTYPE html> <html><head>
		<title>README</title>
		<base href="..\..\..\..\../">
		<meta id="root-path" root-path="..\..\..\..\../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Obsidian_main - README">
		<meta property="og:title" content="README">
		<meta property="og:description" content="Obsidian_main - README">
		<meta property="og:type" content="website">
		<meta property="og:url" content="중앙대학교-수업/4-1/네트워크응용설계-요약/chapter_3/3.5-연결지향형-트랜스포트_-tcp/readme.html">
		<meta property="og:image" content="https://user-images.githubusercontent.com/86337233/211437579-b86e832e-cd39-4707-a212-9ee7c7d6869f.png">
		<meta property="og:site_name" content="Obsidian_main">
		<meta name="author" content="dustbox"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title show-ribbon mk-readable-line mk-folder-lines mk-spaces-enabled mk-inline-context-enabled mk-flow-seamless"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="3.5 연결지향형 트랜스포트: TCP"><p dir="auto">3.5 연결지향형 트랜스포트: TCP</p></h1><div class="heading-wrapper"><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="3.5.1 TCP 연결" dir="auto" class="heading" id="3.5.1_TCP_연결"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.5.1 TCP 연결</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 TCP는 애플리케이션 프로세스가 데이터를 다른 프로세스에게 보내기 전에,<br>
두 프로세스가 <strong>서로 ’핸드셰이크’를 먼저 해야 하므로</strong> <code>연결지향형(connection-oriented)</code>이다.</p>
</blockquote></div><div><p dir="auto">즉, 데이터 전송을 보장하는 파라미터들을 각자 설정하기 위한 어떤 사전 세그먼트들을 보내야 한다.</p></div><div><br></div><div><p dir="auto">TCP <code>연결</code>은 <strong>두 통신 종단 시스템의 TCP에 존재하는 상태를 공유</strong>하는 논리적인 것이다.</p></div><div><br></div><div><p dir="auto">TCP 연결은 <code>전이중 서비스(full-duplex service)</code>를 제공한다.</p></div><div><blockquote dir="auto">
<p dir="auto">만약 호스트 A의 프로세스와 호스트 B의 프로세스 사이에 TCP 연결이 있다면,<br>
<strong>애플리케이션 계층 데이터는 B에서 A로 흐르는 동시에 A에서 B로 흐를 수 있다.</strong></p>
</blockquote></div><div><br></div><div><p dir="auto">TCP 연결은 항상 단일 송신자와 단일 수신자 사이의 <code>점대점(point-to-point)</code>이다.</p></div><div><p dir="auto">따라서 단일 송신 동작으로 한 송신자가 여러 수신자에게 데이터를 전송하는 ‘<strong>멀티캐스팅(multicasting)</strong>’은 TCP에서는 불가능하다.</p></div><div><br></div></div></div><div class="heading-wrapper"><h2 data-heading="TCP 연결 과정" dir="auto" class="heading" id="TCP_연결_과정"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP 연결 과정</h2><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><code>클라이언트 프로세스(client process)</code> : 연결을 초기화하는 프로세스</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto"><code>서버 프로세스(server process)</code></p>
</li>
</ul></div><div><br></div><div class="heading-wrapper"><h3 data-heading="세 방향 핸드셰이크(three-way handshake)" dir="auto" class="heading" id="세_방향_핸드셰이크(three-way_handshake)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>세 방향 핸드셰이크(three-way handshake)</h3><div class="heading-children"><div><p dir="auto"><em>(3.5.6에서 더 자세히 다룰 예정)</em></p></div><div><br></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">클라이언트 애플리케이션 프로세스는 서버의 프로세스와 연결을 설정하기를 원한다고 <strong>TCP 클라이언트에게 먼저 알린다.</strong></p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">클라이언트의 트랜스포트 계층은 서버의 TCP와의 TCP 연결 설정을 진행한다.</p>
<blockquote dir="auto">
<p dir="auto">즉, 클라이언트가 먼저 특별한 <code>TCP 세그먼트</code>를 보낸다.</p>
</blockquote>
</li>
<li data-line="7" dir="auto">
<p dir="auto">서버는 <code>두 번째 특별한 TCP 세그먼트</code>로 응답한다.</p>
</li>
<li data-line="10" dir="auto">
<p dir="auto">마지막으로, 클라이언트가 <code>세 번째 특별한 세그먼트</code>로 다시 응답한다.</p>
</li>
</ol></div><div><br></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">처음 2개의 세그먼트에는 <code>페이로드(payload, 애플리케이션 계층 데이터)</code>가 없다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto"><strong>세 번째 세그먼트는 페이로드를 포함할 수 있다.</strong></p>
</li>
</ul></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="TCP 연결이 설정된 이후" dir="auto" class="heading" id="TCP_연결이_설정된_이후"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP 연결이 설정된 이후</h3><div class="heading-children"><div><p dir="auto">일단 TCP 연결이 설정되면, 두 애플리케이션 프로세스는 서로 데이터를 보낼 수 있다.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">클라이언트 프로세스는 <code>소켓(프로세스의 관문)</code>을 통해 <strong>데이터의 스트림을 전달한다.</strong></p>
</li>
<li data-line="3" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">데이터가 관문을 통해 전달되면, 이제 데이터는 클라이언트에서 동작하고 있는 TCP에 맡겨진다.</p>
<ol dir="auto">
<li data-line="4" dir="auto">TCP는 초기 세 방향 핸드셰이크 동안 준비된 버퍼 중의 하나인 연결의 <code>송신 버퍼(send buffer)</code>로 데이터를 보낸다.</li>
<li data-line="5" dir="auto">때때로 TCP는 송신 버퍼에서 데이터 묶음을 만들어서 네트워크로 보낸다.<br>
(TCP가 언제 버퍼된 데이터를 전송해야 하는지는 정해져 있지 않음)</li>
</ol>
</li>
</ol></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="최대 세그먼트 크기(maximum segment size, MSS)" dir="auto" class="heading" id="최대_세그먼트_크기(maximum_segment_size,_MSS)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>최대 세그먼트 크기(maximum segment size, MSS)</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">세그먼트로 모아 담을 수 있는 최대 데이터 양은 <code>최대 세그먼트 크기(maximum segment size, MSS)</code>로 제한된다.</p>
</blockquote></div><div><br></div><div><p dir="auto">MSS를 결정하는 요소</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">로컬 송신 호스트에 의해 전송될 수 있는 가장 큰 링크 계층 프레임의 길이<br>
(<code>최대 전송 단위(maximum transmission unit, MTU</code>)</p>
</li>
<li data-line="4" dir="auto">
<p dir="auto">TCP 세그먼트(IP 데이터그램 안에 캡슐화되었을 때)와 TCP/IP 헤더 길이(통상 40바이트)가 <strong>단일 링크 계층 프레임에 딱 맞도록</strong> 한다.</p>
</li>
</ul></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 MSS는 <em>헤더를 포함하는 TCP 세그먼트의 최대 크기가 아니라,</em>   <strong>세그먼트에 있는 애플리케이션 계층 데이터에 대한 최대 크기</strong>이다.</p>
</blockquote></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="TCP 세그먼트(TCP segment)" dir="auto" class="heading" id="TCP_세그먼트(TCP_segment)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP 세그먼트(TCP segment)</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">TCP 헤더 + 클라이언트 데이터</p>
</blockquote></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">네트워크 계층에 전달되어 <code>네트워크 계층 IP 데이터그램</code> <strong>안에 각각 캡슐화된다.</strong></p>
</li>
<li data-line="3" dir="auto">
<p dir="auto"><code>세그먼트</code>는 네트워크로 송신된다.</p>
</li>
<li data-line="6" dir="auto">
<p dir="auto">TCP가 상대에게서 세그먼트를 수신했을 때, 세그먼트의 데이터는 TCP 연결의 <code>수신 버퍼</code>에 위치한다.<br>
→ 애플리케이션은 이 버퍼로부터 데이터의 스트림을 읽는다.</p>
</li>
</ol></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">TCP 연결의 양 끝은 각각 자신의 <code>송신 버퍼</code>와 <code>수신 버퍼</code>를 갖고 있다.</p>
</blockquote></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211437579-b86e832e-cd39-4707-a212-9ee7c7d6869f.png" alt="TCP 송신 버퍼와 수신 버퍼" referrerpolicy="no-referrer" style="width: 600px; max-width: 100%;"></p></div><div><br>
<br></div><div><blockquote dir="auto">
<p dir="auto">💡 즉, TCP 연결은 한쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결과<br>
다른 쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결의 집합으로 이루어진다.</p>
</blockquote></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="3.5.2 TCP 세그먼트 구조" dir="auto" class="heading" id="3.5.2_TCP_세그먼트_구조"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.5.2 TCP 세그먼트 구조</h2><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="구조" dir="auto" class="heading" id="구조"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>구조</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="**헤더 필드**" dir="auto" class="heading" id="**헤더_필드**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>헤더 필드</strong></h4><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><code>출발지와 목적지 포트 번호(source and destination port number)</code></p>
</li>
<li data-line="3" dir="auto">
<p dir="auto"><code>체크섬 필드(checksum field)</code></p>
</li>
<li data-line="6" dir="auto">
<p dir="auto">32비트 <code>순서 번호 필드(sequence number field)</code></p>
</li>
<li data-line="9" dir="auto">
<p dir="auto">32비트 <code>확인응답 번호 필드(acknowledgement number field)</code></p>
</li>
<li data-line="12" dir="auto">
<p dir="auto">16비트 <code>수신 윈도(receive window)</code> : 흐름 제어에 사용된다.<br>
(수신자가 받아들이려는 바이트의 크기를 나타내는데 사용됨)</p>
</li>
<li data-line="16" dir="auto">
<p dir="auto">4비트 <code>헤더 길이 필드(header length field)</code> : 32비트 워드 단위로 TCP 헤더의 길이를 나타낸다.</p>
</li>
<li data-line="19" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>옵션 필드(option field)</code></p>
<ul dir="auto">
<li data-line="20" dir="auto">이 필드는 선택적이고 가변적인 길이를 가진다.</li>
<li data-line="21" dir="auto">송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 이용된다.</li>
</ul>
</li>
<li data-line="24" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>플래그 필드(flag field)</code> : 6비트를 포함한다.</p>
<ul dir="auto">
<li data-line="25" dir="auto"><code>ACK</code> 비트 : 확인응답 필드에 있는 값이 유용함을 가리키는 데 사용된다.</li>
<li data-line="26" dir="auto"><code>RST</code>, <code>SYN</code>, <code>FIN</code> 비트 : 연결 설정과 해제에 사용된다.</li>
<li data-line="27" dir="auto"><code>PSH</code> 비트 : 이 비트가 설정되었다면 이것은 수신자가 데이터를 상위 계층에 즉시 전달해야 함을 가리킨다.</li>
<li data-line="28" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>URG</code> 비트
<ul dir="auto">
<li data-line="29" dir="auto">이 세그먼트에서 송신 측 상위 계층 개체가 ‘긴급’으로 표시하는 데이터임을 가리킨다.</li>
<li data-line="30" dir="auto">이 긴급 데이터의 마지막 바이트의 위치는 16비트의 <code>긴급 데이터 포인터 필드(urgent data pointer field)</code>에 의해 가리켜진다.</li>
</ul>
</li>
</ul>
</li>
</ul></div><div><br></div></div></div><div class="heading-wrapper"><h4 data-heading="**데이터 필드**" dir="auto" class="heading" id="**데이터_필드**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>데이터 필드</strong></h4><div class="heading-children"><div><p dir="auto">애플리케이션 데이터의 일정량을 담는다.</p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211437603-f0cab27b-5fc5-4dd3-a7e5-b6d4a23797e7.png" alt="TCP 세그먼트 구조" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;"></p></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="MSS" dir="auto" class="heading" id="MSS"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>MSS</h3><div class="heading-children"><div><p dir="auto">MSS는 세그먼트 데이터 필드의 크기를 제한한다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">큰 파일 전송 시, 일반적으로 MSS 크기로 파일을 분절한다.</li>
<li data-line="1" dir="auto">많은 대화식 애플리케이션은 MSS보다 작은 양의 데이터를 전송한다.</li>
</ul></div><div><br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="순서 번호와 확인응답 번호" dir="auto" class="heading" id="순서_번호와_확인응답_번호"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>순서 번호와 확인응답 번호</h2><div class="heading-children"><div><p dir="auto">이 두 필드는 TCP의 신뢰적인 데이터 전송 서비스의 중대한 부분이다.</p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="순서 번호" dir="auto" class="heading" id="순서_번호"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>순서 번호</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">TCP는 <code>데이터</code>를 구조화되어 있지 않고 <strong>단지 순서대로 정렬되어 있는 바이트 스트림으로 본다.</strong></p>
</blockquote></div><div><blockquote dir="auto">
<p dir="auto"><code>세그먼트에 대한 순서 번호</code>는 <strong>세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호다.</strong></p>
</blockquote></div><div><br></div><div><p dir="auto">e.g.,</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">데이터 스트림은 500,000 바이트로 구성된 파일이라고 가정한다.</li>
<li data-line="1" dir="auto">MSS는 1,000 바이트</li>
<li data-line="2" dir="auto">데이터 스트림의 첫 번째 바이트는 0으로 설정한다.</li>
</ul></div><div><br></div><div><p dir="auto">아래 그림처럼 TCP는 데이터 스트림으로부터 500개의 세그먼트들을 구성하며, 각 세그먼트가 할당받는 순서 번호는 다음과 같다.</p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211437602-133ef178-ba22-4269-86c4-7444efd50f76.png" alt="TCP 세그먼트" referrerpolicy="no-referrer" style="width: 700px; max-width: 100%;"></p></div><div><br>
<br></div><div><blockquote dir="auto">
<p dir="auto">💡 각각의 순서 번호는 적절한 TCP 세그먼트의 헤더 내부의 <code>순서 번호 필드</code>에 삽입된다.</p>
</blockquote></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="확인응답 번호" dir="auto" class="heading" id="확인응답_번호"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>확인응답 번호</h3><div class="heading-children"><div><p dir="auto">TCP는 <strong>전이중 방식</strong>임을 상기하자.<br>
(호스트 A가 호스트 B로 데이터를 송신하는 <strong>동안에</strong> 호스트 B로부터 데이터를 수신하게 해줌)</p></div><div><br></div><div><p dir="auto">호스트 B로부터 도착한 각 세그먼트는 B로부터 A로 들어온 데이터에 대한 <code>순서 번호</code>를 갖는다.</p></div><div><blockquote dir="auto">
<p dir="auto">💡 호스트 A가 자신의 세그먼트에 삽입하는 <code>확인응답 번호</code>는 <strong>호스트 A가 호스트 B로부터 기대하는</strong> <code>다음 바이트의 순서 번호</code><strong>다.</strong></p>
</blockquote></div><div><br></div><div><p dir="auto">e.g.,<br>
호스트 A가 호스트 B로부터<br>
<code>0 ~ 535의 바이트를 포함하는 어떤 세그먼트</code>와 <code>900 ~ 1,000의 바이트를 포함하는 또 다른 세그먼트</code>를 수신했다고 가정하자.</p></div><div><p dir="auto"><em>(어떤 이유 때문인지 몰라도, 호스트 A는 그 사이 <code>536~899의 바이트</code>를 아직 수신하지 않았음)</em></p></div><div><br></div><div><p dir="auto">호스트 A는 <strong>B의 데이터 스트림을 재생성하기 위해</strong> 536번째(와 그 다음의) 바이트를 아직 기다리고 있다.</p></div><div><p dir="auto">그러므로 B에 대한 A의 다음 세그먼트이 <code>확인응답 번호 필드</code>에 536을 가질 것이다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">TCP는 스트림에서 <strong>첫 번째 잃어버린 바이트까지의 바이트들까지만 확인응답</strong>하기 때문에,<br>
TCP는 <code>누적 확인응답(cumulative acknowledgment)</code>을 제공한다고 한다.</p>
</blockquote></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">위 예에서 호스트 A는 <code>세 번째 세그먼트(900~1,000 값의 바이트)</code>를 <code>두 번째 세그먼트(536~899 값의 바이트)</code>가 수신되기 전에 수신했다.</p></div><div><p dir="auto"><em>즉, 세 번째 세그먼트는 순서가 틀리게 도착했다.</em></p></div><div><br></div><div><p dir="auto">이 상황에서 호스트는 어떻게 행동을 할까?</p></div><div><blockquote dir="auto">
<p dir="auto">TCP RFC는 TCP 연결에서 순서가 바뀐 세그먼트를 수신할 때 호스트가 어떤 행동을 취해야 하는지에 대한 어떤 규칙도 부여하지 않았고,<br>
TCP 구현 개발자에게 맡기고 있다.</p>
</blockquote></div><div><br></div><div><p dir="auto">두 가지 선택지</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">수신자가 순서가 바뀐 세그먼트를 <strong>즉시 버린다.</strong></p>
</li>
<li data-line="2" dir="auto">
<p dir="auto">수신자는 순서가 바뀐 데이터를 보유하고, <strong>빈 공간에 잃어버린 데이터를 채우기 위해 기다린다.</strong></p>
</li>
</ol></div><div><p dir="auto"><em>후자가 네트워크 대역폭 관점에서는 효율적이며, 실제에서도 취하는 방법이다.</em></p></div><div><br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="텔넷: 순서 번호와 응답확인 번호 사례연구" dir="auto" class="heading" id="텔넷:_순서_번호와_응답확인_번호_사례연구"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>텔넷: 순서 번호와 응답확인 번호 사례연구</h2><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="텔넷(Telnet)" dir="auto" class="heading" id="텔넷(Telnet)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>텔넷(Telnet)</h3><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto">원격 로그인을 위해 사용되는 유명한 애플리케이션 계층 프로토콜</li>
<li data-line="1" dir="auto">TCP 상에서 실행되며, 한 쌍의 호스트들 사이에서 동작하도록 설계되었다.</li>
</ul></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto"><strong>호스트 A가 호스트 B로</strong> 텔넷 세션을 시작한다고 가정하자.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">호스트 A가 세션을 시작하므로 <code>클라이언트</code></li>
<li data-line="1" dir="auto">호스트 B는 <code>서버</code></li>
</ul></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211437590-612a9b6b-4d54-49b3-ad1a-d0d925d64da7.png" alt="텔넷 애플리케이션" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;"></p></div><div><br>
<br></div><div><blockquote dir="auto">
<p dir="auto">💡 세그먼트의 <code>순서 번호</code> = <strong>데이터 필드 안에 있는</strong> 첫 번째 바이트의 순서 번호</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">클라이언트의 초기 순서 번호 : <code>42</code> → 클라이언트에서 송신된 첫 번째 세그먼트는 <strong>순서 번호 42</strong>를 가진다.</li>
<li data-line="1" dir="auto">서버의 초기 순서 번호 : <code>79</code> → 서버에서 송신된 첫 번째 세그먼트는 <strong>순서 번호 79</strong>를 가질 것이다.</li>
</ul></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 <code>확인응답 번호</code> = <strong>호스트가 기다리는</strong> 데이터의 다음 바이트의 순서 번호</p>
</blockquote></div><div><p dir="auto">TCP 연결이 설정된 후에 <strong>어떤 데이터도 송신되기 전,</strong></p></div><div><ul dir="auto">
<li data-line="0" dir="auto">클라이언트는 바이트 <code>79</code>를 기다리고 있다.</li>
<li data-line="1" dir="auto">서버는 바이트 <code>42</code>를 기다리고 있다.</li>
</ul></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">사용자가 하나의 문자 ‘C’를 입력하고, 커피를 마신다고 가정하자.</p></div><div><p dir="auto">위 그림처럼 <strong>3개의 세그먼트</strong>가 송신된다. = <code>세 방향 핸드셰이크(three-way handshake)</code></p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">1️⃣ 첫 번째 세그먼트</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">클라이언트에서 서버로 송신된다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto"><code>순서 번호 필드</code> 안에 <code>42</code>를 가진다.</p>
</li>
</ul></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">2️⃣ 두 번째 세그먼트</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">서버에서 클라이언트로 송신된다.</p>
</li>
<li data-line="3" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">두 가지 목적을 가진다.</p>
<ol dir="auto">
<li data-line="4" dir="auto">
<p dir="auto">수신하는 서버에게 데이터에 대한 <strong>확인응답을 제공</strong></p>
<blockquote dir="auto">
<p dir="auto"><code>확인응답 필드</code> 안에 <code>43</code>을 넣음으로써,<br>
(1) 서버는 클라이언트에게 바이트 42를 성공적으로 수신했고<br>
(2) 앞으로 바이트 43을 기다린다는 것을 말해준다.</p>
</blockquote>
</li>
<li data-line="10" dir="auto">
<p dir="auto"><strong>문자 ‘C’를 반대로 반향되도록 하는 것</strong></p>
<p dir="auto">→ 그의 데이터 필드에 ‘C’의 ASCII 표현을 한다.</p>
<blockquote dir="auto">
<p dir="auto">두 번째 세그먼트는 TCP 연결의 서버-클라이언트 데이터 흐름의 <code>최초 순서 번호인 순서 79</code>를 갖는다.<br>
(이는 서버가 보내는 데이터의 맨 첫번째 바이트)</p>
</blockquote>
</li>
</ol>
</li>
</ul></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 <code>클라이언트/서버 데이터에 대한 확인응답</code>은 서버와 클라이언트 간에서 데이터를 운반하는 <strong>세그먼트 안에서 전달된다.</strong><br>
= 확인응답은 서버-클라이언트 데이터 세그먼트 상에서 <code>피기백된다(piggybacked)</code></p>
</blockquote></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">3️⃣ 세 번째 세그먼트</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">클라이언트에서 서버로 송신된다.</p>
</li>
<li data-line="3" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">목적 : 서버로부터 수신한 데이터에 대한 확인응답을 하는 것</p>
<ul dir="auto">
<li data-line="4" dir="auto"><strong>이 세그먼트는 빈 데이터 필드를 갖는다.</strong></li>
<li data-line="5" dir="auto">즉, 확인응답은 어떤 클라이언트-서버 데이터와 함께 <strong>피기백되지 않는다.</strong></li>
</ul>
</li>
<li data-line="8" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">세그먼트는 <code>확인응답 필드</code> 안에 <code>80</code>을 갖는다.</p>
<ul dir="auto">
<li data-line="9" dir="auto">클라이언트가 <code>순서 번호 79</code>의 바이트를 통해 바이트의 스트림을 수신했기 때문이다.</li>
<li data-line="10" dir="auto">앞으로 <code>80</code>으로 시작하는 바이트를 기다린다.</li>
</ul>
</li>
</ul></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">이 세그먼트가 데이터를 포함하지 않는데도 순서 번호를 갖는다는 것이 이상하지만,<br>
<strong>TCP가 순서 번호 필드를 갖고 있으므로 세그먼트 역시 어떤 순서 번호를 가져야 한다.</strong></p>
</blockquote></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="3.5.3 왕복 시간(RTT) 예측과 타임아웃" dir="auto" class="heading" id="3.5.3_왕복_시간(RTT)_예측과_타임아웃"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.5.3 왕복 시간(RTT) 예측과 타임아웃</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 TCP는 <strong>손실 세그먼트를 발견하기 위해</strong> <code>타임아웃/재전송 매커니즘</code>을 사용한다.</p>
</blockquote></div><div><p dir="auto">타임아웃은 연결의 <code>왕복 시간(round-trip time, RTT)</code>보다 좀 커야 한다.</p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="왕복 시간 예측" dir="auto" class="heading" id="왕복_시간_예측"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>왕복 시간 예측</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 <code>왕복 시간(round-trip time, RTT)</code> : 세그먼트가 전송된 시간부터 긍정 확인응답될 때까지의 시간</p>
</blockquote></div><div><p dir="auto">TCP가 송신자와 수신자 사이에 왕복 시간을 어떻게 예측하는지에 대하여 알아보자.</p></div><div><br></div><div><p dir="auto">✅  <code>SampleRTT</code>라고 표시되는 세그먼트에 대한 RTT 샘플<br>
: 세그먼트가 <strong>송신된 시간(IP에게 넘겨진 시간)으로부터 그 세그먼트에 대한 긍정응답이 도착한 시간까지</strong>의 시간 길이</p></div><div><p dir="auto">대부분의 TCP는 <strong>한 번에 하나의</strong> <code>SampleRTT</code> <strong>측정</strong>만을 시행한다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">즉, 어떤 시점에서 <code>SampleRTT</code>는 <strong>전송되었지만 현재까지 확인응답이 없는 세그먼트 중 하나에 대해서만</strong> 측정된다.</li>
<li data-line="1" dir="auto">이는 대략 왕복 시간마다 <code>SampleRTT</code>의 새로운 값을 얻게 한다.</li>
</ul></div><div><br></div><div><p dir="auto">✅ SampleRTT 값은 라우터에서의 혼잡과 종단 시스템에서의 부하 변화 때문에 <strong>세그먼트마다 다르기 때문에</strong><br>
대체로 RTT를 추정하기 위해 <code>SampleRTT 값의 평균값</code>을 채택한다.</p></div><div><p dir="auto">→ TCP는 SampleRTT 값의 평균(<code>EstimatedRTT</code>)을 유지한다.</p></div><div><blockquote dir="auto">
<p dir="auto">EstimatedRTT = (1 - α) × EstimatedRTT + α × SampleRTT<br>
(권장되는 α의 값 : 0.125)</p>
</blockquote></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 <code>EstimatedRTT</code>는 <code>SampleRTT</code>의 <b>가중평균(weighted average)</b>이다.</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">이 가중평균은 예전 샘플보다 <strong>최근 샘플에 높은 가중치</strong>를 준다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">최신 샘플들이 네트워크상의 현재 혼잡을 더 잘 반영한다. → <code>지수적 가중 이동 평균(exponential weighted moving average, EWMA)</code></p>
</li>
</ul></div><div><br></div><div><p dir="auto">아래는 TCP 연결에 대해 <code>α = 1/8</code>의 값에 대한 <code>SampleRTT</code> 값들과 <code>EstimatedRTT</code>를 보여준다.</p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211437598-d947f320-f340-4b47-8f64-fb2fc7558e95.png" alt="RTT 샘플과 RTT 추정치" referrerpolicy="no-referrer" style="width: 600px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">✅  <code>DevRTT</code>는 <strong>RTT 변화율</strong>을 의미한다.</p></div><div><p dir="auto">이는 <code>SampleRTT</code>가 <code>EstimatedRTT</code>로부터 얼마나 많이 벗어나는지에 대한 측으로 정의한다.</p></div><div><blockquote dir="auto">
<p dir="auto">DevRTT = (1 - β) × DevRTT + β × | SampleRTT - EstimatedRTT |<br>
(권장되는 β의 값 : 0.25)</p>
</blockquote></div><div><p dir="auto"><em>DevRTT는 SampleRTT와 EstimatedRTT 값 차이의 EWMA이다.</em></p></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="재전송 타임아웃 주기의 설정과 관리" dir="auto" class="heading" id="재전송_타임아웃_주기의_설정과_관리"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>재전송 타임아웃 주기의 설정과 관리</h3><div class="heading-children"><div><p dir="auto">주어진 <code>EstimatedRTT</code> 와 <code>DevRTT</code> 값에서, <code>TCP 타임아웃 주기</code>에는 어떤 값이 사용되어야 하는가?</p></div><div><br></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">주기는 <code>EstimatedRTT</code>보다 크거나 같아야 한다.<br>
(그렇지 않다면 불필요한 재전송이 보내질 것)</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto"><code>EstimatedRTT</code>보다 너무 크면 안된다.<br>
(너무 크면 세그먼트를 잃었을 때, TCP는 세그먼트의 즉각적인 재전송을 하지 않게 됨)</p>
</li>
</ul></div><div><p dir="auto">→ 타임아웃값은 <code>EstimatedRTT</code>에 약간의 여윳값을 더한 값으로 설정하는 것이 바람직하다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">TimeoutInterval = EstimatedRTT + 4 × DevRTT</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">초기 <code>TimeoutInterval</code>의 값으로는 1초를 권고한다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">타임아웃이 발생할 때, <code>TimeoutInterval</code>의 값은 두 배로 하여<br>
조만간 확인응답할 후속 세그먼트에게 발생할 수 있는 <strong>조기 타임아웃을 피하도록 한다.</strong></p>
</li>
</ul></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="3.5.4 신뢰적인 데이터 전송" dir="auto" class="heading" id="3.5.4_신뢰적인_데이터_전송"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.5.4 신뢰적인 데이터 전송</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 TCP는 <em>IP의 비신뢰적인 최선형 서비스에서</em> <code>신뢰적인 데이터 전송 서비스(reliable data transfer service)</code>를 제공한다.</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">프로세스가 자신의 수신 버퍼로부터 읽은 데이터 스트림이 <strong>손상되지 않음</strong>을 보장한다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto"><strong>중복이 없다</strong>는 것과 <strong>순서가 유지된다</strong>는 것을 보장한다.</p>
</li>
</ul></div><div><br></div><div><p dir="auto">즉, 바이트 스트림은 송신자가 전송한 것과 같은 바이트 스트림이다.</p></div><div><br></div><div><p dir="auto"><strong>타이머 관리</strong>는 상당한 오버헤드를 유발할 수 있다.</p></div><div><p dir="auto">따라서 전송되었지만 확인응답이 안 된 다수의 세그먼트들이 있다고 하더라도,<br>
권장되는 <strong>TCP 타이머 관리 절차</strong>에서는 오직 <code>단일 재전송 타이머</code>를 사용한다.</p></div><div><p dir="auto">(이 장에서 설명하는 TCP 프로토콜은 <code>단일 타이머</code>를 따름)</p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="TCP 송신자의 데이터 전송/재전송에 관련된 세 가지 주요 이벤트" dir="auto" class="heading" id="TCP_송신자의_데이터_전송/재전송에_관련된_세_가지_주요_이벤트"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP 송신자의 데이터 전송/재전송에 관련된 세 가지 주요 이벤트</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">1️⃣ 상위 애플리케이션으로부터 수신된 데이터</p>
</blockquote></div><div><p dir="auto">첫 번째 이벤트 발생으로,</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">TCP는 <strong>애플리케이션으로부터</strong> 데이터를 받고,</li>
<li data-line="1" dir="auto"><code>세그먼트</code>로 이 데이터를 캡슐화하고,</li>
<li data-line="2" dir="auto"><strong>IP에게</strong> 이 세그먼트를 넘긴다.</li>
</ol></div><div><br></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">각 세그먼트는 세그먼트의 첫 번째 데이터 바이트의 바이트 열 번호인 <code>순서 번호</code>를 포함한다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">타이머가 이미 다른 세그먼트에 대해 실행 중이 아니면,<br>
<strong>TCP는 이 세그먼트를 IP로 넘길 때</strong> <code>타이머</code><strong>를 시작한다.</strong></p>
</li>
</ul></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">2️⃣ 타이머 타임아웃</p>
</blockquote></div><div><ol dir="auto">
<li data-line="0" dir="auto">TCP는 타임아웃 이벤트에 대해 <strong>타임아웃을 일으킨 세그먼트를 재전송</strong>하여 응답한다.</li>
<li data-line="1" dir="auto">그리고 TCP의 타이머를 다시 시작한다.</li>
</ol></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">3️⃣ 수신 확인응답 세그먼트(ACK) 수신</p>
</blockquote></div><div><p dir="auto">이 이벤트가 발생하면, TCP는 변수 <code>SendBase</code>와 ACK 값 <code>y</code>를 비교한다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><code>SendBase</code> : <strong>수신 확인응답이 확인되지 않은</strong> / <strong>가장 오래된</strong> 바이트의 순서번호</li>
<li data-line="1" dir="auto"><code>SendBase-1</code> : 수신자에게서 정확하게 차례대로 수신되었음을 알리는 마지막 바이트의 순서번호</li>
</ul></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">TCP는 누적 확인응답을 사용하고, <code>y</code>는 y바이트 이전의 모든 바이트의 수신을 확인한다.</p>
</blockquote></div><div><p dir="auto"><code>y &gt; SendBase</code>이면, ACK는 이전에 확인응답 안 된 하나 이상의 세그먼트들을 확인해준다.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">송신자는 자신의 <code>SendBase</code> 변수를 갱신한다.</li>
<li data-line="1" dir="auto"><strong>아직 확인응답 안 된 세그먼트들이 존재한다면</strong> 타이머를 다시 시작한다.</li>
</ol></div><div><br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="몇 가지 흥미로운 시나리오" dir="auto" class="heading" id="몇_가지_흥미로운_시나리오"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>몇 가지 흥미로운 시나리오</h2><div class="heading-children"><div><p dir="auto">TCP 프로토콜이 어떻게 작동하는지 몇 가지 간단한 시나리오를 통해 알아보자.</p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="손실된 확인응답에 기인하는 재전송" dir="auto" class="heading" id="손실된_확인응답에_기인하는_재전송"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>손실된 확인응답에 기인하는 재전송</h3><div class="heading-children"><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211437606-210348ac-1c16-4f20-b87e-6047251daee9.png" alt="손실된 확인응답에 기인하는 재전송" referrerpolicy="no-referrer" style="width: 400px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">호스트 A로부터 세그먼트가 호스트 B 측에서 수신되었음에도 B로부터 A로의 <code>긍정 확인응답이 손실된다면</code></p></div><div><ol dir="auto">
<li data-line="0" dir="auto">타임아웃이 발생한다.</li>
<li data-line="1" dir="auto">호스트 A는 같은 세그먼트를 B에게 재전송한다.</li>
<li data-line="2" dir="auto">호스트 B의 TCP는 재송신된 세그먼트의 바이트를 버린다.</li>
</ol></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="세그먼트 100이 재전송되지 않는 경우" dir="auto" class="heading" id="세그먼트_100이_재전송되지_않는_경우"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>세그먼트 100이 재전송되지 않는 경우</h3><div class="heading-children"><div><p dir="auto">호스트 A가 연속해서 두 세그먼트를 전송한다.</p></div><div><p dir="auto">호스트 A에서 타임아웃 이전에 <strong>어떠한 긍정 확인응답도 수신하지 못한다</strong>고 가정하자.</p></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211437609-5d593657-1975-4515-8614-9a8cf0d2d1fe.png" alt="세그먼트 100이 재전송되지 않는 경우" referrerpolicy="no-referrer" style="width: 520px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">타임아웃 이벤트가 발생하면</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">호스트 A는 <code>순서 번호 92</code>로 첫 번째 세그먼트를 재전송한다.</li>
<li data-line="1" dir="auto">타이머를 다시 시작한다.</li>
<li data-line="2" dir="auto">새로운 타임아웃 이전에 두 번째 세그먼트에 대한 ACK가 도착하는 한,<br>
<strong>두 번째 세그먼트는 재전송을 하지 않을 것이다.</strong></li>
</ol></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="누적 확인응답은 첫 번째 세그먼트의 재전송을 방지한다" dir="auto" class="heading" id="누적_확인응답은_첫_번째_세그먼트의_재전송을_방지한다"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>누적 확인응답은 첫 번째 세그먼트의 재전송을 방지한다</h3><div class="heading-children"><div><p dir="auto">호스트 A가 연속해서 두 세그먼트를 전송한다.</p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211437607-08796096-fe33-4e0b-b443-54e51db96706.png" alt="누적 확인응답" referrerpolicy="no-referrer" style="width: 520px; max-width: 100%;"></p></div><div><br>
<br></div><div><p dir="auto">첫 번째 세그먼트의 긍정 확인응답이 네트워크에서 분실되었지만,<br>
<strong>첫 번째 세그먼트의 타임아웃 전에</strong> 호스트 A가 <strong>긍정 응답번호 120의</strong> <code>긍정 확인응답을 수신하면</code></p></div><div><ul dir="auto">
<li data-line="0" dir="auto">호스트 A는 호스트 B가 119바이트까지 <strong>모든</strong> 데이터를 수신했음을 알게 된다.</li>
<li data-line="1" dir="auto">그러므로 호스트 A는 두 세그먼트 중 <strong>어느 것도 재전송하지 않는다.</strong></li>
</ul></div><div><br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="TCP는 GBN인가 SR인가?" dir="auto" class="heading" id="TCP는_GBN인가_SR인가?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP는 GBN인가 SR인가?</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 <code>TCP 확인응답</code>은 누적되고 올바르게 수신되지만, <strong>순서가 잘못된 세그먼트는 수신자가 개별적으로 ACK를 받지 않는다.</strong></p>
</blockquote></div><div><blockquote dir="auto">
<p dir="auto">TCP 송신자는 전송했지만 확인응답 안 된 바이트의 가장 작은 순서 번호, <code>SendBase</code>와 전송될 다음 바이트의 순서 번호, <code>NextSeqNum</code>을 유지해야 한다.</p>
</blockquote></div><div><p dir="auto">이런 관점에서 TCP는 GBN 형태의 프로토콜과 비슷해보이나, ’TCP에서는 <strong>올바르게 수신되었지만 순서가 바뀐 세그먼트들을 버퍼링한다</strong>’는 차이점이 존재한다.</p></div><div><p dir="auto">e.g.,<br>
패킷 <code>n &lt; N</code>에 대한 <strong>긍정 확인응답이 손실</strong>되었지만,<br>
나머지 N-1개의 긍정 확인 응답들은 타임아웃 전에 송신 측에 도달했다고 가정한다.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><code>GBN</code> : 패킷 n뿐만 아니라, <strong>연속적인 패킷 n+1, n+2, … , N 모두를 재전송한다.</strong></p>
</li>
<li data-line="3" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto"><code>TCP</code></p>
<ol dir="auto">
<li data-line="4" dir="auto"><strong>세그먼트 n 하나만을 재전송</strong></li>
<li data-line="5" dir="auto">세그먼트 n에 대한 타임아웃 전에 세그먼트 n+1에 대한 긍정 확인 응답이 도착한다면 세그먼트를 재전송하지 않는다.</li>
</ol>
</li>
</ol></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 TCP에서 수정제안된 <code>선택적 확인응답(selective acknowledgment)</code><br>
: TCP 수신자가 마지막으로 올바로 수신된 ‘순서가 맞는’ 세그먼트에 대해 누적 확인응답을 하기보다는<br>
<strong>‘순서가 틀린’ 세그먼트에 대해 선택적으로 확인응답을 하게 한다.</strong></p>
</blockquote></div><div><p dir="auto">이를 선택적 재전송과 결합했을 경우, SR 프로토콜과 매우 유사하다.</p></div><div><br></div><div><p dir="auto">따라서 TCP의 오류 복구 메커니즘은 <strong>GBN과 SR 프로토콜의 혼합</strong>으로 분류하는 것이 적당하다.</p></div><div><br></div></div></div><div class="heading-wrapper"><h2 data-heading="빠른 재전송" dir="auto" class="heading" id="빠른_재전송"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>빠른 재전송</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto"><code>타임아웃</code>이 유발하는 재전송의 문제 : 타임아웃의 주기가 때때로 비교적 길다.</p>
</blockquote></div><div><p dir="auto">긴 타임아웃 주기는 종단 간의 지연을 증가시키지만,<br>
다행히도 송신자는 종종 <code>중복 ACK</code>에 의한 타임아웃이 일어나기 전에 패킷 손실을 발견한다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 <code>중복 ACK(duplicate ACK)</code> : 송신자가 이미 이전에 받은 확인응답에 대한 <strong>재확인응답 세그먼트 ACK</strong></p>
</blockquote></div><div><br></div><div class="heading-wrapper"><h3 data-heading="수신자가 중복 ACK를 보내는 이유" dir="auto" class="heading" id="수신자가_중복_ACK를_보내는_이유"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>수신자가 중복 ACK를 보내는 이유</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto"><strong>TCP는 부정 확인응답을 사용하지 않으므로</strong>, 수신자는 송신자에게 부정 확인 응답을 보낼 수 없다.</p>
</blockquote></div><div><ol dir="auto">
<li data-line="0" dir="auto">TCP 수신자가 기다리는 다음 것보다 더 큰 순서 번호를 가진 세그먼트를 받았을 때, TCP 수신자는 <code>손실 세그먼트</code>를 찾아낼 것이다.</li>
<li data-line="1" dir="auto">수신자는 마지막으로 수신된 순차적인 바이트를 갖는 데이터를 그냥 다시 확인응답한다.<br>
즉, <code>중복 ACK</code>를 생성한다.</li>
</ol></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="TCP ACK 생성 권고" dir="auto" class="heading" id="TCP_ACK_생성_권고"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP ACK 생성 권고</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">이벤트 1️⃣<br>
기다리는 순서 번호를 가진 ‘순서가 맞는’ 세그먼트의 도착<br>
기다리는 순서 번호까지의 <strong>모든 데이터는 이미 확인응답된다.</strong></p>
</blockquote></div><div><p dir="auto">TCP 수신자 동작 : <code>지연된 ACK</code></p></div><div><ol dir="auto">
<li data-line="0" dir="auto">또 다른 ‘순서가 맞는’ 세그먼트의 도착을 위해 500 ms까지 기다린다.</li>
<li data-line="1" dir="auto">만약 다음 ‘순서에 맞는’ 세그먼트가 이 기간에 도착하지 않으면, 그냥 ACK를 보낸다.</li>
</ol></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">이벤트 2️⃣<br>
기다리는 순서 번호를 가진 ‘순서가 맞는’ 세그먼트의 도착<br>
<strong>ACK 전송을 기다리는</strong> 다른 하나의 ‘순서에 맞는’ 세그먼트가 있다.</p>
</blockquote></div><div><p dir="auto">TCP 수신자 동작 : 2개의 ‘순서가 맞는’ 세그먼트들을 ACK하기 위해, <code>하나의 누적된 ACK</code>를 즉시 보낸다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">이벤트 3️⃣<br>
<strong>기다리는 것보다 높은 순서 번호를 가진</strong> ‘순서가 바뀐’ 세그먼트의 도착 격자가 발견된다.</p>
</blockquote></div><div><p dir="auto">TCP 수신자 동작<br>
: 순서 번호가 다음의 기다리는 바이트(즉, 격차의 최솟값)를 나타내는 <code>중복 ACK</code>를 즉시 보낸다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">이벤트 4️⃣<br>
수신 데이터에서 <strong>격차를 부분적으로 또는 모두 채우는</strong> 세그먼트의 도착</p>
</blockquote></div><div><p dir="auto">TCP 수신자 동작 : 그 세그먼트가 <strong>격차의 최솟값에서 시작한다고 하면</strong>, 즉시 <code>ACK</code>를 보낸다.</p></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="빠른 재전송(fast retransmit)" dir="auto" class="heading" id="빠른_재전송(fast_retransmit)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>빠른 재전송(fast retransmit)</h3><div class="heading-children"><div><p dir="auto">만약 TCP 송신자가 같은 데이터에 대해 <strong>3개의 중복 확인응답</strong>을 수신한다면,<br>
이것은 ACK된 세그먼트의 다음 3개의 세그먼트가 분실되었음을 의미한다.</p></div><div><blockquote dir="auto">
<p dir="auto">💡 <code>3개의 중복 ACK</code>를 수신할 때,<br>
TCP는 <strong>세그먼트의 타이머가 만료되기 이전에</strong> 손실 세그먼트를 재전송한다.</p>
</blockquote></div><div><br></div><div><p dir="auto">아래 그림을 보면 두 번째 세그먼트를 잃어버린 경우, 타이머가 만료되기 <strong>전에</strong> 재전송되었다.</p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211437613-e03e0eac-251b-4e1c-8d29-c975dfa545b1.png" alt="빠른 재전송" referrerpolicy="no-referrer" style="width: 430px; max-width: 100%;"></p></div><div><br>
<br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="3.5.5 흐름 제어" dir="auto" class="heading" id="3.5.5_흐름_제어"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.5.5 흐름 제어</h2><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 TCP는 송신자가 <strong>수신자의 버퍼를 오버플로시키는 것을 방지하기 위해</strong><br>
애플리케이션에게 <code>흐름 제어 서비스(flow-control service)</code>를 제공한다.</p>
</blockquote></div><div><p dir="auto">→ 수신하는 애플리케이션이 읽는 속도와 송신자가 전송하는 속도를 같게 한다.</p></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">TCP 송신자는 IP 네트워크에서 혼잡 때문에 <strong>억제</strong>될 수도 있다. = <code>혼잡 제어(congestion control)</code></p>
</blockquote></div><div><p dir="auto"><em>흐름 제어와 혼잡 제어는 명백히 각기 다른 목적으로 수행된다. (잘 구별하여야 함)</em></p></div><div><br></div><div class="heading-wrapper"><h3 data-heading="과정" dir="auto" class="heading" id="과정"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>과정</h3><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto">💡 TCP는 <code>수신 윈도(receive window)</code>라는 변수를 유지하여 흐름 제어를 제공한다.</p>
</blockquote></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><strong>수신 측에서 가용한 버퍼 공간이 얼마나 되는지</strong>를 송신자에게 알려주는데 사용된다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">TCP는 <code>전이중(full-duplex)</code>이므로 연결의 각 측의 송신자는 별개의 수신 윈도를 유지한다.</p>
</li>
</ul></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">e.g., TCP 연결상에서 호스트 A가 호스트 B에게 큰 파일을 전송한다고 가정</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">호스트 B는 이 연결에 수신 버퍼를 할당한다.<br>
(이때 할당된 수신 버퍼의 크기 : <code>RcvBuffer</code>)</p>
</li>
<li data-line="4" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">호스트 B의 애플리케이션 프로세스는 버퍼로부터 데이터를 읽으며 다음과 같은 변수들을 정의한다.</p>
<ul dir="auto">
<li data-line="5" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>LastByteRead</code><br>
: 호스트 B의 애플리케이션 프로세스에 의해 버퍼로부터 <strong>읽힌</strong> 데이터 스트림의 마지막 바이트 번호
<ul dir="auto">
<li data-line="7" dir="auto"><code>LastByteRcvd</code><br>
: 호스트 B에서 네트워크로부터 도착하여 수신 버퍼에 <strong>저장된</strong> 데이터 스트림의 마지막 바이트 번호</li>
<li data-line="9" dir="auto"><code>rwnd</code></li>
<li data-line="10" dir="auto">수신 윈도 = <strong>버퍼의 여유 공간</strong></li>
<li data-line="11" dir="auto">시간에 따라 여유 공간은 변하므로 이 변수는 동적이다.</li>
</ul>
</li>
</ul>
</li>
</ol></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">LastByteRcvd - LastByteRead ≤ RcvBuffer</p>
</blockquote></div><div><blockquote dir="auto">
<p dir="auto">rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]</p>
</blockquote></div><div><br></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211437616-fd0b34a2-9117-4bd5-bfb0-3fe82e59e4c3.png" alt="수신 윈도와 수신 버퍼" referrerpolicy="no-referrer" style="width: 480px; max-width: 100%;"></p></div><div><br>
<br></div><div><hr dir="auto"></div><div><br></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">호스트 B는 호스트 B가 호스트 A에게 전송하는 모든 세그먼트의 윈도 필드에 현재 <code>rwnd</code> 값을 설정한다.</p>
<blockquote dir="auto">
<p dir="auto">이를 통해 호스트 A에게 <strong>연결 버퍼에 얼마만큼의 여유 공간이 있는지를 알려준다.</strong></p>
</blockquote>
</li>
<li data-line="4" dir="auto">
<p dir="auto">호스트 A는 두 변수 <code>LastByteSent</code>와 <code>LastByteAcked</code>를 유지한다.</p>
<blockquote dir="auto">
<p dir="auto">LastByteSent - LastByteAcked = 호스트 A가 이 연결에 <strong>전송 확인응답이 안 된</strong> 데이터의 양</p>
</blockquote>
</li>
</ol></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">💡 <code>rwnd</code>의 값보다 작은 확인응답 안 된 데이터의 양을 유지함으로써<br>
호스트 A는 호스트 B의 수신 버퍼에 오버플로가 발생하지 않는다는 것을 확신한다.</p>
</blockquote></div><div><br></div><div><p dir="auto">호스트 A는 연결된 동안 다음의 내용을 보장한다.</p></div><div><blockquote dir="auto">
<p dir="auto">LastBySent - LastByteAcked ≤ rwnd</p>
</blockquote></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="문제점과 해결법" dir="auto" class="heading" id="문제점과_해결법"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>문제점과 해결법</h3><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto">호스트 B의 수신 버퍼는 <code>rwnd = 0</code>으로서 가득 찼고</li>
<li data-line="1" dir="auto">호스트 A에게 rwnd = 0이라고 알린 후 <strong>호스트 B는 호스트 A에게 전송할 것이 없는 경우</strong></li>
</ol></div><div><blockquote dir="auto">
<p dir="auto">호스트 B에서의 애플리케이션 프로세스가 버퍼를 비우더라도,<br>
<strong>TCP는 호스트 A에게 새로운 rwnd로 새로운 세그먼트를 전송하지 않는다.</strong></p>
</blockquote></div><div><br></div><div><p dir="auto">즉, TCP는 전송할 데이터가 있거나, 전송해야 할 확인응답을 가진 경우에만 호스트 A에게 세그먼트를 전송할 것이다.</p></div><div><p dir="auto">→ 호스트 A는 차단되고 더는 데이터를 전송할 수 없다.</p></div><div><br></div><div><p dir="auto">따라서 TCP 명세서는 호스트 A가 호스트 B의 수신 윈도가 0일 때, 1바이트 데이터로 세그먼틀르 계속해서 전송하도록 요구한다.</p></div><div><br>
<br></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="3.5.6 TCP 연결 관리" dir="auto" class="heading" id="3.5.6_TCP_연결_관리"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.5.6 TCP 연결 관리</h2><div class="heading-children"><div><p dir="auto">TCP 연결이 어떻게 설정되고 해제되는가?</p></div><div><br></div><div><p dir="auto">하나의 호스트(클라이언트)에서 운영되는 프로세스가 다른 호스트(서버) 안의 또 다른 프로세스와 연결을 시작하길 원한다고 가정하자.</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">클라이언트 애플리케이션 프로세스는 서버에 있는 프로세스와 연결 설정하기를 원한다는 것을 <strong>클라이언트 TCP에게 알린다.</strong></li>
<li data-line="1" dir="auto">클라이언트 안의 TCP는 다음과 같은 방법으로 TCP를 이용해 서버와 TCP 연결 설정을 시작한다.</li>
</ol></div><div><br></div><div class="heading-wrapper"><h3 data-heading="연결의 설정 : 세 방향 핸드셰이크(three-way handshake)" dir="auto" class="heading" id="연결의_설정_:_세_방향_핸드셰이크(three-way_handshake)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>연결의 설정 : 세 방향 핸드셰이크(three-way handshake)</h3><div class="heading-children"><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211437617-b3a75ef9-8307-499f-b011-2bfb62f92916.png" alt="TCP 세 방향 핸드셰이크" referrerpolicy="no-referrer" style="width: 450px; max-width: 100%;"></p></div><div><br>
<br></div><div class="heading-wrapper"><h4 data-heading="1단계" dir="auto" class="heading" id="1단계"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1단계</h4><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">클라이언트 측 TCP는 서버 TCP에게 특별한 TCP 세그먼트, <code>SYN 세그먼트</code>를 송신한다.</p>
<ul dir="auto">
<li data-line="1" dir="auto">애플리케이션 계층 데이터를 포함하지 않는다.</li>
<li data-line="2" dir="auto">세그먼트 헤더에 <code>SYN 비트</code>를 <strong>1</strong>로 설정한다.</li>
</ul>
</li>
<li data-line="5" dir="auto">
<p dir="auto">클라이언트는 최소 순서 번호(<code>client_isn</code>)를 임의로 선택하고, 최초의 TCP SYN 세그먼트의 <code>순서 번호 필드</code>에 이 번호를 넣는다.</p>
</li>
<li data-line="8" dir="auto">
<p dir="auto">이 세그먼트는 IP 데이터그램 안에서 캡슐화되고 서버로 송신된다.</p>
</li>
</ol></div><div><br></div></div></div><div class="heading-wrapper"><h4 data-heading="2단계" dir="auto" class="heading" id="2단계"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2단계</h4><div class="heading-children"><div><p dir="auto">TCP SYN 세그먼트를 포함하는 <code>IP 데이터그램</code>이 서버 호스트에 도착하면,</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">서버는 데이터그램으로부터 TCP SYN 세그먼트를 추출한다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">연결에 TCP 버퍼와 변수를 할당한다.</p>
</li>
<li data-line="6" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">클라이언트 TCP로 <strong>연결 승인 세그먼트,</strong> <code>SYNACK 세그먼트</code>를 송신한다.</p>
<ul dir="auto">
<li data-line="7" dir="auto">애플리케이션 계층 데이터를 포함하지 않는다.</li>
<li data-line="8" dir="auto"><code>SYN 비트</code>는 <strong>1</strong>로 설정된다.</li>
<li data-line="9" dir="auto">TCP 세그먼트 헤더의 <code>확인응답 필드</code>는 <code>client_isn+1</code>로 설정된다.</li>
<li data-line="10" dir="auto">서버는 자신의 최초의 순서 번호(<code>server_isn</code>)를 선택하고, TCP 세그먼트 헤더의 <code>순서 번호 필드</code>에 이 값을 넣는다.</li>
</ul>
</li>
</ol></div><div><br></div></div></div><div class="heading-wrapper"><h4 data-heading="3단계" dir="auto" class="heading" id="3단계"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3단계</h4><div class="heading-children"><div><p dir="auto">연결 승인 세그먼트를 수신하면,</p></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">클라이언트는 연결에 버퍼와 변수를 할당한다.</p>
</li>
<li data-line="3" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">클라이언트 호스트는 서버로 <strong>또 다른 세그먼트</strong>를 송신한다.</p>
<ol dir="auto">
<li data-line="4" dir="auto">클라이언트는 TCP 세그먼트 헤더의 <code>확인응답 필드</code> 안에 <code>server_isn+1</code> 값을 넣어, 서버의 연결 승인 세그먼트를 확인한다.</li>
<li data-line="5" dir="auto">연결이 설정되었기 때문에 <code>SYN 비트</code>는 <strong>0</strong>으로 설정된다.</li>
</ol>
</li>
</ol></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">세 번째 단계는 클라이언트에서 서버로의 데이터를 <code>세그먼트 페이로드</code>에서 운반할 수 있다.</p>
</blockquote></div><div><br></div><div><hr dir="auto"></div><div><br></div><div><p dir="auto">위의 세 단계가 완료되면,</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">클라이언트와 서버 호스트들은 각각 서로에게 <code>데이터를 포함하는 세그먼트</code>를 보낼 수 있다.</li>
<li data-line="1" dir="auto"><code>SYN 비트</code>는 <strong>0</strong>으로 설정된다.</li>
</ul></div><div><br></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="연결의 종료" dir="auto" class="heading" id="연결의_종료"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>연결의 종료</h3><div class="heading-children"><div><p dir="auto">TCP 연결에 참여하는 두 프로세스 중 하나가 연결을 끊을 수 있다.</p></div><div><p dir="auto">연결이 끝날 때, <strong>호스트의 ‘자원’(버퍼와 변수)는 회수된다.</strong></p></div><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211437618-6aea0b08-6847-450d-b5d7-a1ae129d0c56.png" alt="TCP 연결 종료" referrerpolicy="no-referrer" style="width: 400px; max-width: 100%;"></p></div><div><br>
<br></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">클라이언트 애플리케이션 프로세스는 <strong>종료 명령</strong>을 내린다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">이는 클라이언트 TCP가 서버 프로세스에게 <code>특별한 TCP 세그먼트</code>를 보내도록 한다.<br>
(<code>FIN 비트</code>를 <strong>1</strong>로 설정)</p>
</li>
<li data-line="7" dir="auto">
<p dir="auto">서버가 이 세그먼트를 수신하면, 서버는 클라이언트에게 <code>확인응답 세그먼트</code>를 보낸다.</p>
</li>
<li data-line="10" dir="auto">
<p dir="auto">그 다음에 <code>FIN 비트</code>가 <strong>1</strong>로 설정된 자신의 <code>종료 세그먼트를 송신</code>한다.</p>
</li>
<li data-line="13" dir="auto">
<p dir="auto">마지막으로 클라이언트는 서버의 종료 세그먼트에 <code>확인응답</code>을 한다.</p>
<blockquote dir="auto">
<p dir="auto">이 시점에서 두 호스트의 모든 자원은 할당이 해제된다.</p>
</blockquote>
</li>
</ol></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="TCP 상태(TCP state)" dir="auto" class="heading" id="TCP_상태(TCP_state)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP 상태(TCP state)</h3><div class="heading-children"><div><p dir="auto">TCP 연결이 존재하는 동안 각 호스트에서 동작하는 TCP 프로토콜은 <strong>다양한 TCP 상태를 두루 전이한다.</strong></p></div><div><p dir="auto">아래의 두 그림은 클라이언트가 연결 해제를 시작한다는 것을 가정한다.</p></div><div><br></div><div class="heading-wrapper"><h4 data-heading="클라이언트 TCP에서 TCP 상태 변이의 일반 순서" dir="auto" class="heading" id="클라이언트_TCP에서_TCP_상태_변이의_일반_순서"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>클라이언트 TCP에서 TCP 상태 변이의 일반 순서</h4><div class="heading-children"><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211440563-c245132e-f149-46d6-a184-621ccb29b848.png" alt="TCP 상태 전이 - 클라이언트" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;"></p></div><div><br>
<br></div></div></div><div class="heading-wrapper"><h4 data-heading="서버 TCP에서 TCP 상태 변이의 일반 순서" dir="auto" class="heading" id="서버_TCP에서_TCP_상태_변이의_일반_순서"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>서버 TCP에서 TCP 상태 변이의 일반 순서</h4><div class="heading-children"><div><p align="center" dir="auto"><img src="https://user-images.githubusercontent.com/86337233/211440566-f2dc1e33-46ab-459b-8dc6-707fc963ba70.png" alt="TCP 상태 전이 - 서버" referrerpolicy="no-referrer" style="width: 500px; max-width: 100%;"></p></div><div><br>
<br>
<br></div></div></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="SYN 플러드 공격" dir="auto" class="heading" id="SYN_플러드_공격"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>SYN 플러드 공격</h2><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="TCP의 세 방향 핸드셰이크" dir="auto" class="heading" id="TCP의_세_방향_핸드셰이크"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>TCP의 세 방향 핸드셰이크</h3><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">서버는 <code>수신된 SYN</code>에 대한 응답으로 연결 변수와 버퍼를 할당하고 초기화한다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">그 다음, 서버는 응답으로 <code>SYNACK</code>을 보내고 클라이언트의 <code>ACK 세그먼트</code>를 기다린다.</p>
</li>
</ol></div><div><br></div><div><blockquote dir="auto">
<p dir="auto">클라이언트가 이 세 방향 핸드셰이크의 세 번째 단계를 완료하기 위한 ACK를 보내지 않으면<br>
<strong>결국(종종 1분 이상 후에) 서버가 절반만 열린 연결을 종료하고 할당된 자원을 회수한다.</strong></p>
</blockquote></div><div><p dir="auto">→ 이는 <code>SYN 플러드 공격</code>의 무대가 된다.</p></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="SYN 플러드 공격(SYN flood attack)" dir="auto" class="heading" id="SYN_플러드_공격(SYN_flood_attack)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>SYN 플러드 공격(SYN flood attack)</h3><div class="heading-children"><div><p dir="auto">고전적인 <code>서비스 거부(Denial of Service, DoS) 공격</code></p></div><div><br></div><div><ol dir="auto">
<li data-line="0" dir="auto">
<p dir="auto">공격자는 핸드셰이크의 세 버너째 단계를 완료하지 않은 상태에서 무수한 <code>TCP SYN 세그먼트</code>를 보낸다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto">서버의 연결 자원이 반쪽 연결에 할당된다.</p>
</li>
<li data-line="6" dir="auto">
<p dir="auto">결국 서버의 연결 자원이 소진됨에 따라 합법적인 클라이언트들이 서비스 거부가 된다.</p>
</li>
</ol></div><div><br></div></div></div><div class="heading-wrapper"><h3 data-heading="SYN 쿠키" dir="auto" class="heading" id="SYN_쿠키"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>SYN 쿠키</h3><div class="heading-children"><div><p dir="auto">이는 <strong>SYN 플러드 공격에 대한 방어책</strong>으로, 현재 대부분의 운영체제에 존재하고 있다.</p></div><div><br></div><div class="heading-wrapper"><h4 data-heading="동작 방법" dir="auto" class="heading" id="동작_방법"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>동작 방법</h4><div class="heading-children"><div><ol dir="auto">
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">서버는 SYN에 대해 반만 열린(half-open) TCP 연결을 만들지 않고,<br>
<code>초기 TCP 순서 번호(쿠키, cookie)</code>를 만든다.</p>
<ul dir="auto">
<li data-line="2" dir="auto">서버가 SYN 세그먼트를 받을 때, 그 세그먼트가 정당한 사용자로부터 또는 공격자로부터 온 것인지 구별할 수 없기 때문이다.</li>
<li data-line="3" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>해시 함수에 아래의 항목들을 사용하여 쿠키를 생성한다.
<ul dir="auto">
<li data-line="4" dir="auto">비밀번호</li>
<li data-line="5" dir="auto">SYN 세그먼트의 출발지와 목적지 IP 주소들과 포트번호</li>
</ul>
</li>
</ul>
</li>
<li data-line="8" dir="auto">
<p dir="auto">서버는 이 특별한 초기 순서 번호를 가진 <code>SYNACK</code> 패킷을 보낸다.</p>
<blockquote dir="auto">
<p dir="auto">💡 서버는 SYN에 관련된 쿠키나 어떤 다른 상태 정보를 <strong>기억하지 않는다.</strong></p>
</blockquote>
</li>
<li data-line="13" dir="auto">
<p dir="auto">합법적인 클라이언트는 <code>ACK</code> 세그먼트를 회신한다.</p>
</li>
<li data-line="16" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p dir="auto">이 ACK를 받은 서버는 ACK가 이전에 보낸 일부 SYN에 관한 것인지 확인해야 한다.</p>
<ul dir="auto">
<li data-line="17" dir="auto">이는 이전에 보낸 일부 SYN에 관한 것인지는 <code>쿠키</code><strong>를 통해 확인한다.</strong></li>
<li data-line="18" dir="auto">서버는 SYNACK에 있는 출발지와 목적지 IP 주소와 포트번호, 비밀번호를 사용해서 동일한 해시 함수를 실행한다.</li>
</ul>
</li>
</ol></div><div><br></div><div><p dir="auto"><strong>만약 함수의 결과에 1을 더한 것이 클라이언트의 SYNACK에 있는 확인응답 번호(쿠키)와 같다면</strong><br>
서버는 ACK가 초기 SYN 세그먼트에 관련된 것, 즉 올바른 것이라고 결론짓는다.</p></div><div><p dir="auto">→ 이후 서버는 소켓을 가지고 완전하게 열린 연결을 만든다.</p></div><div><br></div><div><p dir="auto">만약 클라이언트가 ACK 세그먼트를 회신하지 않으면<br>
서버가 처음의 가짜 SYN에 대해 어떤 자원도 할당하지 않았기 때문에 처음의 SYN은 서버에 해를 끼치지 못한다.</p></div><div class="mod-footer"></div></div></div></div></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#3.5 연결지향형 트랜스포트: TCP"><div class="tree-item-contents heading-link" heading-name="3.5 연결지향형 트랜스포트: TCP"><span class="tree-item-title">3.5 연결지향형 트랜스포트: TCP</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#3.5.1_TCP_연결"><div class="tree-item-contents heading-link" heading-name="3.5.1 TCP 연결"><span class="tree-item-title">3.5.1 TCP 연결</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#TCP_연결_과정"><div class="tree-item-contents heading-link" heading-name="TCP 연결 과정"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">TCP 연결 과정</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#세_방향_핸드셰이크(three-way_handshake)"><div class="tree-item-contents heading-link" heading-name="세 방향 핸드셰이크(three-way handshake)"><span class="tree-item-title">세 방향 핸드셰이크(three-way handshake)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#TCP_연결이_설정된_이후"><div class="tree-item-contents heading-link" heading-name="TCP 연결이 설정된 이후"><span class="tree-item-title">TCP 연결이 설정된 이후</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#최대_세그먼트_크기(maximum_segment_size,_MSS)"><div class="tree-item-contents heading-link" heading-name="최대 세그먼트 크기(maximum segment size, MSS)"><span class="tree-item-title">최대 세그먼트 크기(maximum segment size, MSS)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#TCP_세그먼트(TCP_segment)"><div class="tree-item-contents heading-link" heading-name="TCP 세그먼트(TCP segment)"><span class="tree-item-title">TCP 세그먼트(TCP segment)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#3.5.2_TCP_세그먼트_구조"><div class="tree-item-contents heading-link" heading-name="3.5.2 TCP 세그먼트 구조"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.5.2 TCP 세그먼트 구조</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#구조"><div class="tree-item-contents heading-link" heading-name="구조"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">구조</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#**헤더_필드**"><div class="tree-item-contents heading-link" heading-name="**헤더 필드**"><span class="tree-item-title"><strong>헤더 필드</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#**데이터_필드**"><div class="tree-item-contents heading-link" heading-name="**데이터 필드**"><span class="tree-item-title"><strong>데이터 필드</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#MSS"><div class="tree-item-contents heading-link" heading-name="MSS"><span class="tree-item-title">MSS</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#순서_번호와_확인응답_번호"><div class="tree-item-contents heading-link" heading-name="순서 번호와 확인응답 번호"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">순서 번호와 확인응답 번호</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#순서_번호"><div class="tree-item-contents heading-link" heading-name="순서 번호"><span class="tree-item-title">순서 번호</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#확인응답_번호"><div class="tree-item-contents heading-link" heading-name="확인응답 번호"><span class="tree-item-title">확인응답 번호</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#텔넷:_순서_번호와_응답확인_번호_사례연구"><div class="tree-item-contents heading-link" heading-name="텔넷: 순서 번호와 응답확인 번호 사례연구"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">텔넷: 순서 번호와 응답확인 번호 사례연구</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#텔넷(Telnet)"><div class="tree-item-contents heading-link" heading-name="텔넷(Telnet)"><span class="tree-item-title">텔넷(Telnet)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#3.5.3_왕복_시간(RTT)_예측과_타임아웃"><div class="tree-item-contents heading-link" heading-name="3.5.3 왕복 시간(RTT) 예측과 타임아웃"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.5.3 왕복 시간(RTT) 예측과 타임아웃</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#왕복_시간_예측"><div class="tree-item-contents heading-link" heading-name="왕복 시간 예측"><span class="tree-item-title">왕복 시간 예측</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#재전송_타임아웃_주기의_설정과_관리"><div class="tree-item-contents heading-link" heading-name="재전송 타임아웃 주기의 설정과 관리"><span class="tree-item-title">재전송 타임아웃 주기의 설정과 관리</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#3.5.4_신뢰적인_데이터_전송"><div class="tree-item-contents heading-link" heading-name="3.5.4 신뢰적인 데이터 전송"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.5.4 신뢰적인 데이터 전송</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#TCP_송신자의_데이터_전송/재전송에_관련된_세_가지_주요_이벤트"><div class="tree-item-contents heading-link" heading-name="TCP 송신자의 데이터 전송/재전송에 관련된 세 가지 주요 이벤트"><span class="tree-item-title">TCP 송신자의 데이터 전송/재전송에 관련된 세 가지 주요 이벤트</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#몇_가지_흥미로운_시나리오"><div class="tree-item-contents heading-link" heading-name="몇 가지 흥미로운 시나리오"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">몇 가지 흥미로운 시나리오</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#손실된_확인응답에_기인하는_재전송"><div class="tree-item-contents heading-link" heading-name="손실된 확인응답에 기인하는 재전송"><span class="tree-item-title">손실된 확인응답에 기인하는 재전송</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#세그먼트_100이_재전송되지_않는_경우"><div class="tree-item-contents heading-link" heading-name="세그먼트 100이 재전송되지 않는 경우"><span class="tree-item-title">세그먼트 100이 재전송되지 않는 경우</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#누적_확인응답은_첫_번째_세그먼트의_재전송을_방지한다"><div class="tree-item-contents heading-link" heading-name="누적 확인응답은 첫 번째 세그먼트의 재전송을 방지한다"><span class="tree-item-title">누적 확인응답은 첫 번째 세그먼트의 재전송을 방지한다</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#TCP는_GBN인가_SR인가?"><div class="tree-item-contents heading-link" heading-name="TCP는 GBN인가 SR인가?"><span class="tree-item-title">TCP는 GBN인가 SR인가?</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#빠른_재전송"><div class="tree-item-contents heading-link" heading-name="빠른 재전송"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">빠른 재전송</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#수신자가_중복_ACK를_보내는_이유"><div class="tree-item-contents heading-link" heading-name="수신자가 중복 ACK를 보내는 이유"><span class="tree-item-title">수신자가 중복 ACK를 보내는 이유</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#TCP_ACK_생성_권고"><div class="tree-item-contents heading-link" heading-name="TCP ACK 생성 권고"><span class="tree-item-title">TCP ACK 생성 권고</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#빠른_재전송(fast_retransmit)"><div class="tree-item-contents heading-link" heading-name="빠른 재전송(fast retransmit)"><span class="tree-item-title">빠른 재전송(fast retransmit)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#3.5.5_흐름_제어"><div class="tree-item-contents heading-link" heading-name="3.5.5 흐름 제어"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.5.5 흐름 제어</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#과정"><div class="tree-item-contents heading-link" heading-name="과정"><span class="tree-item-title">과정</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#문제점과_해결법"><div class="tree-item-contents heading-link" heading-name="문제점과 해결법"><span class="tree-item-title">문제점과 해결법</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#3.5.6_TCP_연결_관리"><div class="tree-item-contents heading-link" heading-name="3.5.6 TCP 연결 관리"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.5.6 TCP 연결 관리</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#연결의_설정_:_세_방향_핸드셰이크(three-way_handshake)"><div class="tree-item-contents heading-link" heading-name="연결의 설정 : 세 방향 핸드셰이크(three-way handshake)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">연결의 설정 : 세 방향 핸드셰이크(three-way handshake)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#1단계"><div class="tree-item-contents heading-link" heading-name="1단계"><span class="tree-item-title">1단계</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#2단계"><div class="tree-item-contents heading-link" heading-name="2단계"><span class="tree-item-title">2단계</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#3단계"><div class="tree-item-contents heading-link" heading-name="3단계"><span class="tree-item-title">3단계</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#연결의_종료"><div class="tree-item-contents heading-link" heading-name="연결의 종료"><span class="tree-item-title">연결의 종료</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#TCP_상태(TCP_state)"><div class="tree-item-contents heading-link" heading-name="TCP 상태(TCP state)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">TCP 상태(TCP state)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#클라이언트_TCP에서_TCP_상태_변이의_일반_순서"><div class="tree-item-contents heading-link" heading-name="클라이언트 TCP에서 TCP 상태 변이의 일반 순서"><span class="tree-item-title">클라이언트 TCP에서 TCP 상태 변이의 일반 순서</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#서버_TCP에서_TCP_상태_변이의_일반_순서"><div class="tree-item-contents heading-link" heading-name="서버 TCP에서 TCP 상태 변이의 일반 순서"><span class="tree-item-title">서버 TCP에서 TCP 상태 변이의 일반 순서</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#SYN_플러드_공격"><div class="tree-item-contents heading-link" heading-name="SYN 플러드 공격"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">SYN 플러드 공격</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#TCP의_세_방향_핸드셰이크"><div class="tree-item-contents heading-link" heading-name="TCP의 세 방향 핸드셰이크"><span class="tree-item-title">TCP의 세 방향 핸드셰이크</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#SYN_플러드_공격(SYN_flood_attack)"><div class="tree-item-contents heading-link" heading-name="SYN 플러드 공격(SYN flood attack)"><span class="tree-item-title">SYN 플러드 공격(SYN flood attack)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#SYN_쿠키"><div class="tree-item-contents heading-link" heading-name="SYN 쿠키"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">SYN 쿠키</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="중앙대학교-수업\4-1\네트워크응용설계-요약\chapter_3\3.5-연결지향형-트랜스포트_-tcp\readme.html#동작_방법"><div class="tree-item-contents heading-link" heading-name="동작 방법"><span class="tree-item-title">동작 방법</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>